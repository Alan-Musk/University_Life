[Script Info]
Title: Lecture 22. Efficiency_哔哩哔哩_bilibili
ScriptType: v4.00+
Collisions: Reverse
PlayResX: 1280
PlayResY: 720
WrapStyle: 3
ScaledBorderAndShadow: yes
; ----------------------
; 本字幕由CC字幕助手自动转换
; 字幕来源https://www.bilibili.com/video/BV1s3411G7yM?p=54&vd_source=6ffca0aa1006734a4fba52f389036611
; 脚本地址https://greasyfork.org/scripts/378513
; 设置了字幕过长自动换行，但若字幕中没有空格换行将无效
; 字体大小依据720p 48号字体等比缩放
; 如显示不正常请尝试使用SRT格式

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Segoe UI,48,&H00FFFFFF,&HF0000000,&H00000000,&HF0000000,1,0,0,0,100,100,0,0.00,1,1,3,2,30,30,20,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.40,0:00:02.67,*Default,NTP,0000,0000,0000,,61 第 22 号选举
Dialogue: 0,0:00:02.97,0:00:04.07,*Default,NTP,0000,0000,0000,,公告
Dialogue: 0,0:00:05.50,0:00:07.67,*Default,NTP,0000,0000,0000,,本周星期二有实验课
Dialogue: 0,0:00:08.13,0:00:10.50,*Default,NTP,0000,0000,0000,,蚂蚁项目周五交
Dialogue: 0,0:00:10.57,0:00:14.37,*Default,NTP,0000,0000,0000,,但你们需要在周二之前完成第一和第二阶段的作业
Dialogue: 0,0:00:15.13,0:00:16.93,*Default,NTP,0000,0000,0000,,你可以获得提前提交奖励分
Dialogue: 0,0:00:16.93,0:00:18.57,*Default,NTP,0000,0000,0000,,提前提交整个项目
Dialogue: 0,0:00:18.87,0:00:21.70,*Default,NTP,0000,0000,0000,,我建议你尽量在周四之前完成
Dialogue: 0,0:00:22.47,0:00:27.10,*Default,NTP,0000,0000,0000,,家庭作业五将于下周一发布。
Dialogue: 0,0:00:27.47,0:00:30.60,*Default,NTP,0000,0000,0000,,这应该是对即将到来的期中考试的一次很好的复习
Dialogue: 0,0:00:31.47,0:00:34.33,*Default,NTP,0000,0000,0000,,下周的实验课只有一个必修部分
Dialogue: 0,0:00:34.33,0:00:36.33,*Default,NTP,0000,0000,0000,,即完成作业五
Dialogue: 0,0:00:36.57,0:00:37.17,*Default,NTP,0000,0000,0000,,还有一些
Dialogue: 0,0:00:37.17,0:00:39.33,*Default,NTP,0000,0000,0000,,还有一些选做题，可以给你更多的练习机会
Dialogue: 0,0:00:39.33,0:00:41.07,*Default,NTP,0000,0000,0000,,如果你想在期中考试中多练习的话
Dialogue: 0,0:00:41.40,0:00:43.87,*Default,NTP,0000,0000,0000,,但不会有任何必做的实验题
Dialogue: 0,0:00:43.87,0:00:46.27,*Default,NTP,0000,0000,0000,,除了下周一必须完成的作业题
Dialogue: 0,0:00:46.33,0:00:48.37,*Default,NTP,0000,0000,0000,,下周一交
Dialogue: 0,0:00:49.40,0:00:51.77,*Default,NTP,0000,0000,0000,,这是你最后一次填写薄弱环节八的机会
Dialogue: 0,0:00:51.77,0:00:53.17,*Default,NTP,0000,0000,0000,,匿名调查
Dialogue: 0,0:00:53.17,0:00:55.40,*Default,NTP,0000,0000,0000,,我们非常感谢你们的意见
Dialogue: 0,0:00:56.00,0:00:58.20,*Default,NTP,0000,0000,0000,,期中考试二即将到来
Dialogue: 0,0:00:58.50,0:01:02.67,*Default,NTP,0000,0000,0000,,一周后的周三，太平洋时间下午 7 点
Dialogue: 0,0:01:02.93,0:01:05.60,*Default,NTP,0000,0000,0000,,考试形式和风格与期中考试一相似
Dialogue: 0,0:01:05.73,0:01:09.10,*Default,NTP,0000,0000,0000,,内容包括上周五的讲座
Dialogue: 0,0:01:09.57,0:01:11.70,*Default,NTP,0000,0000,0000,,以及今天关于效率的讲座
Dialogue: 0,0:01:11.73,0:01:14.30,*Default,NTP,0000,0000,0000,,考试中不会涉及
Dialogue: 0,0:01:14.37,0:01:18.30,*Default,NTP,0000,0000,0000,,也不会在作业、实验或讨论中涉及
Dialogue: 0,0:01:18.57,0:01:21.20,*Default,NTP,0000,0000,0000,,这只是本学期的一个选修主题
Dialogue: 0,0:01:21.57,0:01:23.67,*Default,NTP,0000,0000,0000,,过去是必修的
Dialogue: 0,0:01:23.73,0:01:27.40,*Default,NTP,0000,0000,0000,,但我们只在 61 A 课中讲了一课
Dialogue: 0,0:01:27.60,0:01:30.67,*Default,NTP,0000,0000,0000,,而在 61 b 中你会听到很多关于它的内容。
Dialogue: 0,0:01:31.33,0:01:34.00,*Default,NTP,0000,0000,0000,,因此，最好能看一下这个讲座
Dialogue: 0,0:01:34.00,0:01:35.93,*Default,NTP,0000,0000,0000,,了解效率是什么
Dialogue: 0,0:01:35.93,0:01:38.57,*Default,NTP,0000,0000,0000,,但如果你选了 61 b
Dialogue: 0,0:01:38.60,0:01:40.10,*Default,NTP,0000,0000,0000,,就能学到所有相关知识
Dialogue: 0,0:01:40.10,0:01:41.53,*Default,NTP,0000,0000,0000,,你不会错过任何东西
Dialogue: 0,0:01:44.73,0:01:46.30,*Default,NTP,0000,0000,0000,,测量效率
Dialogue: 0,0:01:46.90,0:01:49.37,*Default,NTP,0000,0000,0000,,这不是关于特定对象
Dialogue: 0,0:01:49.70,0:01:50.97,*Default,NTP,0000,0000,0000,,而是关于如何
Dialogue: 0,0:01:50.97,0:01:53.53,*Default,NTP,0000,0000,0000,,了解程序运行所需的时间
Dialogue: 0,0:01:53.53,0:01:54.33,*Default,NTP,0000,0000,0000,,运行时间
Dialogue: 0,0:01:55.77,0:01:59.50,*Default,NTP,0000,0000,0000,,让我们回到第一个树递归的例子
Dialogue: 0,0:01:59.90,0:02:01.67,*Default,NTP,0000,0000,0000,,计算
Dialogue: 0,0:02:01.67,0:02:03.87,*Default,NTP,0000,0000,0000,,斐波那契数列元素的方法
Dialogue: 0,0:02:04.17,0:02:07.53,*Default,NTP,0000,0000,0000,,使用树递归的实现如下
Dialogue: 0,0:02:08.27,0:02:10.40,*Default,NTP,0000,0000,0000,,元素 0 为 0 元素 1 为 1
Dialogue: 0,0:02:10.40,0:02:12.80,*Default,NTP,0000,0000,0000,,其他所有元素都是前两个元素之和
Dialogue: 0,0:02:13.70,0:02:17.27,*Default,NTP,0000,0000,0000,,感谢斐波那契让这个数列如此流行
Dialogue: 0,0:02:18.13,0:02:20.27,*Default,NTP,0000,0000,0000,,如果我想计算斐波那契 5
Dialogue: 0,0:02:20.33,0:02:23.27,*Default,NTP,0000,0000,0000,,就需要将 fib3 和 fib4 的结果相加
Dialogue: 0,0:02:23.33,0:02:28.13,*Default,NTP,0000,0000,0000,,腓三意味着将一和二相加
Dialogue: 0,0:02:28.57,0:02:30.60,*Default,NTP,0000,0000,0000,,我在这里标出了基本情况
Dialogue: 0,0:02:30.70,0:02:32.87,*Default,NTP,0000,0000,0000,,标出了它们的返回值
Dialogue: 0,0:02:33.70,0:02:35.87,*Default,NTP,0000,0000,0000,,因此，要计算纤维三，我必须做所有这些工作
Dialogue: 0,0:02:35.87,0:02:38.80,*Default,NTP,0000,0000,0000,,要计算纤维四，我必须完成所有这些工作
Dialogue: 0,0:02:39.17,0:02:41.20,*Default,NTP,0000,0000,0000,,实际计算
Dialogue: 0,0:02:41.90,0:02:45.00,*Default,NTP,0000,0000,0000,,是这样进行的
Dialogue: 0,0:02:45.40,0:02:47.67,*Default,NTP,0000,0000,0000,,所以这个树形计算
Dialogue: 0,0:02:47.90,0:02:50.00,*Default,NTP,0000,0000,0000,,实际上是从调用 fip 5 开始的
Dialogue: 0,0:02:50.00,0:02:51.00,*Default,NTP,0000,0000,0000,,调用 fip 三
Dialogue: 0,0:02:51.00,0:02:52.30,*Default,NTP,0000,0000,0000,,然后调用 fip 1
Dialogue: 0,0:02:52.50,0:02:54.60,*Default,NTP,0000,0000,0000,,实际上返回的是 1
Dialogue: 0,0:02:55.47,0:02:58.13,*Default,NTP,0000,0000,0000,,接下来返回的是一个叫做纤维零的东西
Dialogue: 0,0:02:58.33,0:03:01.20,*Default,NTP,0000,0000,0000,,纤维 0 和纤维 1 将返回纤维 2
Dialogue: 0,0:03:01.93,0:03:02.90,*Default,NTP,0000,0000,0000,,然后我们可以
Dialogue: 0,0:03:02.93,0:03:05.77,*Default,NTP,0000,0000,0000,,最后，我们调用纤维三返回
Dialogue: 0,0:03:06.57,0:03:07.70,*Default,NTP,0000,0000,0000,,然后我们继续
Dialogue: 0,0:03:07.77,0:03:11.10,*Default,NTP,0000,0000,0000,,计算我们需要的其余值
Dialogue: 0,0:03:11.37,0:03:14.30,*Default,NTP,0000,0000,0000,,以最终返回纤维五
Dialogue: 0,0:03:15.40,0:03:17.00,*Default,NTP,0000,0000,0000,,所以我们想知道
Dialogue: 0,0:03:17.40,0:03:19.93,*Default,NTP,0000,0000,0000,,运行这个计算需要多长时间
Dialogue: 0,0:03:20.40,0:03:22.30,*Default,NTP,0000,0000,0000,,我们要做的第一件事就是计算
Dialogue: 0,0:03:22.30,0:03:23.77,*Default,NTP,0000,0000,0000,,调用
Dialogue: 0,0:03:23.90,0:03:27.17,*Default,NTP,0000,0000,0000,,看看增长情况
Dialogue: 0,0:03:29.47,0:03:35.70,*Default,NTP,0000,0000,0000,,如果等于 0 或等于 1，则返回 fib in
Dialogue: 0,0:03:36.57,0:03:37.37,*Default,NTP,0000,0000,0000,,否则
Dialogue: 0,0:03:37.47,0:03:42.73,*Default,NTP,0000,0000,0000,,return fib and minus two plus fib and minus one
Dialogue: 0,0:03:43.50,0:03:44.90,*Default,NTP,0000,0000,0000,,我知道这与
Dialogue: 0,0:03:44.90,0:03:46.17,*Default,NTP,0000,0000,0000,,我知道这与幻灯片上的内容略有不同
Dialogue: 0,0:03:46.27,0:03:48.00,*Default,NTP,0000,0000,0000,,但它会做同样的事情
Dialogue: 0,0:03:48.13,0:03:49.87,*Default,NTP,0000,0000,0000,,如果我运行这段代码
Dialogue: 0,0:03:50.00,0:03:51.80,*Default,NTP,0000,0000,0000,,并询问纤维 5 在哪里
Dialogue: 0,0:03:51.80,0:03:53.27,*Default,NTP,0000,0000,0000,,它会告诉我是 5
Dialogue: 0,0:03:53.47,0:03:54.70,*Default,NTP,0000,0000,0000,,纤维6是8
Dialogue: 0,0:03:54.93,0:03:57.37,*Default,NTP,0000,0000,0000,,纤维七是 13 等等
Dialogue: 0,0:03:58.57,0:04:02.40,*Default,NTP,0000,0000,0000,,现在我要做的是定义一个装饰器
Dialogue: 0,0:04:02.73,0:04:06.17,*Default,NTP,0000,0000,0000,,它接收函数 f
Dialogue: 0,0:04:07.27,0:04:09.80,*Default,NTP,0000,0000,0000,,返回一个新的计数版本 f
Dialogue: 0,0:04:10.93,0:04:12.93,*Default,NTP,0000,0000,0000,,的一个新的计数版本。
Dialogue: 0,0:04:13.57,0:04:17.27,*Default,NTP,0000,0000,0000,,不仅会返回结果，还会
Dialogue: 0,0:04:18.93,0:04:21.97,*Default,NTP,0000,0000,0000,,增加调用计数属性
Dialogue: 0,0:04:22.73,0:04:23.93,*Default,NTP,0000,0000,0000,,属性
Dialogue: 0,0:04:23.93,0:04:24.53,*Default,NTP,0000,0000,0000,,属性
Dialogue: 0,0:04:24.53,0:04:26.77,*Default,NTP,0000,0000,0000,,来记录该函数
Dialogue: 0,0:04:26.77,0:04:27.57,*Default,NTP,0000,0000,0000,,被调用的次数
Dialogue: 0,0:04:30.40,0:04:32.17,*Default,NTP,0000,0000,0000,,现在对于计数
Dialogue: 0,0:04:32.27,0:04:34.97,*Default,NTP,0000,0000,0000,,我们必须从调用次数为零开始
Dialogue: 0,0:04:34.97,0:04:36.70,*Default,NTP,0000,0000,0000,,这样我们以后就可以递增
Dialogue: 0,0:04:36.90,0:04:39.30,*Default,NTP,0000,0000,0000,,然后我们可以返回计数函数
Dialogue: 0,0:04:41.33,0:04:44.70,*Default,NTP,0000,0000,0000,,因此，我们可以在 count
Dialogue: 0,0:04:45.40,0:04:48.10,*Default,NTP,0000,0000,0000,,但我们只需要在
Dialogue: 0,0:04:48.20,0:04:49.57,*Default,NTP,0000,0000,0000,,交互会话中进行
Dialogue: 0,0:04:49.57,0:04:53.80,*Default,NTP,0000,0000,0000,,所以 fib 是 fib 的计数版本
Dialogue: 0,0:04:54.70,0:04:57.17,*Default,NTP,0000,0000,0000,,如果我在 5 次调用 fib
Dialogue: 0,0:04:57.27,0:05:00.47,*Default,NTP,0000,0000,0000,,我就可以问它被调用了多少次
Dialogue: 0,0:05:00.57,0:05:02.60,*Default,NTP,0000,0000,0000,,它被调用了 15 次
Dialogue: 0,0:05:03.90,0:05:06.90,*Default,NTP,0000,0000,0000,,现在这是累计的，所以如果我再次调用 fib 5
Dialogue: 0,0:05:07.00,0:05:09.20,*Default,NTP,0000,0000,0000,,调用次数就增加到了 30 次
Dialogue: 0,0:05:10.57,0:05:12.47,*Default,NTP,0000,0000,0000,,现在，如果我在某个
Dialogue: 0,0:05:12.87,0:05:15.13,*Default,NTP,0000,0000,0000,,大端，比如 30
Dialogue: 0,0:05:15.30,0:05:17.47,*Default,NTP,0000,0000,0000,,它会进行大量计算
Dialogue: 0,0:05:17.67,0:05:20.57,*Default,NTP,0000,0000,0000,,并得出 832 000
Dialogue: 0,0:05:20.80,0:05:24.40,*Default,NTP,0000,0000,0000,,但我调用这个函数的实际次数
Dialogue: 0,0:05:25.20,0:05:28.20,*Default,NTP,0000,0000,0000,,是 200 万次
Dialogue: 0,0:05:28.70,0:05:33.97,*Default,NTP,0000,0000,0000,,仅计算这一结果就调用了 269 万次 fip
Dialogue: 0,0:05:34.80,0:05:37.13,*Default,NTP,0000,0000,0000,,其中许多调用的返回值为零
Dialogue: 0,0:05:37.87,0:05:39.07,*Default,NTP,0000,0000,0000,,有些返回 1
Dialogue: 0,0:05:39.13,0:05:40.73,*Default,NTP,0000,0000,0000,,有的返回大数
Dialogue: 0,0:05:40.73,0:05:42.87,*Default,NTP,0000,0000,0000,,直到最终得到我们想要的结果
Dialogue: 0,0:05:43.53,0:05:45.90,*Default,NTP,0000,0000,0000,,所以我们可以理解为什么调用这个函数要花费很长时间。
Dialogue: 0,0:05:46.37,0:05:49.97,*Default,NTP,0000,0000,0000,,所以这个例子的重点是让我们开始理解
Dialogue: 0,0:05:50.50,0:05:53.20,*Default,NTP,0000,0000,0000,,调用函数时到底会发生什么
Dialogue: 0,0:05:54.10,0:05:56.47,*Default,NTP,0000,0000,0000,,与函数返回结果所需的时间之间的关系。
Dialogue: 0,0:05:56.47,0:05:57.97,*Default,NTP,0000,0000,0000,,函数返回
Dialogue: 0,0:05:58.60,0:06:00.37,*Default,NTP,0000,0000,0000,,我们一开始只是
Dialogue: 0,0:06:00.50,0:06:02.80,*Default,NTP,0000,0000,0000,,我们一开始只是计算调用次数
Dialogue: 0,0:06:03.13,0:06:05.17,*Default,NTP,0000,0000,0000,,但在接下来的两讲中
Dialogue: 0,0:06:05.17,0:06:06.80,*Default,NTP,0000,0000,0000,,更复杂的方法
Dialogue: 0,0:06:06.87,0:06:10.60,*Default,NTP,0000,0000,0000,,的方法。
Dialogue: 0,0:06:12.33,0:06:15.97,*Default,NTP,0000,0000,0000,,记忆是一种非常有用的技术
Dialogue: 0,0:06:16.13,0:06:20.13,*Default,NTP,0000,0000,0000,,加快程序运行时间的一种非常有用的技术
Dialogue: 0,0:06:21.37,0:06:23.00,*Default,NTP,0000,0000,0000,,以下是简单的思路
Dialogue: 0,0:06:23.50,0:06:24.00,*Default,NTP,0000,0000,0000,,只需
Dialogue: 0,0:06:24.00,0:06:26.87,*Default,NTP,0000,0000,0000,,记住之前计算过的结果
Dialogue: 0,0:06:27.47,0:06:29.40,*Default,NTP,0000,0000,0000,,这样当你需要重新计算
Dialogue: 0,0:06:29.40,0:06:31.30,*Default,NTP,0000,0000,0000,,当你再次需要它们的值时
Dialogue: 0,0:06:31.50,0:06:33.13,*Default,NTP,0000,0000,0000,,只需将它们保留下来
Dialogue: 0,0:06:34.30,0:06:35.87,*Default,NTP,0000,0000,0000,,这里还有一个装饰器
Dialogue: 0,0:06:36.57,0:06:37.70,*Default,NTP,0000,0000,0000,,名为 memo
Dialogue: 0,0:06:37.70,0:06:39.17,*Default,NTP,0000,0000,0000,,它接收一个函数
Dialogue: 0,0:06:39.33,0:06:41.40,*Default,NTP,0000,0000,0000,,可能需要一段时间来计算
Dialogue: 0,0:06:42.13,0:06:44.17,*Default,NTP,0000,0000,0000,,但我们也会保留
Dialogue: 0,0:06:44.17,0:06:46.93,*Default,NTP,0000,0000,0000,,函数返回的值
Dialogue: 0,0:06:46.93,0:06:47.73,*Default,NTP,0000,0000,0000,,在
Dialogue: 0,0:06:48.53,0:06:50.50,*Default,NTP,0000,0000,0000,,在 f 的备忘录化版本中
Dialogue: 0,0:06:51.27,0:06:52.57,*Default,NTP,0000,0000,0000,,我们首先检查
Dialogue: 0,0:06:52.57,0:06:55.37,*Default,NTP,0000,0000,0000,,传入的参数是否在现金中
Dialogue: 0,0:06:55.80,0:06:59.17,*Default,NTP,0000,0000,0000,,如果不在现金中，则将其添加到现金中
Dialogue: 0,0:06:59.57,0:07:03.70,*Default,NTP,0000,0000,0000,,也就是说，我们在键 n
Dialogue: 0,0:07:04.27,0:07:06.13,*Default,NTP,0000,0000,0000,,和返回值 f
Dialogue: 0,0:07:06.13,0:07:06.93,*Default,NTP,0000,0000,0000,,甚至
Dialogue: 0,0:07:07.40,0:07:09.13,*Default,NTP,0000,0000,0000,,现在我们实际上必须调用 f
Dialogue: 0,0:07:09.33,0:07:11.13,*Default,NTP,0000,0000,0000,,来计算这个返回值。
Dialogue: 0,0:07:11.33,0:07:13.70,*Default,NTP,0000,0000,0000,,来计算这个返回值
Dialogue: 0,0:07:14.37,0:07:16.07,*Default,NTP,0000,0000,0000,,但一旦它进入现金
Dialogue: 0,0:07:16.20,0:07:18.20,*Default,NTP,0000,0000,0000,,我们就不会再计算它了
Dialogue: 0,0:07:18.40,0:07:21.27,*Default,NTP,0000,0000,0000,,我们只需返回
Dialogue: 0,0:07:21.33,0:07:22.87,*Default,NTP,0000,0000,0000,,的返回值。
Dialogue: 0,0:07:24.13,0:07:25.87,*Default,NTP,0000,0000,0000,,一旦我返回到这个函数的
Dialogue: 0,0:07:25.87,0:07:27.20,*Default,NTP,0000,0000,0000,,版本的函数
Dialogue: 0,0:07:27.67,0:07:31.00,*Default,NTP,0000,0000,0000,,我将内置自动兑现功能
Dialogue: 0,0:07:32.53,0:07:33.73,*Default,NTP,0000,0000,0000,,所以我们在
Dialogue: 0,0:07:34.57,0:07:35.80,*Default,NTP,0000,0000,0000,,键和值之间的
Dialogue: 0,0:07:35.93,0:07:38.33,*Default,NTP,0000,0000,0000,,键和值之间的字典，其中键是参数
Dialogue: 0,0:07:38.37,0:07:41.17,*Default,NTP,0000,0000,0000,,的返回值。
Dialogue: 0,0:07:42.40,0:07:45.73,*Default,NTP,0000,0000,0000,,的返回值，这个 memoized 函数的行为与 f
Dialogue: 0,0:07:46.07,0:07:48.07,*Default,NTP,0000,0000,0000,,如果 f 是纯函数
Dialogue: 0,0:07:48.67,0:07:50.47,*Default,NTP,0000,0000,0000,,如果是非纯函数
Dialogue: 0,0:07:50.60,0:07:51.10,*Default,NTP,0000,0000,0000,,则
Dialogue: 0,0:07:51.10,0:07:54.27,*Default,NTP,0000,0000,0000,,我们并不是每次调用 memoized 时都调用 f
Dialogue: 0,0:07:54.30,0:07:55.97,*Default,NTP,0000,0000,0000,,所以可能会有不同的行为
Dialogue: 0,0:07:56.30,0:07:58.50,*Default,NTP,0000,0000,0000,,所以需要注意这一点
Dialogue: 0,0:07:58.60,0:08:00.27,*Default,NTP,0000,0000,0000,,您只能将
Dialogue: 0,0:08:00.27,0:08:02.30,*Default,NTP,0000,0000,0000,,纯函数，并期望它们的行为
Dialogue: 0,0:08:02.30,0:08:03.27,*Default,NTP,0000,0000,0000,,保持不变
Dialogue: 0,0:08:04.37,0:08:09.30,*Default,NTP,0000,0000,0000,,让我们看看使用 memo 加速 fib 时会发生什么
Dialogue: 0,0:08:10.97,0:08:12.93,*Default,NTP,0000,0000,0000,,的 memo 化版本
Dialogue: 0,0:08:14.13,0:08:15.70,*Default,NTP,0000,0000,0000,,的内存化版本
Dialogue: 0,0:08:19.67,0:08:21.37,*Default,NTP,0000,0000,0000,,的参数
Dialogue: 0,0:08:21.90,0:08:24.97,*Default,NTP,0000,0000,0000,,如果 in 不在现金中
Dialogue: 0,0:08:25.27,0:08:27.10,*Default,NTP,0000,0000,0000,,那么我们就把它放入现金
Dialogue: 0,0:08:28.50,0:08:31.00,*Default,NTP,0000,0000,0000,,用 f 事件的返回值
Dialogue: 0,0:08:31.93,0:08:35.60,*Default,NTP,0000,0000,0000,,我们每次都会返回现金中的内容，并返回
Dialogue: 0,0:08:36.13,0:08:37.17,*Default,NTP,0000,0000,0000,,memoized
Dialogue: 0,0:08:38.93,0:08:42.40,*Default,NTP,0000,0000,0000,,过去，fib 30 的计算需要一段时间
Dialogue: 0,0:08:42.80,0:08:44.33,*Default,NTP,0000,0000,0000,,但如果我们把 fib
Dialogue: 0,0:08:44.33,0:08:46.20,*Default,NTP,0000,0000,0000,,变成 memoized 版本的 fib
Dialogue: 0,0:08:47.00,0:08:50.07,*Default,NTP,0000,0000,0000,,那么我们可以很快计算出 fib 30
Dialogue: 0,0:08:50.27,0:08:55.33,*Default,NTP,0000,0000,0000,,事实上，我们可以很快计算出 fib 50 或 fib 300
Dialogue: 0,0:08:55.73,0:08:57.60,*Default,NTP,0000,0000,0000,,这是一个非常大的数字
Dialogue: 0,0:08:58.30,0:08:59.87,*Default,NTP,0000,0000,0000,,但计算起来并不难
Dialogue: 0,0:08:59.87,0:09:01.20,*Default,NTP,0000,0000,0000,,我们只需计算
Dialogue: 0,0:09:01.33,0:09:04.20,*Default,NTP,0000,0000,0000,,腓2908和腓2909
Dialogue: 0,0:09:05.10,0:09:06.97,*Default,NTP,0000,0000,0000,,我们几乎可以立即完成
Dialogue: 0,0:09:07.17,0:09:09.47,*Default,NTP,0000,0000,0000,,用这个 memoized 版本的 fib
Dialogue: 0,0:09:09.93,0:09:12.70,*Default,NTP,0000,0000,0000,,让我们看看是否能理解发生了什么。
Dialogue: 0,0:09:13.07,0:09:17.20,*Default,NTP,0000,0000,0000,,我重启了 python，所以 fib 又变慢了
Dialogue: 0,0:09:18.27,0:09:19.70,*Default,NTP,0000,0000,0000,,我们要做的是
Dialogue: 0,0:09:19.70,0:09:21.67,*Default,NTP,0000,0000,0000,,替换为计数版 fib
Dialogue: 0,0:09:21.87,0:09:25.20,*Default,NTP,0000,0000,0000,,这样我们就能知道它到底被调用了多少次
Dialogue: 0,0:09:26.47,0:09:29.40,*Default,NTP,0000,0000,0000,,我们将给计数版 fib 另取一个名字
Dialogue: 0,0:09:29.67,0:09:31.90,*Default,NTP,0000,0000,0000,,这样我们就可以访问它的属性
Dialogue: 0,0:09:32.93,0:09:35.90,*Default,NTP,0000,0000,0000,,现在，我要将 fib 改为 memoized
Dialogue: 0,0:09:35.90,0:09:37.37,*Default,NTP,0000,0000,0000,,计数版本
Dialogue: 0,0:09:39.17,0:09:40.00,*Default,NTP,0000,0000,0000,,而
Dialogue: 0,0:09:41.47,0:09:43.40,*Default,NTP,0000,0000,0000,,我们甚至可以计算
Dialogue: 0,0:09:44.90,0:09:47.07,*Default,NTP,0000,0000,0000,,我们将在 30 时调用 fib
Dialogue: 0,0:09:47.67,0:09:49.57,*Default,NTP,0000,0000,0000,,立即完成
Dialogue: 0,0:09:52.13,0:09:57.80,*Default,NTP,0000,0000,0000,,共有 59 次调用哺乳动物化版本的 fib
Dialogue: 0,0:09:58.33,0:10:00.10,*Default,NTP,0000,0000,0000,,其中一些调用了现金
Dialogue: 0,0:10:00.20,0:10:01.07,*Default,NTP,0000,0000,0000,,其中一些
Dialogue: 0,0:10:01.07,0:10:04.50,*Default,NTP,0000,0000,0000,,实际上调用了底层的原始 fib 函数
Dialogue: 0,0:10:04.80,0:10:07.77,*Default,NTP,0000,0000,0000,,在本例中，我们将其称为计数 fib
Dialogue: 0,0:10:08.13,0:10:10.30,*Default,NTP,0000,0000,0000,,其调用次数为 31
Dialogue: 0,0:10:11.20,0:10:12.60,*Default,NTP,0000,0000,0000,,为什么是 31
Dialogue: 0,0:10:13.17,0:10:17.30,*Default,NTP,0000,0000,0000,,因为我们要传递 31 个不同的参数
Dialogue: 0,0:10:18.07,0:10:19.50,*Default,NTP,0000,0000,0000,,329
Dialogue: 0,0:10:19.50,0:10:22.40,*Default,NTP,0000,0000,0000,,二十八一直到零
Dialogue: 0,0:10:23.20,0:10:24.27,*Default,NTP,0000,0000,0000,,这就是
Dialogue: 0,0:10:24.27,0:10:27.30,*Default,NTP,0000,0000,0000,,我们调用原始函数的次数
Dialogue: 0,0:10:28.00,0:10:29.67,*Default,NTP,0000,0000,0000,,那么 59 呢？
Dialogue: 0,0:10:29.97,0:10:32.47,*Default,NTP,0000,0000,0000,,让我们看看发生了什么
Dialogue: 0,0:10:34.17,0:10:37.17,*Default,NTP,0000,0000,0000,,这是我们的树状结构递归过程
Dialogue: 0,0:10:37.87,0:10:40.97,*Default,NTP,0000,0000,0000,,我们将记录实际调用 fib
Dialogue: 0,0:10:41.47,0:10:44.40,*Default,NTP,0000,0000,0000,,的实际调用次数。
Dialogue: 0,0:10:44.40,0:10:46.73,*Default,NTP,0000,0000,0000,,并在现金
Dialogue: 0,0:10:47.20,0:10:50.07,*Default,NTP,0000,0000,0000,,和完全跳过的次数
Dialogue: 0,0:10:50.33,0:10:52.87,*Default,NTP,0000,0000,0000,,一定有很多次我们是完全跳过的
Dialogue: 0,0:10:52.87,0:10:55.93,*Default,NTP,0000,0000,0000,,因为我们的调用次数比以前少了很多
Dialogue: 0,0:10:59.33,0:11:01.70,*Default,NTP,0000,0000,0000,,所以我们调用了 fib 5，它调用了 fib 3
Dialogue: 0,0:11:01.70,0:11:02.97,*Default,NTP,0000,0000,0000,,调用 fib 1
Dialogue: 0,0:11:03.30,0:11:04.80,*Default,NTP,0000,0000,0000,,返回 1
Dialogue: 0,0:11:05.00,0:11:07.47,*Default,NTP,0000,0000,0000,,这是对 fib 函数的实际调用
Dialogue: 0,0:11:07.90,0:11:09.77,*Default,NTP,0000,0000,0000,,所以这就是所谓的 fib 0
Dialogue: 0,0:11:10.60,0:11:12.70,*Default,NTP,0000,0000,0000,,但下一次调用 fib one
Dialogue: 0,0:11:12.90,0:11:14.00,*Default,NTP,0000,0000,0000,,我们只会得到
Dialogue: 0,0:11:14.10,0:11:17.33,*Default,NTP,0000,0000,0000,,我们已经从现金中计算出的值
Dialogue: 0,0:11:17.77,0:11:18.53,*Default,NTP,0000,0000,0000,,所以这不算
Dialogue: 0,0:11:18.53,0:11:21.10,*Default,NTP,0000,0000,0000,,算作对底层 fib 函数的调用
Dialogue: 0,0:11:21.20,0:11:23.93,*Default,NTP,0000,0000,0000,,但可以算作对 memoized 版本的调用
Dialogue: 0,0:11:25.57,0:11:28.67,*Default,NTP,0000,0000,0000,,纤维二返回，然后纤维三返回
Dialogue: 0,0:11:28.93,0:11:31.70,*Default,NTP,0000,0000,0000,,接下来我们调用
Dialogue: 0,0:11:32.70,0:11:35.87,*Default,NTP,0000,0000,0000,,fib four 调用 fib two
Dialogue: 0,0:11:36.27,0:11:38.33,*Default,NTP,0000,0000,0000,,这意味着我们可以跳过
Dialogue: 0,0:11:38.53,0:11:40.07,*Default,NTP,0000,0000,0000,,这意味着我们可以完全跳过
Dialogue: 0,0:11:40.07,0:11:42.80,*Default,NTP,0000,0000,0000,,对 fib 0 和 fib 1 的调用
Dialogue: 0,0:11:42.90,0:11:44.77,*Default,NTP,0000,0000,0000,,它们根本不会发生
Dialogue: 0,0:11:45.50,0:11:47.97,*Default,NTP,0000,0000,0000,,这是因为这个结构是
Dialogue: 0,0:11:47.97,0:11:50.50,*Default,NTP,0000,0000,0000,,重复了我们之前的工作
Dialogue: 0,0:11:50.93,0:11:52.93,*Default,NTP,0000,0000,0000,,所以我们马上就能找到纤维二
Dialogue: 0,0:11:53.10,0:11:53.97,*Default,NTP,0000,0000,0000,,而当我们
Dialogue: 0,0:11:54.17,0:11:57.80,*Default,NTP,0000,0000,0000,,调用纤维三时，我们也会立即找到结果
Dialogue: 0,0:11:58.20,0:12:00.27,*Default,NTP,0000,0000,0000,,跳过这些递归调用
Dialogue: 0,0:12:01.37,0:12:03.10,*Default,NTP,0000,0000,0000,,因此，将纤维二放入纤维三
Dialogue: 0,0:12:03.10,0:12:05.70,*Default,NTP,0000,0000,0000,,我们最终可以从纤维四返回
Dialogue: 0,0:12:06.33,0:12:08.77,*Default,NTP,0000,0000,0000,,然后从纤维五返回
Dialogue: 0,0:12:09.80,0:12:12.40,*Default,NTP,0000,0000,0000,,因此，正如你所看到的，对于每个 n 值
Dialogue: 0,0:12:12.47,0:12:14.93,*Default,NTP,0000,0000,0000,,fib 都会被调用一次
Dialogue: 0,0:12:15.20,0:12:17.80,*Default,NTP,0000,0000,0000,,而对于许多 n
Dialogue: 0,0:12:18.50,0:12:21.90,*Default,NTP,0000,0000,0000,,fib 的 memoized 版本会被调用第二次
Dialogue: 0,0:12:22.37,0:12:24.37,*Default,NTP,0000,0000,0000,,以完成计算
Dialogue: 0,0:12:25.30,0:12:27.27,*Default,NTP,0000,0000,0000,,但 fib 4 从不被调用第二次
Dialogue: 0,0:12:27.27,0:12:28.67,*Default,NTP,0000,0000,0000,,而 fib 5 也不会
Dialogue: 0,0:12:30.53,0:12:32.30,*Default,NTP,0000,0000,0000,,让我们看一个例子
Dialogue: 0,0:12:32.60,0:12:36.77,*Default,NTP,0000,0000,0000,,我们可以用两种不同的方法定义一个函数
Dialogue: 0,0:12:36.90,0:12:40.10,*Default,NTP,0000,0000,0000,,其中一种方法比另一种方法更高效
Dialogue: 0,0:12:41.17,0:12:44.17,*Default,NTP,0000,0000,0000,,python 内置了指数化功能
Dialogue: 0,0:12:44.17,0:12:47.13,*Default,NTP,0000,0000,0000,,我可以将一个数字提升到另一个数字的幂级数
Dialogue: 0,0:12:48.07,0:12:51.53,*Default,NTP,0000,0000,0000,,但让我们用递归方式写一个指数函数
Dialogue: 0,0:12:52.27,0:12:54.90,*Default,NTP,0000,0000,0000,,我们的目标是
Dialogue: 0,0:12:55.17,0:12:59.80,*Default,NTP,0000,0000,0000,,再做一次乘法就能让指数翻倍
Dialogue: 0,0:12:59.80,0:13:02.20,*Default,NTP,0000,0000,0000,,我们使用的是指数函数
Dialogue: 0,0:13:03.67,0:13:06.90,*Default,NTP,0000,0000,0000,,下面是一个无法实现这一目标的实现方法
Dialogue: 0,0:13:07.33,0:13:09.80,*Default,NTP,0000,0000,0000,,这里说的是将 b 提升到 n 的幂级数
Dialogue: 0,0:13:09.80,0:13:11.70,*Default,NTP,0000,0000,0000,,如果 n 为零，返回 1
Dialogue: 0,0:13:11.73,0:13:14.10,*Default,NTP,0000,0000,0000,,否则乘以
Dialogue: 0,0:13:14.70,0:13:17.13,*Default,NTP,0000,0000,0000,,将 b 乘以 n 减 1
Dialogue: 0,0:13:18.10,0:13:20.33,*Default,NTP,0000,0000,0000,,这是一个正确的定义
Dialogue: 0,0:13:20.73,0:13:22.40,*Default,NTP,0000,0000,0000,,但如果将
Dialogue: 0,0:13:22.77,0:13:26.17,*Default,NTP,0000,0000,0000,,我必须做两倍的乘法运算
Dialogue: 0,0:13:26.57,0:13:29.50,*Default,NTP,0000,0000,0000,,因为每次递归调用
Dialogue: 0,0:13:29.67,0:13:32.07,*Default,NTP,0000,0000,0000,,我只是将 n 减一
Dialogue: 0,0:13:33.50,0:13:37.07,*Default,NTP,0000,0000,0000,,这个函数的实现与
Dialogue: 0,0:13:37.13,0:13:39.57,*Default,NTP,0000,0000,0000,,与下面的数学定义相对应
Dialogue: 0,0:13:39.57,0:13:40.93,*Default,NTP,0000,0000,0000,,for b 至末尾
Dialogue: 0,0:13:41.60,0:13:42.73,*Default,NTP,0000,0000,0000,,但这并不是
Dialogue: 0,0:13:42.73,0:13:45.10,*Default,NTP,0000,0000,0000,,的数学定义
Dialogue: 0,0:13:45.80,0:13:46.97,*Default,NTP,0000,0000,0000,,下面是另一个
Dialogue: 0,0:13:47.50,0:13:48.90,*Default,NTP,0000,0000,0000,,更复杂
Dialogue: 0,0:13:48.93,0:13:51.07,*Default,NTP,0000,0000,0000,,但额外的复杂性
Dialogue: 0,0:13:51.10,0:13:54.07,*Default,NTP,0000,0000,0000,,也会给我们带来额外的效率
Dialogue: 0,0:13:55.10,0:13:57.87,*Default,NTP,0000,0000,0000,,这里说，如果 n 为零，则 b 至 n 为一
Dialogue: 0,0:13:57.93,0:13:59.77,*Default,NTP,0000,0000,0000,,然后有两种不同的情况
Dialogue: 0,0:13:59.77,0:14:01.77,*Default,NTP,0000,0000,0000,,n 是否为偶数
Dialogue: 0,0:14:02.57,0:14:03.80,*Default,NTP,0000,0000,0000,,如果 n 是偶数
Dialogue: 0,0:14:04.50,0:14:08.70,*Default,NTP,0000,0000,0000,,那么我可以将 b 减去 n 的二分之一次方
Dialogue: 0,0:14:09.17,0:14:11.10,*Default,NTP,0000,0000,0000,,并将结果平方
Dialogue: 0,0:14:12.33,0:14:15.33,*Default,NTP,0000,0000,0000,,因此，如果 n 是 16，我把 b 升到 8
Dialogue: 0,0:14:15.70,0:14:19.50,*Default,NTP,0000,0000,0000,,然后将 b 平方到 8，得到 b 的 16
Dialogue: 0,0:14:20.67,0:14:23.97,*Default,NTP,0000,0000,0000,,如果 n 为奇数，则使用之前的定义
Dialogue: 0,0:14:24.30,0:14:25.80,*Default,NTP,0000,0000,0000,,下面是一个实现方法
Dialogue: 0,0:14:26.73,0:14:29.90,*Default,NTP,0000,0000,0000,,这是一个更高效的指数化版本
Dialogue: 0,0:14:29.90,0:14:32.50,*Default,NTP,0000,0000,0000,,它有两种不同的递归情况
Dialogue: 0,0:14:32.57,0:14:34.40,*Default,NTP,0000,0000,0000,,取决于 n 是否为偶数
Dialogue: 0,0:14:34.80,0:14:36.97,*Default,NTP,0000,0000,0000,,如果是偶数，则将
Dialogue: 0,0:14:37.47,0:14:41.00,*Default,NTP,0000,0000,0000,,的结果除以 2
Dialogue: 0,0:14:41.93,0:14:43.80,*Default,NTP,0000,0000,0000,,我知道 n 是偶数
Dialogue: 0,0:14:43.80,0:14:47.27,*Default,NTP,0000,0000,0000,,所以底除会得到准确的结果
Dialogue: 0,0:14:47.50,0:14:48.80,*Default,NTP,0000,0000,0000,,如果 n 是奇数
Dialogue: 0,0:14:49.00,0:14:51.27,*Default,NTP,0000,0000,0000,,那么我就使用以前的定义
Dialogue: 0,0:14:51.87,0:14:54.20,*Default,NTP,0000,0000,0000,,这不是树递归函数
Dialogue: 0,0:14:54.77,0:14:57.47,*Default,NTP,0000,0000,0000,,尽管我在
Dialogue: 0,0:14:57.50,0:15:00.17,*Default,NTP,0000,0000,0000,,调用
Dialogue: 0,0:15:00.47,0:15:02.57,*Default,NTP,0000,0000,0000,,只调用了其中一个
Dialogue: 0,0:15:02.90,0:15:05.73,*Default,NTP,0000,0000,0000,,所以这是一个线性递归的实例
Dialogue: 0,0:15:06.27,0:15:11.20,*Default,NTP,0000,0000,0000,,有时问题的大小会减半
Dialogue: 0,0:15:11.80,0:15:14.30,*Default,NTP,0000,0000,0000,,也就是多做一次乘法运算
Dialogue: 0,0:15:14.60,0:15:16.77,*Default,NTP,0000,0000,0000,,在这种情况下，调用 square
Dialogue: 0,0:15:17.07,0:15:19.80,*Default,NTP,0000,0000,0000,,的乘法运算，就能将我们正在处理的
Dialogue: 0,0:15:19.80,0:15:21.30,*Default,NTP,0000,0000,0000,,我们正在处理的
Dialogue: 0,0:15:21.67,0:15:23.73,*Default,NTP,0000,0000,0000,,x 快速运行速度更快
Dialogue: 0,0:15:23.80,0:15:25.00,*Default,NTP,0000,0000,0000,,让我们来看看
Dialogue: 0,0:15:25.77,0:15:28.50,*Default,NTP,0000,0000,0000,,这个环境叫做朱庇特笔记本
Dialogue: 0,0:15:28.87,0:15:30.60,*Default,NTP,0000,0000,0000,,你可以在网上读到
Dialogue: 0,0:15:30.73,0:15:34.93,*Default,NTP,0000,0000,0000,,它是人们常用的一种方式，用于执行
Dialogue: 0,0:15:35.10,0:15:39.93,*Default,NTP,0000,0000,0000,,当输出是图形或图表时，人们常用这种方式来执行 python 代码。
Dialogue: 0,0:15:41.27,0:15:44.07,*Default,NTP,0000,0000,0000,,这就是我们对 "慢速运行 "的定义
Dialogue: 0,0:15:44.70,0:15:45.87,*Default,NTP,0000,0000,0000,,的定义
Dialogue: 0,0:15:45.87,0:15:47.37,*Default,NTP,0000,0000,0000,,在这个笔记本环境中
Dialogue: 0,0:15:47.40,0:15:50.13,*Default,NTP,0000,0000,0000,,就是我们可以计算运行某程序所需的时间
Dialogue: 0,0:15:50.57,0:15:53.20,*Default,NTP,0000,0000,0000,,因此，如果我将 2 的幂级数提高到 104
Dialogue: 0,0:15:54.10,0:15:57.17,*Default,NTP,0000,0000,0000,,所花费的时间是[2]毫秒
Dialogue: 0,0:15:57.60,0:15:59.67,*Default,NTP,0000,0000,0000,,如果我把 2 提升到 100 次幂
Dialogue: 0,0:16:00.27,0:16:03.70,*Default,NTP,0000,0000,0000,,我只花了 100 微秒
Dialogue: 0,0:16:03.87,0:16:04.97,*Default,NTP,0000,0000,0000,,但如果我再运行一次
Dialogue: 0,0:16:04.97,0:16:07.00,*Default,NTP,0000,0000,0000,,每次得到的数字都不一样
Dialogue: 0,0:16:07.50,0:16:08.90,*Default,NTP,0000,0000,0000,,所以如果我多次运行
Dialogue: 0,0:16:08.90,0:16:11.90,*Default,NTP,0000,0000,0000,,我看到它徘徊在100微秒左右
Dialogue: 0,0:16:12.37,0:16:15.80,*Default,NTP,0000,0000,0000,,2到104次方往往徘徊在
Dialogue: 0,0:16:16.17,0:16:17.87,*Default,NTP,0000,0000,0000,,200 微秒
Dialogue: 0,0:16:18.50,0:16:21.10,*Default,NTP,0000,0000,0000,,这样多次运行效率很低
Dialogue: 0,0:16:21.10,0:16:24.10,*Default,NTP,0000,0000,0000,,因此，我编写了一些代码，使用内置的 timet 模块多次运行
Dialogue: 0,0:16:24.47,0:16:27.00,*Default,NTP,0000,0000,0000,,使用内置的 timet 模块
Dialogue: 0,0:16:27.20,0:16:29.13,*Default,NTP,0000,0000,0000,,可以重复调用
Dialogue: 0,0:16:29.37,0:16:30.27,*Default,NTP,0000,0000,0000,,在这种情况下
Dialogue: 0,0:16:30.27,0:16:33.30,*Default,NTP,0000,0000,0000,,我们要计算的是
Dialogue: 0,0:16:33.40,0:16:36.97,*Default,NTP,0000,0000,0000,,执行某行代码
Dialogue: 0,0:16:37.50,0:16:38.90,*Default,NTP,0000,0000,0000,,结果如下
Dialogue: 0,0:16:39.07,0:16:40.80,*Default,NTP,0000,0000,0000,,二的 102 次方
Dialogue: 0,0:16:41.10,0:16:43.60,*Default,NTP,0000,0000,0000,,每秒不到半毫秒
Dialogue: 0,0:16:43.60,0:16:45.33,*Default,NTP,0000,0000,0000,,二的 104 次方
Dialogue: 0,0:16:45.40,0:16:47.80,*Default,NTP,0000,0000,0000,,每秒少于一百万
Dialogue: 0,0:16:47.97,0:16:49.73,*Default,NTP,0000,0000,0000,,这看起来像一条直线
Dialogue: 0,0:16:50.30,0:16:53.70,*Default,NTP,0000,0000,0000,,我们用来描述它的术语是线性
Dialogue: 0,0:16:54.20,0:16:57.47,*Default,NTP,0000,0000,0000,,计算 2 的 n 次方所需的时间是 n 的线性关系。
Dialogue: 0,0:16:57.67,0:17:01.77,*Default,NTP,0000,0000,0000,,的时间是 n 的线性
Dialogue: 0,0:17:02.53,0:17:04.30,*Default,NTP,0000,0000,0000,,现在有点颠簸
Dialogue: 0,0:17:04.47,0:17:06.50,*Default,NTP,0000,0000,0000,,因为计算机内部
Dialogue: 0,0:17:06.50,0:17:08.37,*Default,NTP,0000,0000,0000,,在计算机内部发生
Dialogue: 0,0:17:08.67,0:17:10.97,*Default,NTP,0000,0000,0000,,但使用了线性这个词
Dialogue: 0,0:17:11.00,0:17:14.07,*Default,NTP,0000,0000,0000,,即使有轻微的偏差
Dialogue: 0,0:17:14.37,0:17:17.37,*Default,NTP,0000,0000,0000,,来描述出现的总体趋势
Dialogue: 0,0:17:17.50,0:17:20.53,*Default,NTP,0000,0000,0000,,当你绘制计算某项内容所需的时间与输入大小的函数关系图时
Dialogue: 0,0:17:20.60,0:17:23.20,*Default,NTP,0000,0000,0000,,与输入大小的函数关系时所呈现的总体趋势
Dialogue: 0,0:17:23.30,0:17:25.17,*Default,NTP,0000,0000,0000,,以下是快速定义
Dialogue: 0,0:17:25.47,0:17:27.33,*Default,NTP,0000,0000,0000,,我们可以绘制同样的曲线图
Dialogue: 0,0:17:27.53,0:17:28.47,*Default,NTP,0000,0000,0000,,我们会发现
Dialogue: 0,0:17:28.47,0:17:31.27,*Default,NTP,0000,0000,0000,,整体数字要小得多
Dialogue: 0,0:17:32.20,0:17:35.57,*Default,NTP,0000,0000,0000,,为 1600，而不是取
Dialogue: 0,0:17:35.77,0:17:37.30,*Default,NTP,0000,0000,0000,,[四]毫秒
Dialogue: 0,0:17:37.30,0:17:40.60,*Default,NTP,0000,0000,0000,,只需要 [point, zero, four]millisecond
Dialogue: 0,0:17:40.97,0:17:43.93,*Default,NTP,0000,0000,0000,,曲线的形状也不同
Dialogue: 0,0:17:44.60,0:17:47.30,*Default,NTP,0000,0000,0000,,这种形状被称为对数曲线
Dialogue: 0,0:17:48.00,0:17:51.73,*Default,NTP,0000,0000,0000,,从 200 到 400
Dialogue: 0,0:17:51.90,0:17:57.00,*Default,NTP,0000,0000,0000,,在本例中仅为 002 点
Dialogue: 0,0:17:58.20,0:17:59.70,*Default,NTP,0000,0000,0000,,那么
Dialogue: 0,0:17:59.80,0:18:02.50,*Default,NTP,0000,0000,0000,,从 400 到 800
Dialogue: 0,0:18:02.57,0:18:04.17,*Default,NTP,0000,0000,0000,,这又是一个点
Dialogue: 0,0:18:04.17,0:18:05.87,*Default,NTP,0000,0000,0000,,哦，哦，二
Dialogue: 0,0:18:06.50,0:18:10.93,*Default,NTP,0000,0000,0000,,从 800 到 1600 又是一个点，哦，两个
Dialogue: 0,0:18:11.40,0:18:13.53,*Default,NTP,0000,0000,0000,,每次我们把输入量增加一倍
Dialogue: 0,0:18:13.67,0:18:17.20,*Default,NTP,0000,0000,0000,,都需要持续的额外工作
Dialogue: 0,0:18:17.53,0:18:21.80,*Default,NTP,0000,0000,0000,,这是因为我们在 n 上进行递归调用
Dialogue: 0,0:18:21.80,0:18:23.90,*Default,NTP,0000,0000,0000,,的一半
Dialogue: 0,0:18:24.53,0:18:27.20,*Default,NTP,0000,0000,0000,,这就是所谓的对数时间
Dialogue: 0,0:18:27.93,0:18:29.27,*Default,NTP,0000,0000,0000,,所以总结一下
Dialogue: 0,0:18:29.30,0:18:31.27,*Default,NTP,0000,0000,0000,,一个线性时间函数
Dialogue: 0,0:18:31.30,0:18:33.77,*Default,NTP,0000,0000,0000,,需要增加一个工作单位
Dialogue: 0,0:18:34.00,0:18:36.73,*Default,NTP,0000,0000,0000,,每增加一个末端
Dialogue: 0,0:18:37.13,0:18:39.97,*Default,NTP,0000,0000,0000,,也就是说，输入量增加一倍，时间增加一倍
Dialogue: 0,0:18:40.30,0:18:44.20,*Default,NTP,0000,0000,0000,,而 1000 倍的输入则需要 1000 倍的时间
Dialogue: 0,0:18:44.97,0:18:48.90,*Default,NTP,0000,0000,0000,,1024 是 2 的 10 次方
Dialogue: 0,0:18:50.27,0:18:52.10,*Default,NTP,0000,0000,0000,,对数时间更好
Dialogue: 0,0:18:52.93,0:18:54.27,*Default,NTP,0000,0000,0000,,输入量增加一倍
Dialogue: 0,0:18:54.30,0:18:57.30,*Default,NTP,0000,0000,0000,,只需将时间增加某个常数
Dialogue: 0,0:18:57.47,0:18:59.37,*Default,NTP,0000,0000,0000,,而 1000 倍的输入
Dialogue: 0,0:18:59.50,0:19:02.87,*Default,NTP,0000,0000,0000,,只需增加该常数的 10 倍
Dialogue: 0,0:19:03.13,0:19:05.07,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:19:05.10,0:19:07.40,*Default,NTP,0000,0000,0000,,做 1000 倍的工作
Dialogue: 0,0:19:08.07,0:19:10.50,*Default,NTP,0000,0000,0000,,这些术语线性和对数
Dialogue: 0,0:19:10.70,0:19:13.53,*Default,NTP,0000,0000,0000,,用来描述时间与输入量大小
Dialogue: 0,0:19:13.57,0:19:16.47,*Default,NTP,0000,0000,0000,,时间与输入大小的函数关系
Dialogue: 0,0:19:16.80,0:19:19.60,*Default,NTP,0000,0000,0000,,即使一路上有摇摆和颠簸
Dialogue: 0,0:19:22.77,0:19:24.57,*Default,NTP,0000,0000,0000,,增长顺序
Dialogue: 0,0:19:24.57,0:19:26.37,*Default,NTP,0000,0000,0000,,的增长顺序
Dialogue: 0,0:19:26.37,0:19:29.00,*Default,NTP,0000,0000,0000,,的增长顺序
Dialogue: 0,0:19:29.10,0:19:32.70,*Default,NTP,0000,0000,0000,,是函数所属的一般类别
Dialogue: 0,0:19:33.10,0:19:35.87,*Default,NTP,0000,0000,0000,,如线性或对数
Dialogue: 0,0:19:36.77,0:19:40.27,*Default,NTP,0000,0000,0000,,使用线性时间的两个函数
Dialogue: 0,0:19:40.50,0:19:43.30,*Default,NTP,0000,0000,0000,,所需的时间可能不完全相同
Dialogue: 0,0:19:43.30,0:19:45.97,*Default,NTP,0000,0000,0000,,计算结果所需的时间可能不完全相同
Dialogue: 0,0:19:46.27,0:19:48.90,*Default,NTP,0000,0000,0000,,但它们的缩放方式相同
Dialogue: 0,0:19:49.17,0:19:52.30,*Default,NTP,0000,0000,0000,,它们的缩放曲线的一般形状
Dialogue: 0,0:19:52.47,0:19:54.00,*Default,NTP,0000,0000,0000,,都是直线
Dialogue: 0,0:19:54.67,0:19:56.57,*Default,NTP,0000,0000,0000,,和对数函数
Dialogue: 0,0:19:56.57,0:20:00.37,*Default,NTP,0000,0000,0000,,它们都具有相同的对数特征形状
Dialogue: 0,0:20:01.17,0:20:03.33,*Default,NTP,0000,0000,0000,,还有其他形状
Dialogue: 0,0:20:04.60,0:20:05.93,*Default,NTP,0000,0000,0000,,二次时间
Dialogue: 0,0:20:06.07,0:20:07.60,*Default,NTP,0000,0000,0000,,描述了一个函数
Dialogue: 0,0:20:07.73,0:20:13.67,*Default,NTP,0000,0000,0000,,处理线性输入中的所有元素对
Dialogue: 0,0:20:14.13,0:20:18.07,*Default,NTP,0000,0000,0000,,或长度为 n 的序列中的所有值对的函数
Dialogue: 0,0:20:18.60,0:20:19.97,*Default,NTP,0000,0000,0000,,例如
Dialogue: 0,0:20:20.10,0:20:22.70,*Default,NTP,0000,0000,0000,,下面是一个计算重叠的函数
Dialogue: 0,0:20:22.97,0:20:26.10,*Default,NTP,0000,0000,0000,,中的元素之间的关系
Dialogue: 0,0:20:26.47,0:20:28.37,*Default,NTP,0000,0000,0000,,中的每个元素
Dialogue: 0,0:20:28.77,0:20:30.47,*Default,NTP,0000,0000,0000,,中的每个元素
Dialogue: 0,0:20:30.87,0:20:33.00,*Default,NTP,0000,0000,0000,,并检查它们是否相同
Dialogue: 0,0:20:33.67,0:20:35.47,*Default,NTP,0000,0000,0000,,如果相同，则加上计数
Dialogue: 0,0:20:35.67,0:20:37.77,*Default,NTP,0000,0000,0000,,并将计数返回到结尾
Dialogue: 0,0:20:38.07,0:20:39.00,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:20:39.00,0:20:42.73,*Default,NTP,0000,0000,0000,,因此，3 5 7 6 和 4 5 6 5 之间的重叠数
Dialogue: 0,0:20:42.90,0:20:45.40,*Default,NTP,0000,0000,0000,,是三个，因为五个五个是相同的
Dialogue: 0,0:20:45.57,0:20:48.67,*Default,NTP,0000,0000,0000,,五五相同，六六相同
Dialogue: 0,0:20:49.57,0:20:51.17,*Default,NTP,0000,0000,0000,,为了计算这个结果
Dialogue: 0,0:20:51.50,0:20:55.10,*Default,NTP,0000,0000,0000,,重叠比较 a 中元素和 b 中元素的所有对
Dialogue: 0,0:20:55.17,0:20:56.67,*Default,NTP,0000,0000,0000,,和 b 中元素的所有对
Dialogue: 0,0:20:57.00,0:20:59.80,*Default,NTP,0000,0000,0000,,这是一个四等分的工作量
Dialogue: 0,0:21:00.33,0:21:02.27,*Default,NTP,0000,0000,0000,,基于输入长度
Dialogue: 0,0:21:02.60,0:21:04.50,*Default,NTP,0000,0000,0000,,这里的输入长度是 4
Dialogue: 0,0:21:04.67,0:21:08.90,*Default,NTP,0000,0000,0000,,比较的数量是 4 乘以 4 或 16
Dialogue: 0,0:21:09.57,0:21:11.73,*Default,NTP,0000,0000,0000,,处理长度为 4
Dialogue: 0,0:21:12.07,0:21:15.77,*Default,NTP,0000,0000,0000,,处理长度为 4 和长度为 3 的数据所需的额外工作量
Dialogue: 0,0:21:16.07,0:21:17.67,*Default,NTP,0000,0000,0000,,是这整行
Dialogue: 0,0:21:17.73,0:21:18.93,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:21:18.93,0:21:20.90,*Default,NTP,0000,0000,0000,,如果将输入大小
Dialogue: 0,0:21:20.90,0:21:23.50,*Default,NTP,0000,0000,0000,,计算结果所需的时间
Dialogue: 0,0:21:23.67,0:21:25.90,*Default,NTP,0000,0000,0000,,你会得到一个二次方形状
Dialogue: 0,0:21:26.60,0:21:28.50,*Default,NTP,0000,0000,0000,,因此，当我们输入
Dialogue: 0,0:21:28.50,0:21:31.97,*Default,NTP,0000,0000,0000,,从 20 到 200 的两端
Dialogue: 0,0:21:32.47,0:21:34.30,*Default,NTP,0000,0000,0000,,并计算
Dialogue: 0,0:21:34.30,0:21:36.93,*Default,NTP,0000,0000,0000,,所需的中位时间
Dialogue: 0,0:21:37.27,0:21:40.10,*Default,NTP,0000,0000,0000,,75需要[2]毫秒
Dialogue: 0,0:21:40.30,0:21:44.87,*Default,NTP,0000,0000,0000,,而 150 则需要近 [8]毫秒
Dialogue: 0,0:21:45.40,0:21:47.33,*Default,NTP,0000,0000,0000,,曲线向上倾斜
Dialogue: 0,0:21:47.47,0:21:49.90,*Default,NTP,0000,0000,0000,,呈一条熟悉的抛物线
Dialogue: 0,0:21:50.50,0:21:52.50,*Default,NTP,0000,0000,0000,,另一条向上倾斜的
Dialogue: 0,0:21:52.50,0:21:55.40,*Default,NTP,0000,0000,0000,,增长顺序是指数时间
Dialogue: 0,0:21:55.67,0:21:57.47,*Default,NTP,0000,0000,0000,,这里的情况更糟
Dialogue: 0,0:21:58.20,0:22:01.17,*Default,NTP,0000,0000,0000,,树形递归函数可能需要指数时间
Dialogue: 0,0:22:01.37,0:22:04.10,*Default,NTP,0000,0000,0000,,因为未记忆的纤维函数
Dialogue: 0,0:22:04.33,0:22:06.90,*Default,NTP,0000,0000,0000,,要多做 60% 的工作
Dialogue: 0,0:22:07.00,0:22:08.40,*Default,NTP,0000,0000,0000,,计算 n
Dialogue: 0,0:22:08.40,0:22:10.93,*Default,NTP,0000,0000,0000,,就需要多做 60% 的工作。
Dialogue: 0,0:22:11.37,0:22:14.73,*Default,NTP,0000,0000,0000,,所以计算 fib 2 就需要这么多工作
Dialogue: 0,0:22:14.80,0:22:17.93,*Default,NTP,0000,0000,0000,,纤维三需要这么多额外的工作
Dialogue: 0,0:22:18.00,0:22:18.77,*Default,NTP,0000,0000,0000,,纤维四
Dialogue: 0,0:22:18.77,0:22:22.07,*Default,NTP,0000,0000,0000,,需要在纤三的基础上计算所有这些额外的工作
Dialogue: 0,0:22:22.37,0:22:25.77,*Default,NTP,0000,0000,0000,,而纤维五不仅要计算纤维四
Dialogue: 0,0:22:25.80,0:22:28.47,*Default,NTP,0000,0000,0000,,还要计算所有这些额外的工作
Dialogue: 0,0:22:28.77,0:22:30.77,*Default,NTP,0000,0000,0000,,假设我们不进行 memoize
Dialogue: 0,0:22:31.33,0:22:33.33,*Default,NTP,0000,0000,0000,,所以像这样的树形递归函数
Dialogue: 0,0:22:33.33,0:22:34.73,*Default,NTP,0000,0000,0000,,的树形递归函数
Dialogue: 0,0:22:34.87,0:22:37.57,*Default,NTP,0000,0000,0000,,将花费所谓的指数时间
Dialogue: 0,0:22:38.87,0:22:42.10,*Default,NTP,0000,0000,0000,,以下是分析函数时常见的增长顺序
Dialogue: 0,0:22:42.30,0:22:44.67,*Default,NTP,0000,0000,0000,,在分析函数时
Dialogue: 0,0:22:45.20,0:22:46.53,*Default,NTP,0000,0000,0000,,还有其他的
Dialogue: 0,0:22:46.70,0:22:48.60,*Default,NTP,0000,0000,0000,,还有一个正式的系统
Dialogue: 0,0:22:48.60,0:22:51.33,*Default,NTP,0000,0000,0000,,分析函数并证明
Dialogue: 0,0:22:51.50,0:22:54.60,*Default,NTP,0000,0000,0000,,它们属于哪种增长阶次
Dialogue: 0,0:22:54.77,0:22:57.60,*Default,NTP,0000,0000,0000,,但这些我们都将在以后的课程中讨论
Dialogue: 0,0:22:58.00,0:22:59.47,*Default,NTP,0000,0000,0000,,我们将把重点放在
Dialogue: 0,0:22:59.60,0:23:01.80,*Default,NTP,0000,0000,0000,,了解这些类别是什么
Dialogue: 0,0:23:02.00,0:23:03.97,*Default,NTP,0000,0000,0000,,及其对程序运行时间的影响
Dialogue: 0,0:23:04.00,0:23:06.27,*Default,NTP,0000,0000,0000,,对程序运行时间的影响
Dialogue: 0,0:23:07.33,0:23:12.37,*Default,NTP,0000,0000,0000,,它们都描述了时间如何随输入大小而缩放
Dialogue: 0,0:23:12.77,0:23:15.47,*Default,NTP,0000,0000,0000,,它们都描述了总体趋势
Dialogue: 0,0:23:15.47,0:23:17.30,*Default,NTP,0000,0000,0000,,而不是
Dialogue: 0,0:23:17.30,0:23:18.27,*Default,NTP,0000,0000,0000,,具体
Dialogue: 0,0:23:18.27,0:23:21.13,*Default,NTP,0000,0000,0000,,函数调用需要多少微秒
Dialogue: 0,0:23:21.13,0:23:22.33,*Default,NTP,0000,0000,0000,,调用返回
Dialogue: 0,0:23:23.13,0:23:25.40,*Default,NTP,0000,0000,0000,,所以指数增长真的很慢
Dialogue: 0,0:23:25.47,0:23:28.00,*Default,NTP,0000,0000,0000,,四分增长缓慢但常见
Dialogue: 0,0:23:28.13,0:23:30.30,*Default,NTP,0000,0000,0000,,线性增长非常常见
Dialogue: 0,0:23:30.37,0:23:32.10,*Default,NTP,0000,0000,0000,,对数增长非常好
Dialogue: 0,0:23:32.10,0:23:34.53,*Default,NTP,0000,0000,0000,,而且可以扩展到非常大的输入
Dialogue: 0,0:23:34.57,0:23:37.47,*Default,NTP,0000,0000,0000,,恒定增长是所有增长中最好的
Dialogue: 0,0:23:37.93,0:23:40.93,*Default,NTP,0000,0000,0000,,当输入大小
Dialogue: 0,0:23:40.97,0:23:43.07,*Default,NTP,0000,0000,0000,,不影响时间时
Dialogue: 0,0:23:43.33,0:23:45.70,*Default,NTP,0000,0000,0000,,例如，在 Python 中
Dialogue: 0,0:23:45.93,0:23:49.10,*Default,NTP,0000,0000,0000,,字典中元素的数量
Dialogue: 0,0:23:49.27,0:23:52.77,*Default,NTP,0000,0000,0000,,不会影响通过键值查找一个值所需的时间。
Dialogue: 0,0:23:52.80,0:23:57.10,*Default,NTP,0000,0000,0000,,这将是以后课程的主题。
Dialogue: 0,0:23:57.50,0:23:58.97,*Default,NTP,0000,0000,0000,,但事实上
Dialogue: 0,0:23:58.97,0:24:02.73,*Default,NTP,0000,0000,0000,,通过键值查找一个值是一个恒定时间的操作
Dialogue: 0,0:24:02.73,0:24:03.73,*Default,NTP,0000,0000,0000,,是一个恒定时间的操作
Dialogue: 0,0:24:03.90,0:24:07.53,*Default,NTP,0000,0000,0000,,是 python 字典的一个重要特性。
Dialogue: 0,0:24:08.20,0:24:09.80,*Default,NTP,0000,0000,0000,,每一类
Dialogue: 0,0:24:09.87,0:24:12.60,*Default,NTP,0000,0000,0000,,都可以用一个简单的等式来描述
Dialogue: 0,0:24:12.93,0:24:15.30,*Default,NTP,0000,0000,0000,,其中我们写下了
Dialogue: 0,0:24:15.50,0:24:18.57,*Default,NTP,0000,0000,0000,,处理
Dialogue: 0,0:24:18.60,0:24:21.77,*Default,NTP,0000,0000,0000,,大小为 n+1 的输入
Dialogue: 0,0:24:22.13,0:24:25.50,*Default,NTP,0000,0000,0000,,的时间。
Dialogue: 0,0:24:25.50,0:24:27.17,*Default,NTP,0000,0000,0000,,所需的时间。
Dialogue: 0,0:24:27.53,0:24:30.27,*Default,NTP,0000,0000,0000,,使用常数 a 和 b
Dialogue: 0,0:24:30.50,0:24:32.17,*Default,NTP,0000,0000,0000,,来说明
Dialogue: 0,0:24:32.33,0:24:35.80,*Default,NTP,0000,0000,0000,,因为关于某项程序运行所需的时间有很多细节可循
Dialogue: 0,0:24:35.80,0:24:37.07,*Default,NTP,0000,0000,0000,,的许多细节
Dialogue: 0,0:24:37.27,0:24:38.73,*Default,NTP,0000,0000,0000,,的许多细节
Dialogue: 0,0:24:38.73,0:24:41.87,*Default,NTP,0000,0000,0000,,在我们讨论时间的一般形状时
Dialogue: 0,0:24:41.87,0:24:44.13,*Default,NTP,0000,0000,0000,,作为输入大小的函数
Dialogue: 0,0:24:45.27,0:24:46.93,*Default,NTP,0000,0000,0000,,因此，对于指数增长
Dialogue: 0,0:24:47.20,0:24:49.40,*Default,NTP,0000,0000,0000,,计算
Dialogue: 0,0:24:49.40,0:24:52.20,*Default,NTP,0000,0000,0000,,计算结果所需的时间
Dialogue: 0,0:24:52.33,0:24:55.40,*Default,NTP,0000,0000,0000,,是 n 加 1 的 a 乘以 b。
Dialogue: 0,0:24:56.50,0:24:57.30,*Default,NTP,0000,0000,0000,,这
Dialogue: 0,0:24:57.33,0:25:00.70,*Default,NTP,0000,0000,0000,,与大小为 n 的输入所需的时间相比
Dialogue: 0,0:25:00.80,0:25:04.97,*Default,NTP,0000,0000,0000,,需要额外的乘法系数 b
Dialogue: 0,0:25:05.87,0:25:09.27,*Default,NTP,0000,0000,0000,,这就是指数增长的主要特点
Dialogue: 0,0:25:09.70,0:25:12.10,*Default,NTP,0000,0000,0000,,输入大小以
Dialogue: 0,0:25:12.30,0:25:15.80,*Default,NTP,0000,0000,0000,,时间会乘以某个常数
Dialogue: 0,0:25:15.97,0:25:18.73,*Default,NTP,0000,0000,0000,,常数越大，情况越糟
Dialogue: 0,0:25:18.97,0:25:22.13,*Default,NTP,0000,0000,0000,,但基本上任何常数都很糟糕
Dialogue: 0,0:25:22.67,0:25:25.13,*Default,NTP,0000,0000,0000,,二次增长则没有这么慢
Dialogue: 0,0:25:25.93,0:25:28.53,*Default,NTP,0000,0000,0000,,二次增长说的是，对于输入
Dialogue: 0,0:25:28.60,0:25:30.27,*Default,NTP,0000,0000,0000,,的输入
Dialogue: 0,0:25:30.53,0:25:34.47,*Default,NTP,0000,0000,0000,,需要类似于 n 加 1 的平方的 a 次方
Dialogue: 0,0:25:34.70,0:25:36.70,*Default,NTP,0000,0000,0000,,才能计算出结果
Dialogue: 0,0:25:37.33,0:25:40.67,*Default,NTP,0000,0000,0000,,计算结果所需的时间。
Dialogue: 0,0:25:40.70,0:25:42.47,*Default,NTP,0000,0000,0000,,的结果外，还需要额外的加法项。
Dialogue: 0,0:25:42.90,0:25:46.33,*Default,NTP,0000,0000,0000,,还需要一个额外的加法项
Dialogue: 0,0:25:47.10,0:25:47.30,*Default,NTP,0000,0000,0000,,现在
Dialogue: 0,0:25:47.30,0:25:50.50,*Default,NTP,0000,0000,0000,,加法时间比乘法时间好
Dialogue: 0,0:25:51.10,0:25:53.17,*Default,NTP,0000,0000,0000,,但二次增长的问题仍然是
Dialogue: 0,0:25:53.17,0:25:56.33,*Default,NTP,0000,0000,0000,,二次增长的问题在于
Dialogue: 0,0:25:56.47,0:25:59.00,*Default,NTP,0000,0000,0000,,从终点到终点加一
Dialogue: 0,0:25:59.10,0:26:01.40,*Default,NTP,0000,0000,0000,,是一个取决于
Dialogue: 0,0:26:01.53,0:26:03.97,*Default,NTP,0000,0000,0000,,的一个项，因此增加时间
Dialogue: 0,0:26:04.10,0:26:06.20,*Default,NTP,0000,0000,0000,,端乘以一个常数
Dialogue: 0,0:26:06.93,0:26:09.93,*Default,NTP,0000,0000,0000,,对于大小为 n 加 1 的问题，线性增长
Dialogue: 0,0:26:09.97,0:26:13.87,*Default,NTP,0000,0000,0000,,需要 n 加 1 乘以某个 a 步骤
Dialogue: 0,0:26:14.33,0:26:18.50,*Default,NTP,0000,0000,0000,,这与求解大小为 n 的同一问题相比
Dialogue: 0,0:26:18.70,0:26:21.93,*Default,NTP,0000,0000,0000,,只是一个不依赖于它的加法系数
Dialogue: 0,0:26:22.40,0:26:25.60,*Default,NTP,0000,0000,0000,,递增 n 会以一个常数增加时间
Dialogue: 0,0:26:26.60,0:26:29.50,*Default,NTP,0000,0000,0000,,对数增长才是真正意义上的增长
Dialogue: 0,0:26:29.50,0:26:30.57,*Default,NTP,0000,0000,0000,,开始
Dialogue: 0,0:26:31.70,0:26:33.87,*Default,NTP,0000,0000,0000,,在这里，我们写下一个表达式
Dialogue: 0,0:26:33.93,0:26:37.60,*Default,NTP,0000,0000,0000,,的计算结果所需的时间。
Dialogue: 0,0:26:37.67,0:26:39.80,*Default,NTP,0000,0000,0000,,n 加 n 或 n 的 2 倍
Dialogue: 0,0:26:40.47,0:26:43.67,*Default,NTP,0000,0000,0000,,是某个常数乘以 2 的对数，即
Dialogue: 0,0:26:44.07,0:26:45.80,*Default,NTP,0000,0000,0000,,与
Dialogue: 0,0:26:45.80,0:26:47.50,*Default,NTP,0000,0000,0000,,计算结果所需的时间
Dialogue: 0,0:26:47.50,0:26:50.80,*Default,NTP,0000,0000,0000,,加某个常数
Dialogue: 0,0:26:51.70,0:26:55.27,*Default,NTP,0000,0000,0000,,因此，将 in 增加一倍只会使时间增加一个常数
Dialogue: 0,0:26:55.90,0:26:59.07,*Default,NTP,0000,0000,0000,,如果可以重新实现某个函数
Dialogue: 0,0:26:59.30,0:27:01.87,*Default,NTP,0000,0000,0000,,以改变其增长顺序
Dialogue: 0,0:27:02.07,0:27:05.17,*Default,NTP,0000,0000,0000,,通过 memoization 从指数增长到线性增长
Dialogue: 0,0:27:05.40,0:27:07.40,*Default,NTP,0000,0000,0000,,或从线性变为
Dialogue: 0,0:27:07.40,0:27:09.50,*Default,NTP,0000,0000,0000,,的顺序
Dialogue: 0,0:27:10.37,0:27:12.53,*Default,NTP,0000,0000,0000,,这不仅能大大改变
Dialogue: 0,0:27:12.60,0:27:14.70,*Default,NTP,0000,0000,0000,,不仅会大大改变程序的速度
Dialogue: 0,0:27:14.80,0:27:18.17,*Default,NTP,0000,0000,0000,,程序所能处理问题的大小
Dialogue: 0,0:27:18.17,0:27:20.80,*Default,NTP,0000,0000,0000,,而不会让人觉得程序永远都在运行
Dialogue: 0,0:27:23.77,0:27:27.33,*Default,NTP,0000,0000,0000,,有精确的数学定义
Dialogue: 0,0:27:27.50,0:27:30.30,*Default,NTP,0000,0000,0000,,有精确的数学定义
Dialogue: 0,0:27:30.30,0:27:32.33,*Default,NTP,0000,0000,0000,,二次等
Dialogue: 0,0:27:32.93,0:27:35.40,*Default,NTP,0000,0000,0000,,这些定义非常有用，因为
Dialogue: 0,0:27:35.40,0:27:38.13,*Default,NTP,0000,0000,0000,,它们允许你证明
Dialogue: 0,0:27:38.27,0:27:39.73,*Default,NTP,0000,0000,0000,,函数的
Dialogue: 0,0:27:40.57,0:27:42.93,*Default,NTP,0000,0000,0000,,证明函数的性质
Dialogue: 0,0:27:42.97,0:27:45.00,*Default,NTP,0000,0000,0000,,证明这些函数的性质
Dialogue: 0,0:27:45.77,0:27:49.93,*Default,NTP,0000,0000,0000,,而计算理论的一个重要组成部分
Dialogue: 0,0:27:50.50,0:27:51.77,*Default,NTP,0000,0000,0000,,就是这种
Dialogue: 0,0:27:51.93,0:27:55.87,*Default,NTP,0000,0000,0000,,证明函数特性的实践
Dialogue: 0,0:27:56.17,0:27:59.13,*Default,NTP,0000,0000,0000,,根据数学定义进行推理
Dialogue: 0,0:28:00.17,0:28:02.50,*Default,NTP,0000,0000,0000,,这不是本课程的主题
Dialogue: 0,0:28:02.90,0:28:05.67,*Default,NTP,0000,0000,0000,,但在伯克利大学的未来课程中会广泛涉及
Dialogue: 0,0:28:05.67,0:28:06.47,*Default,NTP,0000,0000,0000,,伯克利
Dialogue: 0,0:28:07.13,0:28:07.77,*Default,NTP,0000,0000,0000,,而且是
Dialogue: 0,0:28:07.77,0:28:10.60,*Default,NTP,0000,0000,0000,,计算机科学课程的标准组成部分
Dialogue: 0,0:28:11.70,0:28:13.97,*Default,NTP,0000,0000,0000,,而不是告诉你所有的定义
Dialogue: 0,0:28:13.97,0:28:15.93,*Default,NTP,0000,0000,0000,,欢迎大家自行查找
Dialogue: 0,0:28:16.33,0:28:18.73,*Default,NTP,0000,0000,0000,,我将向你们展示与这些定义相关的标准符号
Dialogue: 0,0:28:18.73,0:28:21.17,*Default,NTP,0000,0000,0000,,与这些定义相关的标准符号
Dialogue: 0,0:28:21.33,0:28:23.60,*Default,NTP,0000,0000,0000,,因为它太常用了
Dialogue: 0,0:28:23.67,0:28:25.27,*Default,NTP,0000,0000,0000,,可能会让你大吃一惊
Dialogue: 0,0:28:25.27,0:28:27.10,*Default,NTP,0000,0000,0000,,如果你从未见过它
Dialogue: 0,0:28:28.27,0:28:30.17,*Default,NTP,0000,0000,0000,,因此，对于这些常见的增长阶数
Dialogue: 0,0:28:30.17,0:28:32.20,*Default,NTP,0000,0000,0000,,指数四阶线性
Dialogue: 0,0:28:32.20,0:28:34.27,*Default,NTP,0000,0000,0000,,对数和常数
Dialogue: 0,0:28:34.77,0:28:39.10,*Default,NTP,0000,0000,0000,,描述每种增长阶次的最典型方法是
Dialogue: 0,0:28:39.33,0:28:44.00,*Default,NTP,0000,0000,0000,,最典型的方法是使用大 Theta 或大 O 符号
Dialogue: 0,0:28:45.17,0:28:48.13,*Default,NTP,0000,0000,0000,,大 Theta 表示法如下
Dialogue: 0,0:28:48.33,0:28:50.40,*Default,NTP,0000,0000,0000,,每个增长阶数都有不同的表达式
Dialogue: 0,0:28:50.53,0:28:52.47,*Default,NTP,0000,0000,0000,,的表达式
Dialogue: 0,0:28:52.80,0:28:58.20,*Default,NTP,0000,0000,0000,,因此，二次增长是大θ 的安妮平方
Dialogue: 0,0:28:58.40,0:29:02.07,*Default,NTP,0000,0000,0000,,而线性增长是蚂蚁的大 theta
Dialogue: 0,0:29:02.90,0:29:03.60,*Default,NTP,0000,0000,0000,,没错
Dialogue: 0,0:29:03.60,0:29:07.20,*Default,NTP,0000,0000,0000,,是的，计算机科学家真的会到处说
Dialogue: 0,0:29:07.33,0:29:08.37,*Default,NTP,0000,0000,0000,,大θ
Dialogue: 0,0:29:09.77,0:29:13.40,*Default,NTP,0000,0000,0000,,对数节奏是对数 n，常量是棘手的问题
Dialogue: 0,0:29:13.53,0:29:16.77,*Default,NTP,0000,0000,0000,,你最常写的是一个的 big theta
Dialogue: 0,0:29:17.07,0:29:18.60,*Default,NTP,0000,0000,0000,,n
Dialogue: 0,0:29:18.87,0:29:20.10,*Default,NTP,0000,0000,0000,,增加 n
Dialogue: 0,0:29:20.10,0:29:23.67,*Default,NTP,0000,0000,0000,,不会影响恒定增长函数中的时间
Dialogue: 0,0:29:23.90,0:29:26.17,*Default,NTP,0000,0000,0000,,所以你根本不用把 n 放在这里
Dialogue: 0,0:29:27.07,0:29:31.27,*Default,NTP,0000,0000,0000,,另一种常用的符号是大 o 符号
Dialogue: 0,0:29:31.33,0:29:34.00,*Default,NTP,0000,0000,0000,,这比 big theta 更有趣
Dialogue: 0,0:29:34.50,0:29:36.40,*Default,NTP,0000,0000,0000,,表达式看起来也一样
Dialogue: 0,0:29:36.53,0:29:41.33,*Default,NTP,0000,0000,0000,,因此，b 的 big theta 表示 n 或 b 的 big o 表示 n
Dialogue: 0,0:29:42.30,0:29:46.10,*Default,NTP,0000,0000,0000,,现在，它们的实际含义略有不同
Dialogue: 0,0:29:46.60,0:29:50.97,*Default,NTP,0000,0000,0000,,big o 描述的是函数运行所需的时间上限。
Dialogue: 0,0:29:50.97,0:29:52.40,*Default,NTP,0000,0000,0000,,函数运行时间的上限
Dialogue: 0,0:29:53.07,0:29:56.57,*Default,NTP,0000,0000,0000,,所以这就好比说最多二次方
Dialogue: 0,0:29:57.20,0:29:58.37,*Default,NTP,0000,0000,0000,,而这里说的是
Dialogue: 0,0:29:58.37,0:30:00.80,*Default,NTP,0000,0000,0000,,下限和上限
Dialogue: 0,0:30:01.33,0:30:02.67,*Default,NTP,0000,0000,0000,,最多
Dialogue: 0,0:30:02.77,0:30:06.97,*Default,NTP,0000,0000,0000,,和至少需要二次方时间
Dialogue: 0,0:30:07.73,0:30:10.87,*Default,NTP,0000,0000,0000,,现在，要有效地使用这个数学符号
Dialogue: 0,0:30:10.87,0:30:12.67,*Default,NTP,0000,0000,0000,,你必须非常精确地
Dialogue: 0,0:30:12.77,0:30:14.40,*Default,NTP,0000,0000,0000,,你在描述什么
Dialogue: 0,0:30:14.67,0:30:17.37,*Default,NTP,0000,0000,0000,,与问题相关的 n 是什么
Dialogue: 0,0:30:18.57,0:30:20.87,*Default,NTP,0000,0000,0000,,如果 n 只是输入数
Dialogue: 0,0:30:21.07,0:30:22.37,*Default,NTP,0000,0000,0000,,那么事情就简单了
Dialogue: 0,0:30:22.60,0:30:26.17,*Default,NTP,0000,0000,0000,,但 n 可能是输入序列的长度
Dialogue: 0,0:30:26.80,0:30:29.27,*Default,NTP,0000,0000,0000,,这意味着有很多序列都
Dialogue: 0,0:30:29.27,0:30:30.70,*Default,NTP,0000,0000,0000,,长度相同
Dialogue: 0,0:30:30.93,0:30:33.40,*Default,NTP,0000,0000,0000,,那么你是在描述
Dialogue: 0,0:30:33.67,0:30:37.20,*Default,NTP,0000,0000,0000,,在最坏情况下
Dialogue: 0,0:30:37.27,0:30:40.07,*Default,NTP,0000,0000,0000,,或平均最佳情况下
Dialogue: 0,0:30:40.13,0:30:42.90,*Default,NTP,0000,0000,0000,,在所有不同长度的序列中
Dialogue: 0,0:30:43.33,0:30:45.37,*Default,NTP,0000,0000,0000,,这是你需要说明的问题
Dialogue: 0,0:30:45.37,0:30:47.80,*Default,NTP,0000,0000,0000,,如果你要证明
Dialogue: 0,0:30:48.00,0:30:49.37,*Default,NTP,0000,0000,0000,,函数的属性
Dialogue: 0,0:30:49.93,0:30:52.87,*Default,NTP,0000,0000,0000,,这些在以后的课程中会变得很重要
Dialogue: 0,0:30:52.97,0:30:54.50,*Default,NTP,0000,0000,0000,,但我认为在本课程中
Dialogue: 0,0:30:54.60,0:30:56.77,*Default,NTP,0000,0000,0000,,重要的是认识到
Dialogue: 0,0:30:56.80,0:31:00.00,*Default,NTP,0000,0000,0000,,有不同的一般增长模式
Dialogue: 0,0:31:00.13,0:31:02.87,*Default,NTP,0000,0000,0000,,函数完成所需的时间
Dialogue: 0,0:31:03.20,0:31:07.47,*Default,NTP,0000,0000,0000,,最常见的是我在这里向大家展示的五种模式
Dialogue: 0,0:31:08.10,0:31:10.57,*Default,NTP,0000,0000,0000,,当人们讨论对数增长时
Dialogue: 0,0:31:10.67,0:31:13.07,*Default,NTP,0000,0000,0000,,有时他们不说对数增长
Dialogue: 0,0:31:13.10,0:31:17.30,*Default,NTP,0000,0000,0000,,而是说 big theta log in 或 biggo log in
Dialogue: 0,0:31:20.07,0:31:24.13,*Default,NTP,0000,0000,0000,,空间或内存是另一种资源
Dialogue: 0,0:31:24.13,0:31:27.27,*Default,NTP,0000,0000,0000,,内存是程序执行时消耗的另一种资源
Dialogue: 0,0:31:27.80,0:31:30.33,*Default,NTP,0000,0000,0000,,因此，这是你需要担心的问题
Dialogue: 0,0:31:31.37,0:31:36.93,*Default,NTP,0000,0000,0000,,占用空间的是数值
Dialogue: 0,0:31:37.27,0:31:40.10,*Default,NTP,0000,0000,0000,,因此，长列表比短列表占用更多空间
Dialogue: 0,0:31:40.33,0:31:43.10,*Default,NTP,0000,0000,0000,,但空间也会被帧占用
Dialogue: 0,0:31:43.20,0:31:45.70,*Default,NTP,0000,0000,0000,,所以你需要知道有多少帧存在
Dialogue: 0,0:31:45.87,0:31:47.17,*Default,NTP,0000,0000,0000,,因此你需要知道有多少帧存在
Dialogue: 0,0:31:47.17,0:31:49.53,*Default,NTP,0000,0000,0000,,调用而存在多少帧
Dialogue: 0,0:31:50.10,0:31:52.50,*Default,NTP,0000,0000,0000,,这将涉及一些新概念
Dialogue: 0,0:31:53.67,0:31:56.37,*Default,NTP,0000,0000,0000,,因此，我们需要跟踪的新概念是
Dialogue: 0,0:31:56.37,0:31:59.27,*Default,NTP,0000,0000,0000,,我们需要保留哪些环境帧
Dialogue: 0,0:31:59.37,0:32:00.80,*Default,NTP,0000,0000,0000,,在评估过程中
Dialogue: 0,0:32:00.93,0:32:03.30,*Default,NTP,0000,0000,0000,,哪些可以放手不管
Dialogue: 0,0:32:03.87,0:32:05.27,*Default,NTP,0000,0000,0000,,故事是这样的
Dialogue: 0,0:32:05.53,0:32:06.50,*Default,NTP,0000,0000,0000,,在任何时刻
Dialogue: 0,0:32:06.50,0:32:09.70,*Default,NTP,0000,0000,0000,,有一组所谓的活动环境
Dialogue: 0,0:32:10.20,0:32:13.33,*Default,NTP,0000,0000,0000,,这些活动环境中的值和框架
Dialogue: 0,0:32:13.37,0:32:15.90,*Default,NTP,0000,0000,0000,,消耗内存或空间
Dialogue: 0,0:32:17.10,0:32:18.97,*Default,NTP,0000,0000,0000,,内存或空间
Dialogue: 0,0:32:18.97,0:32:21.93,*Default,NTP,0000,0000,0000,,不在活动环境中的价值和框架
Dialogue: 0,0:32:22.13,0:32:23.53,*Default,NTP,0000,0000,0000,,可以循环使用
Dialogue: 0,0:32:23.73,0:32:26.57,*Default,NTP,0000,0000,0000,,python 解释器会自动这样做
Dialogue: 0,0:32:26.60,0:32:29.40,*Default,NTP,0000,0000,0000,,通过回收之前使用过的基础信息
Dialogue: 0,0:32:29.73,0:32:34.13,*Default,NTP,0000,0000,0000,,当它知道不再需要这些信息时
Dialogue: 0,0:32:35.07,0:32:37.73,*Default,NTP,0000,0000,0000,,哪些是活动环境
Dialogue: 0,0:32:38.00,0:32:40.27,*Default,NTP,0000,0000,0000,,活动环境是指
Dialogue: 0,0:32:40.27,0:32:42.90,*Default,NTP,0000,0000,0000,,函数调用
Dialogue: 0,0:32:43.30,0:32:46.20,*Default,NTP,0000,0000,0000,,也就是说，我们调用了它，但它还没有返回
Dialogue: 0,0:32:47.53,0:32:50.50,*Default,NTP,0000,0000,0000,,还有另一种情况
Dialogue: 0,0:32:50.67,0:32:53.33,*Default,NTP,0000,0000,0000,,是函数的父环境
Dialogue: 0,0:32:53.67,0:32:55.93,*Default,NTP,0000,0000,0000,,的父环境
Dialogue: 0,0:32:56.47,0:32:58.67,*Default,NTP,0000,0000,0000,,因此会出现这种情况
Dialogue: 0,0:32:58.77,0:33:02.00,*Default,NTP,0000,0000,0000,,当你在另一个函数中定义了一个函数
Dialogue: 0,0:33:02.53,0:33:04.27,*Default,NTP,0000,0000,0000,,因此它的父框架
Dialogue: 0,0:33:04.87,0:33:07.20,*Default,NTP,0000,0000,0000,,不是全局框架，而是其他框架
Dialogue: 0,0:33:07.67,0:33:09.37,*Default,NTP,0000,0000,0000,,只要您需要该函数
Dialogue: 0,0:33:09.40,0:33:11.90,*Default,NTP,0000,0000,0000,,就需要它的父框架
Dialogue: 0,0:33:11.93,0:33:15.33,*Default,NTP,0000,0000,0000,,以及其父环境中的所有其他框架
Dialogue: 0,0:33:17.60,0:33:19.53,*Default,NTP,0000,0000,0000,,幸运的是
Dialogue: 0,0:33:19.53,0:33:21.27,*Default,NTP,0000,0000,0000,,所以幸运的是
Dialogue: 0,0:33:21.27,0:33:23.00,*Default,NTP,0000,0000,0000,,哪些框架处于活动状态
Dialogue: 0,0:33:24.07,0:33:25.93,*Default,NTP,0000,0000,0000,,下面是 fib 的定义
Dialogue: 0,0:33:27.17,0:33:30.20,*Default,NTP,0000,0000,0000,,的定义，它可以计算斐波那契数字 6
Dialogue: 0,0:33:31.07,0:33:33.77,*Default,NTP,0000,0000,0000,,有一个设置
Dialogue: 0,0:33:34.60,0:33:36.07,*Default,NTP,0000,0000,0000,,我将向你展示
Dialogue: 0,0:33:36.80,0:33:39.57,*Default,NTP,0000,0000,0000,,不显示已退出的函数
Dialogue: 0,0:33:40.30,0:33:41.40,*Default,NTP,0000,0000,0000,,这样
Dialogue: 0,0:33:41.50,0:33:43.93,*Default,NTP,0000,0000,0000,,它实际上会删除
Dialogue: 0,0:33:43.93,0:33:45.50,*Default,NTP,0000,0000,0000,,已经返回的
Dialogue: 0,0:33:46.17,0:33:47.67,*Default,NTP,0000,0000,0000,,所以当我们调用 fib six
Dialogue: 0,0:33:47.67,0:33:49.10,*Default,NTP,0000,0000,0000,,显然它还没有返回
Dialogue: 0,0:33:49.10,0:33:50.47,*Default,NTP,0000,0000,0000,,因为我们还有一些工作要做
Dialogue: 0,0:33:50.73,0:33:53.07,*Default,NTP,0000,0000,0000,,这就需要调用 fib 4
Dialogue: 0,0:33:53.60,0:33:54.47,*Default,NTP,0000,0000,0000,,必须
Dialogue: 0,0:33:54.47,0:33:56.93,*Default,NTP,0000,0000,0000,,在我们尝试完成纤维 6 之前
Dialogue: 0,0:33:57.57,0:34:00.00,*Default,NTP,0000,0000,0000,,纤维四需要调用纤维二
Dialogue: 0,0:34:00.73,0:34:04.50,*Default,NTP,0000,0000,0000,,因此所有这些都是同时活动的帧
Dialogue: 0,0:34:05.27,0:34:06.97,*Default,NTP,0000,0000,0000,,纤维二调用纤维零
Dialogue: 0,0:34:07.10,0:34:09.33,*Default,NTP,0000,0000,0000,,纤维零实际返回
Dialogue: 0,0:34:09.37,0:34:11.27,*Default,NTP,0000,0000,0000,,一旦返回
Dialogue: 0,0:34:11.27,0:34:14.80,*Default,NTP,0000,0000,0000,,它就不再处于活动状态，所以它就会消失
Dialogue: 0,0:34:15.50,0:34:16.67,*Default,NTP,0000,0000,0000,,取而代之的是
Dialogue: 0,0:34:16.70,0:34:21.13,*Default,NTP,0000,0000,0000,,取而代之的是纤维 1 的框架
Dialogue: 0,0:34:21.40,0:34:24.07,*Default,NTP,0000,0000,0000,,注意，我们有了纤维 1、纤维 2 和纤维 3
Dialogue: 0,0:34:24.13,0:34:25.47,*Default,NTP,0000,0000,0000,,我们创建了 F4
Dialogue: 0,0:34:25.47,0:34:26.77,*Default,NTP,0000,0000,0000,,但后来把它去掉了
Dialogue: 0,0:34:26.77,0:34:28.27,*Default,NTP,0000,0000,0000,,因为我们不再需要它了
Dialogue: 0,0:34:28.27,0:34:29.77,*Default,NTP,0000,0000,0000,,现在我们创建了 f5
Dialogue: 0,0:34:31.00,0:34:34.60,*Default,NTP,0000,0000,0000,,所以，如果我们继续这个过程，就会发现一旦
Dialogue: 0,0:34:34.87,0:34:37.40,*Default,NTP,0000,0000,0000,,纤维四完成了对纤维二的运算
Dialogue: 0,0:34:37.40,0:34:40.53,*Default,NTP,0000,0000,0000,,就删除了纤维二帧
Dialogue: 0,0:34:40.73,0:34:42.80,*Default,NTP,0000,0000,0000,,现在我们有了纤维三帧
Dialogue: 0,0:34:42.80,0:34:45.40,*Default,NTP,0000,0000,0000,,这是计算纤维四的另一部分
Dialogue: 0,0:34:46.13,0:34:47.53,*Default,NTP,0000,0000,0000,,这样持续一段时间
Dialogue: 0,0:34:47.90,0:34:50.30,*Default,NTP,0000,0000,0000,,最终，纤四框架完全消失
Dialogue: 0,0:34:50.30,0:34:52.50,*Default,NTP,0000,0000,0000,,我们只剩下原来的纤维一帧
Dialogue: 0,0:34:52.50,0:34:55.07,*Default,NTP,0000,0000,0000,,因为我们还没有计算完纤六
Dialogue: 0,0:34:55.17,0:34:56.97,*Default,NTP,0000,0000,0000,,我们还有 f
Dialogue: 0,0:34:57.07,0:34:59.70,*Default,NTP,0000,0000,0000,,11 框架，它是为计算纤维五而创建的
Dialogue: 0,0:35:00.30,0:35:01.47,*Default,NTP,0000,0000,0000,,它做了一些工作
Dialogue: 0,0:35:01.57,0:35:03.40,*Default,NTP,0000,0000,0000,,最终会被删除
Dialogue: 0,0:35:03.67,0:35:07.80,*Default,NTP,0000,0000,0000,,最后，fib 6 可以返回值 8
Dialogue: 0,0:35:08.07,0:35:09.67,*Default,NTP,0000,0000,0000,,然后我们的代码中就没有工作要做了
Dialogue: 0,0:35:11.37,0:35:12.37,*Default,NTP,0000,0000,0000,,在我们的代码中
Dialogue: 0,0:35:12.37,0:35:15.20,*Default,NTP,0000,0000,0000,,我们还可以看到有多少帧正在被使用
Dialogue: 0,0:35:15.73,0:35:18.30,*Default,NTP,0000,0000,0000,,因此，让我们定义一个名为
Dialogue: 0,0:35:18.30,0:35:20.73,*Default,NTP,0000,0000,0000,,计数帧的高阶函数。
Dialogue: 0,0:35:21.10,0:35:24.40,*Default,NTP,0000,0000,0000,,并定义一个计数版本
Dialogue: 0,0:35:25.37,0:35:27.60,*Default,NTP,0000,0000,0000,,的参数。
Dialogue: 0,0:35:29.33,0:35:34.27,*Default,NTP,0000,0000,0000,,它的作用是递增打开的帧数
Dialogue: 0,0:35:35.40,0:35:37.33,*Default,NTP,0000,0000,0000,,它还会记录
Dialogue: 0,0:35:37.40,0:35:40.97,*Default,NTP,0000,0000,0000,,在任何时候的最大打开帧数
Dialogue: 0,0:35:41.87,0:35:45.40,*Default,NTP,0000,0000,0000,,因此，如果打开的帧数实际上大于
Dialogue: 0,0:35:47.53,0:35:48.90,*Default,NTP,0000,0000,0000,,那么
Dialogue: 0,0:35:50.10,0:35:51.37,*Default,NTP,0000,0000,0000,,我们可以将
Dialogue: 0,0:35:52.00,0:35:54.73,*Default,NTP,0000,0000,0000,,最大值为打开帧数
Dialogue: 0,0:35:55.60,0:35:58.07,*Default,NTP,0000,0000,0000,,现在我们将通过
Dialogue: 0,0:35:58.57,0:36:00.87,*Default,NTP,0000,0000,0000,,在 n 上调用 f
Dialogue: 0,0:36:01.97,0:36:04.73,*Default,NTP,0000,0000,0000,,现在是关闭帧的时候了
Dialogue: 0,0:36:07.17,0:36:10.20,*Default,NTP,0000,0000,0000,,这意味着从打开计数中减去 1
Dialogue: 0,0:36:10.90,0:36:12.73,*Default,NTP,0000,0000,0000,,然后我们就可以返回结果了
Dialogue: 0,0:36:13.97,0:36:16.30,*Default,NTP,0000,0000,0000,,打开计数从 0 开始
Dialogue: 0,0:36:16.40,0:36:18.77,*Default,NTP,0000,0000,0000,,最大计数从 0 开始
Dialogue: 0,0:36:21.17,0:36:23.67,*Default,NTP,0000,0000,0000,,我们可以返回计数函数
Dialogue: 0,0:36:25.10,0:36:27.70,*Default,NTP,0000,0000,0000,,因此，如果我们快速定义
Dialogue: 0,0:36:29.37,0:36:32.57,*Default,NTP,0000,0000,0000,,我们已经知道它会进行很多很多的递归调用
Dialogue: 0,0:36:32.97,0:36:34.33,*Default,NTP,0000,0000,0000,,但我们不知道
Dialogue: 0,0:36:34.60,0:36:37.33,*Default,NTP,0000,0000,0000,,在任何时候有多少帧是打开的
Dialogue: 0,0:36:39.27,0:36:41.97,*Default,NTP,0000,0000,0000,,或打开帧的最大数量是多少
Dialogue: 0,0:36:42.17,0:36:45.17,*Default,NTP,0000,0000,0000,,所以我们可以通过调用 count frames
Dialogue: 0,0:36:45.17,0:36:46.07,*Default,NTP,0000,0000,0000,,来计算
Dialogue: 0,0:36:46.90,0:36:50.30,*Default,NTP,0000,0000,0000,,然后在一些数字上调用 fib，例如 20
Dialogue: 0,0:36:50.53,0:36:53.87,*Default,NTP,0000,0000,0000,,这样就计算出了第 20 个斐波那契数字
Dialogue: 0,0:36:54.37,0:36:58.50,*Default,NTP,0000,0000,0000,,而 fib dot open count 应该为零
Dialogue: 0,0:36:58.60,0:36:59.67,*Default,NTP,0000,0000,0000,,因为我们
Dialogue: 0,0:36:59.77,0:37:02.33,*Default,NTP,0000,0000,0000,,因为我们每次调用 fib 都会返回
Dialogue: 0,0:37:02.70,0:37:04.67,*Default,NTP,0000,0000,0000,,但最大计数会告诉我们
Dialogue: 0,0:37:07.13,0:37:10.93,*Default,NTP,0000,0000,0000,,一次打开的最大帧数
Dialogue: 0,0:37:11.07,0:37:12.97,*Default,NTP,0000,0000,0000,,答案是 20
Dialogue: 0,0:37:13.77,0:37:15.77,*Default,NTP,0000,0000,0000,,所以这说明了
Dialogue: 0,0:37:15.77,0:37:17.93,*Default,NTP,0000,0000,0000,,这个函数使用了多少空间
Dialogue: 0,0:37:18.33,0:37:21.40,*Default,NTP,0000,0000,0000,,它不需要同时打开 6000 个帧
Dialogue: 0,0:37:21.53,0:37:22.53,*Default,NTP,0000,0000,0000,,只需要几个
Dialogue: 0,0:37:23.40,0:37:26.50,*Default,NTP,0000,0000,0000,,现在我们如何理解为什么这个数字是 20？
Dialogue: 0,0:37:27.53,0:37:28.33,*Default,NTP,0000,0000,0000,,那么
Dialogue: 0,0:37:28.77,0:37:30.00,*Default,NTP,0000,0000,0000,,这是我们用来计算
Dialogue: 0,0:37:30.00,0:37:33.27,*Default,NTP,0000,0000,0000,,我们用来计算纤维5的树形过程
Dialogue: 0,0:37:34.57,0:37:37.27,*Default,NTP,0000,0000,0000,,假设我们已经完成了所有这些工作
Dialogue: 0,0:37:37.33,0:37:39.07,*Default,NTP,0000,0000,0000,,我们还得做这些工作
Dialogue: 0,0:37:39.13,0:37:42.17,*Default,NTP,0000,0000,0000,,我们即将从这个调用返回到 fib 1
Dialogue: 0,0:37:43.57,0:37:44.70,*Default,NTP,0000,0000,0000,,我们可以
Dialogue: 0,0:37:44.87,0:37:47.67,*Default,NTP,0000,0000,0000,,找出哪些调用有活动环境
Dialogue: 0,0:37:47.67,0:37:49.80,*Default,NTP,0000,0000,0000,,这一个 这一个 这一个 还有这一个
Dialogue: 0,0:37:49.80,0:37:51.37,*Default,NTP,0000,0000,0000,,哪些还没有返回
Dialogue: 0,0:37:52.30,0:37:53.87,*Default,NTP,0000,0000,0000,,左边的
Dialogue: 0,0:37:53.87,0:37:56.27,*Default,NTP,0000,0000,0000,,已经被调用并返回
Dialogue: 0,0:37:56.30,0:38:00.07,*Default,NTP,0000,0000,0000,,所以这些框架使用的内存可以回收
Dialogue: 0,0:38:00.70,0:38:03.20,*Default,NTP,0000,0000,0000,,然后这里的这些还没有被调用
Dialogue: 0,0:38:03.37,0:38:05.77,*Default,NTP,0000,0000,0000,,所以我们不需要担心这个问题
Dialogue: 0,0:38:06.20,0:38:08.60,*Default,NTP,0000,0000,0000,,因此，打开的最大帧数
Dialogue: 0,0:38:08.73,0:38:11.53,*Default,NTP,0000,0000,0000,,是你能在这棵树里找到的最长的链
Dialogue: 0,0:38:11.70,0:38:12.87,*Default,NTP,0000,0000,0000,,在本例中
Dialogue: 0,0:38:12.87,0:38:15.60,*Default,NTP,0000,0000,0000,,从纤维 5 到纤维 4 到纤维 3 到纤维 2 到纤维 1
Dialogue: 0,0:38:15.77,0:38:17.00,*Default,NTP,0000,0000,0000,,长度为五
