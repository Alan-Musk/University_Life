1
00:00:00,800 --> 00:00:03,100
61一选13号

2
00:00:03,370 --> 00:00:04,470
公告

3
00:00:05,670 --> 00:00:07,700
猫项目将于周五截止

4
00:00:07,800 --> 00:00:09,370
但第一阶段

5
00:00:09,600 --> 00:00:12,270
如果你想通过检查站，那就周二吧

6
00:00:12,270 --> 00:00:13,470
这是一点

7
00:00:14,000 --> 00:00:15,930
以及你需要做的一切才能得到这一分

8
00:00:15,930 --> 00:00:18,670
周二之前完成所有第一阶段的问题

9
00:00:19,370 --> 00:00:22,130
您可以获得提前提交奖励积分

10
00:00:22,130 --> 00:00:23,730
提交整个项目

11
00:00:23,730 --> 00:00:25,170
周四或更早

12
00:00:26,370 --> 00:00:28,900
今天的讲座和周三的讲座

13
00:00:28,930 --> 00:00:31,500
不包含在考试或作业中

14
00:00:31,530 --> 00:00:34,100
但这确实是你应该知道的有趣的事情

15
00:00:34,570 --> 00:00:36,100
只是还有很多其他的

16
00:00:36,100 --> 00:00:37,900
会考验你的事情

17
00:00:38,300 --> 00:00:41,100
您将在以后的课程中看到这些主题

18
00:00:41,200 --> 00:00:43,930
但你现在肯定应该接触一下它们

19
00:00:44,400 --> 00:00:44,930
并希望

20
00:00:44,930 --> 00:00:47,530
这两场讲座将有助于加深你的理解

21
00:00:47,600 --> 00:00:48,400
理解

22
00:00:48,800 --> 00:00:50,400
关于计算机实际上是怎样的

23
00:00:50,400 --> 00:00:52,570
代表您正在运行的程序

24
00:00:53,530 --> 00:00:54,330
享受

25
00:00:55,770 --> 00:00:56,570
欢迎回来

26
00:00:57,200 --> 00:01:00,370
这个学期的大部分时间都花在谈论

27
00:01:00,670 --> 00:01:05,370
python 数据结构 算法 类

28
00:01:05,370 --> 00:01:06,970
面向对象编程

29
00:01:07,330 --> 00:01:08,530
如果你还记得

30
00:01:08,530 --> 00:01:08,970
中的一个

31
00:01:08,970 --> 00:01:11,900
所有这一切的主题就是抽象的力量

32
00:01:12,330 --> 00:01:17,170
划分数据或代码的力量

33
00:01:17,200 --> 00:01:19,470
以便了解它的具体细节

34
00:01:19,600 --> 00:01:20,870
不必是

35
00:01:21,070 --> 00:01:23,530
我们工作的一部分

36
00:01:23,670 --> 00:01:25,800
围绕它编写代码

37
00:01:25,800 --> 00:01:28,470
有一个非常强大的抽象概念

38
00:01:28,970 --> 00:01:31,200
在本课程的最后一部分我想谈谈

39
00:01:31,200 --> 00:01:33,070
在某些方面关于最终的障碍

40
00:01:33,070 --> 00:01:34,370
这是一台电脑

41
00:01:34,770 --> 00:01:37,470
我们经常使用这些东西

42
00:01:37,470 --> 00:01:40,270
无论是手持设备、笔记本电脑还是台式机

43
00:01:40,900 --> 00:01:43,970
他们非常出色，他们的计算能力令人难以置信

44
00:01:44,770 --> 00:01:46,670
我们确切知道它是如何运作的吗

45
00:01:46,670 --> 00:01:47,930
大部分情况下没有

46
00:01:47,930 --> 00:01:49,130
这是一个抽象

47
00:01:49,470 --> 00:01:50,900
我们知道当我们打开电脑时

48
00:01:50,900 --> 00:01:51,870
并保存一个文件

49
00:01:51,870 --> 00:01:52,570
有事情发生

50
00:01:52,570 --> 00:01:54,070
当我们打开电脑时我们知道

51
00:01:54,370 --> 00:01:55,170
并询问

52
00:01:55,170 --> 00:01:57,970
计算机将两个数字相加或将两个数字相除

53
00:01:57,970 --> 00:01:58,970
只是一些作品

54
00:01:58,970 --> 00:02:02,270
但是计算的本质是如何工作的

55
00:02:02,700 --> 00:02:04,700
因为我认为重要的是

56
00:02:04,700 --> 00:02:05,600
非常理解这一点

57
00:02:05,600 --> 00:02:07,700
我们每天使用的工具

58
00:02:07,700 --> 00:02:09,729
我们将度过这堂课的最后一部分

59
00:02:09,900 --> 00:02:11,470
谈论那个抽象

60
00:02:11,470 --> 00:02:13,600
这就是现代计算机的工作方式

61
00:02:13,870 --> 00:02:14,730
现在显然

62
00:02:14,870 --> 00:02:16,570
这不能适用于每个小比迪

63
00:02:16,570 --> 00:02:19,330
现代计算机如何工作的细节

64
00:02:19,330 --> 00:02:20,370
但我要去

65
00:02:20,500 --> 00:02:23,330
向您展示现代计算机的构建模块

66
00:02:23,330 --> 00:02:24,670
我想什么

67
00:02:24,670 --> 00:02:25,900
真的非常了不起

68
00:02:25,900 --> 00:02:28,330
这就是它们是多么的简单

69
00:02:28,600 --> 00:02:30,530
所以让我们先开始吧

70
00:02:30,770 --> 00:02:34,070
看看计算机实际上是如何工作的

71
00:02:35,170 --> 00:02:35,970
好吧所以

72
00:02:35,970 --> 00:02:38,470
让我首先开始谈论语言

73
00:02:38,470 --> 00:02:39,700
现代计算机的

74
00:02:39,700 --> 00:02:40,930
这是二进制数

75
00:02:40,930 --> 00:02:42,300
但在我这样做之前

76
00:02:42,400 --> 00:02:45,000
让我谈谈我们都知道的爱情数字

77
00:02:45,330 --> 00:02:47,100
这是以 10 为基数的数字

78
00:02:47,100 --> 00:02:49,600
然后我们会讨论一下二进制数

79
00:02:49,800 --> 00:02:51,700
所以当我说No.7 23

80
00:02:53,300 --> 00:02:55,130
你和我有共同语言

81
00:02:55,130 --> 00:02:56,400
我这是什么意思

82
00:02:56,400 --> 00:02:59,370
语言是我们知道这个数字

83
00:02:59,600 --> 00:03:01,370
以 10 为基数

84
00:03:01,800 --> 00:03:02,870
这意味着什么

85
00:03:03,130 --> 00:03:05,170
这意味着这七个

86
00:03:05,300 --> 00:03:07,730
对应第101位

87
00:03:07,730 --> 00:03:09,000
倾向于权力

88
00:03:09,400 --> 00:03:11,670
两者对应的是第10个位置

89
00:03:11,670 --> 00:03:12,770
10 的 1 次方

90
00:03:12,970 --> 00:03:15,900
三个对应第一个位置

91
00:03:15,900 --> 00:03:17,270
10 的零次方

92
00:03:17,670 --> 00:03:21,000
我们不 我不必说七点二十三分

93
00:03:21,070 --> 00:03:23,470
假设以 10 为底

94
00:03:23,730 --> 00:03:26,930
我们都以 10 为基数工作，与语言不同

95
00:03:26,930 --> 00:03:28,800
公制与非公制

96
00:03:28,800 --> 00:03:29,870
有许多

97
00:03:29,900 --> 00:03:32,530
我们总是需要担心的其他转换

98
00:03:32,530 --> 00:03:34,070
所以当我说温度时

99
00:03:34,270 --> 00:03:36,930
当我说距离时，东南方的公平和高度

100
00:03:37,070 --> 00:03:38,700
公里或米

101
00:03:39,300 --> 00:03:41,070
所以这是一件好事

102
00:03:41,070 --> 00:03:44,500
关于数字，我们已经同意以 10 为基数了

103
00:03:44,530 --> 00:03:48,900
这就是数字的语言，它是隐含的

104
00:03:48,900 --> 00:03:51,000
但确实有

105
00:03:51,300 --> 00:03:53,930
这个数字背后的基本原理是

106
00:03:53,970 --> 00:03:55,170
七乘一百

107
00:03:55,170 --> 00:03:58,000
加两倍10+3乘一

108
00:03:58,930 --> 00:03:59,930
我要去

109
00:03:59,930 --> 00:04:01,170
因为这就是我们做事的方式

110
00:04:01,170 --> 00:04:01,800
基本男高音

111
00:04:01,800 --> 00:04:04,000
提醒你百分之一的地方

112
00:04:04,000 --> 00:04:05,600
第十名和第一名

113
00:04:05,670 --> 00:04:08,530
只是十的连续幂

114
00:04:08,530 --> 00:04:09,000
所以 10 到

115
00:04:09,000 --> 00:04:12,500
0 1 10 到 1 10 10 到 2100 显然

116
00:04:12,500 --> 00:04:14,770
10 到 31,000 等等

117
00:04:15,070 --> 00:04:16,970
这就是我们所说的以 10 为基数的意思

118
00:04:17,399 --> 00:04:20,600
是这个底数被提升到指数

119
00:04:20,930 --> 00:04:22,270
这构成了基础

120
00:04:22,270 --> 00:04:24,500
然后我们乘以任意数字

121
00:04:24,500 --> 00:04:26,170
处于那个位置

122
00:04:27,700 --> 00:04:28,770
例如

123
00:04:28,770 --> 00:04:29,500
如果我有电话号码

124
00:04:29,500 --> 00:04:31,400
五千三百四十九

125
00:04:31,400 --> 00:04:32,500
这将对应于

126
00:04:32,500 --> 00:04:35,100
5乘以10 3+3乘以10 两者

127
00:04:35,100 --> 00:04:37,170
四乘以 10 和九乘以 10 到零

128
00:04:37,200 --> 00:04:39,530
当我再次给你这个号码时

129
00:04:39,600 --> 00:04:42,070
我不必告诉你以 10 为底，这是一致同意的

130
00:04:42,070 --> 00:04:44,300
我们已经预先同意了这一点

131
00:04:44,570 --> 00:04:47,600
但我们应该同意这有点武断

132
00:04:47,600 --> 00:04:48,800
为什么以 10 为基数

133
00:04:48,970 --> 00:04:51,300
你知道有些人认为这是因为这个

134
00:04:51,300 --> 00:04:52,570
实际上非常合适

135
00:04:53,470 --> 00:04:55,570
以 10 为底，因为这是我们用手指数数的方式

136
00:04:55,570 --> 00:04:58,130
1 2 3 4 5 6 7 8 9 10

137
00:04:58,400 --> 00:04:59,300
是的，但是

138
00:04:59,470 --> 00:05:01,100
如果你回顾一下历史，就会有

139
00:05:01,100 --> 00:05:03,200
使用不同数字的其他文明

140
00:05:03,200 --> 00:05:05,170
我最喜欢的例子是我的父亲

141
00:05:05,370 --> 00:05:07,400
我父亲数数的时候他做了一个

142
00:05:07,900 --> 00:05:13,500
2 3 4 5 6 7 8 用拇指数数

143
00:05:13,500 --> 00:05:15,270
我不知道当他到了九点和十点时他会做什么

144
00:05:15,270 --> 00:05:16,770
你只能数到八

145
00:05:17,200 --> 00:05:19,570
以八为底是一个完美的数字，对吧

146
00:05:19,570 --> 00:05:21,400
那么这是什么意思

147
00:05:21,530 --> 00:05:24,700
二五十七代表八基

148
00:05:24,970 --> 00:05:26,730
这意味着

149
00:05:27,470 --> 00:05:29,330
基数现在不是 10

150
00:05:29,700 --> 00:05:31,570
就在那里，他们就在那儿

151
00:05:31,570 --> 00:05:33,870
八了，所以是这个

152
00:05:33,870 --> 00:05:36,930
2 对应于 2 乘以 8 的 2 次方

153
00:05:37,170 --> 00:05:40,130
这 5 对应于以 8 为底的 1 次方

154
00:05:40,130 --> 00:05:40,730
八到大约两个

155
00:05:40,730 --> 00:05:42,570
所以请注意这个数字

156
00:05:42,570 --> 00:05:44,670
这个数字和这个数字完全一样

157
00:05:44,700 --> 00:05:46,100
除了我只是简单地替换了

158
00:05:46,170 --> 00:05:47,870
在前面的示例中 10 与 8

159
00:05:47,870 --> 00:05:49,770
然后当然可以计算出指数

160
00:05:50,000 --> 00:05:51,300
所以二点五十七

161
00:05:51,300 --> 00:05:53,570
以 8 为基数可以转换为以 10 为基数

162
00:05:53,600 --> 00:05:55,800
通过简单地计算这个算术

163
00:05:55,870 --> 00:05:57,470
那是 175

164
00:05:57,470 --> 00:05:58,900
所以你可以想象一个世界

165
00:05:59,130 --> 00:06:01,800
一些社团以八为基数工作的地方

166
00:06:01,900 --> 00:06:03,200
以及一些以 10 为基数的工作

167
00:06:03,200 --> 00:06:06,000
我们必须以与转换相同的方式转换单位

168
00:06:06,070 --> 00:06:08,270
温度 距离 权重

169
00:06:08,370 --> 00:06:09,770
公制和非公制

170
00:06:09,900 --> 00:06:11,670
这会很烦人，但我们可以做到

171
00:06:11,670 --> 00:06:13,870
这个基地并没有什么根本性的问题

172
00:06:13,870 --> 00:06:14,670
什么也没有

173
00:06:14,730 --> 00:06:16,570
关于这个基地的说法基本上是正确的

174
00:06:16,670 --> 00:06:18,170
你可以代表所有的数字

175
00:06:18,170 --> 00:06:19,670
它们只是有不同的含义

176
00:06:21,130 --> 00:06:21,930
现在

177
00:06:22,570 --> 00:06:26,900
基数二也是一个完全有效的基数

178
00:06:27,070 --> 00:06:27,930
顺便注意一下

179
00:06:27,930 --> 00:06:31,370
基数为 2 的数字只有两个数字 0 1

180
00:06:31,370 --> 00:06:36,270
所以以 10 为基数的数字有 10 个数字 0 1 2 到 9

181
00:06:36,930 --> 00:06:39,970
以七为基数的数字只有八个数字为零

182
00:06:39,970 --> 00:06:44,300
到七和以二为基数的数字只有两个数字

183
00:06:44,300 --> 00:06:46,270
零和一还好

184
00:06:46,400 --> 00:06:49,070
所以如果我给你数字零一一零

185
00:06:49,070 --> 00:06:51,970
我问你 10 进制是什么

186
00:06:52,130 --> 00:06:54,100
那么我们玩同一个游戏

187
00:06:54,100 --> 00:06:56,070
这个前导零乘以

188
00:06:56,070 --> 00:06:57,170
二的三次方

189
00:06:57,500 --> 00:06:58,800
这个被乘以

190
00:06:58,800 --> 00:07:00,200
当然是那个

191
00:07:00,200 --> 00:07:01,270
乘二到二

192
00:07:01,300 --> 00:07:02,970
二到一 二到零

193
00:07:03,600 --> 00:07:07,970
算出 2 的幂，结果是 8 4 2 1

194
00:07:08,130 --> 00:07:10,900
这两个乘以零，所以它们消失了

195
00:07:11,100 --> 00:07:12,870
一和四乘以一

196
00:07:12,870 --> 00:07:15,200
四加二等于六，所以是以 10 为底

197
00:07:15,670 --> 00:07:17,770
二基数没有什么对错

198
00:07:17,770 --> 00:07:19,130
我可以代表任何数字

199
00:07:19,130 --> 00:07:20,530
我可以用 10 为基数表示

200
00:07:20,530 --> 00:07:22,200
我可以用八进制来表示

201
00:07:22,200 --> 00:07:25,000
或以 4 为基数或以 16 为基数

202
00:07:25,000 --> 00:07:27,800
好吧，所以基地是任意的

203
00:07:27,800 --> 00:07:30,070
这就是重点，他们是任意的

204
00:07:30,070 --> 00:07:31,470
我们可以代表所有的数字

205
00:07:31,470 --> 00:07:33,400
他们只是有不同的代表

206
00:07:33,400 --> 00:07:35,700
这就是全部和原因

207
00:07:35,900 --> 00:07:39,500
这样做是因为现代计算机会说话

208
00:07:39,700 --> 00:07:41,600
以二进制数表示

209
00:07:41,730 --> 00:07:45,170
他们有两个数字可以代表 1 中的 0

210
00:07:45,170 --> 00:07:47,370
我会谈谈为什么会这样

211
00:07:47,470 --> 00:07:49,370
然后我们将看看如何从

212
00:07:49,500 --> 00:07:51,170
那种语言

213
00:07:51,270 --> 00:07:52,500
现代计算机

214
00:07:52,500 --> 00:07:55,470
到二进制数的实际计算

215
00:07:55,470 --> 00:07:57,330
但当然我们必须理解这种语言

216
00:07:57,470 --> 00:07:58,170
在我们之前

217
00:07:58,170 --> 00:08:00,730
了解该语言实际上正在做什么

218
00:08:01,170 --> 00:08:02,730
好吧，例如

219
00:08:03,670 --> 00:08:05,330
因为电脑

220
00:08:05,800 --> 00:08:08,700
具有有限的内存和有限的精度

221
00:08:08,700 --> 00:08:11,470
我们总是必须指定有多少位

222
00:08:11,570 --> 00:08:14,170
我们将在二进制数中讨论

223
00:08:14,170 --> 00:08:17,530
所以与以 10 为基数不同，我可以给你一个数字

224
00:08:17,900 --> 00:08:19,800
五千三百七十一

225
00:08:19,970 --> 00:08:21,330
二十七八

226
00:08:21,400 --> 00:08:24,000
我不必说这是四位或五位

227
00:08:24,000 --> 00:08:26,100
或一位但以二进制数表示

228
00:08:26,100 --> 00:08:26,900
因为一切

229
00:08:26,900 --> 00:08:29,530
必须具有相同的长度表示

230
00:08:29,800 --> 00:08:32,370
我们总是会指定多少位

231
00:08:32,370 --> 00:08:33,370
我们可以使用

232
00:08:33,370 --> 00:08:36,070
简单地说，我的意思是有多少

233
00:08:36,799 --> 00:08:39,470
2 的幂我有那么 2 位吗

234
00:08:39,929 --> 00:08:42,570
服饰编号表示您可以在

235
00:08:43,200 --> 00:08:45,270
第一个位置 2 的零次方

236
00:08:45,400 --> 00:08:47,130
你可以在第二个位置上有一点

237
00:08:47,130 --> 00:08:47,970
二的幂一

238
00:08:47,970 --> 00:08:48,870
就是这样

239
00:08:49,600 --> 00:08:51,670
现在有一个两位二进制数

240
00:08:51,670 --> 00:08:53,070
你可以走过去并弄清楚

241
00:08:53,070 --> 00:08:53,900
有多少种可能

242
00:08:53,900 --> 00:08:56,330
如果我只有两位，我可以表示数字

243
00:08:56,330 --> 00:08:58,700
好吧，我可以代表 0 0 0

244
00:08:58,700 --> 00:09:00,700
我可以代表一零一

245
00:09:01,100 --> 00:09:04,170
二一零三一一就是这样

246
00:09:04,170 --> 00:09:05,670
没有其他位

247
00:09:05,900 --> 00:09:06,700
所以现在

248
00:09:07,370 --> 00:09:09,200
当我限制位数时

249
00:09:09,200 --> 00:09:10,270
并通过二进制数

250
00:09:10,270 --> 00:09:11,770
现在我确实有一个限制

251
00:09:11,900 --> 00:09:15,530
我只能表示零到三之间的数字

252
00:09:15,570 --> 00:09:17,570
这是真的，我可以说基地 10 ii

253
00:09:17,600 --> 00:09:19,930
你的小数位数不超过两位

254
00:09:19,930 --> 00:09:21,130
或两个位置

255
00:09:21,130 --> 00:09:23,400
那么你只能表示零到之间的数字

256
00:09:23,400 --> 00:09:25,530
909，没有100

257
00:09:25,570 --> 00:09:26,470
所以同样的事情也成立

258
00:09:26,470 --> 00:09:28,330
当然我现在就要开始修理那个婊子了

259
00:09:28,330 --> 00:09:30,100
你会明白为什么会这样

260
00:09:30,300 --> 00:09:32,700
所以让我们确保我们理解这一点

261
00:09:32,900 --> 00:09:34,000
那么为什么这个为零

262
00:09:34,000 --> 00:09:36,330
因为这个数字以 10 为基数为零

263
00:09:36,330 --> 00:09:37,200
乘以 z 的 2 倍

264
00:09:37,470 --> 00:09:39,800
加零乘以二等于 1 0

265
00:09:40,000 --> 00:09:41,370
这是什么No.1

266
00:09:41,400 --> 00:09:45,200
2 乘以 0 等于 1 0 乘以 2 等于 1

267
00:09:45,270 --> 00:09:47,130
所以这是零所以这就是一

268
00:09:47,370 --> 00:09:48,770
好吧零

269
00:09:48,870 --> 00:09:51,670
然后就是一乘二

270
00:09:51,670 --> 00:09:54,770
然后当然我有 2+1 是三

271
00:09:54,870 --> 00:09:57,530
请注意，使用两位二进制数

272
00:09:57,700 --> 00:09:58,330
我将永远

273
00:09:58,330 --> 00:09:59,370
如果他们总是积极的

274
00:09:59,370 --> 00:10:01,070
我们稍后会得到负数

275
00:10:01,130 --> 00:10:05,570
我总能从零到二的2-1次方

276
00:10:05,570 --> 00:10:07,000
所以在这种情况下就是

277
00:10:07,670 --> 00:10:10,400
四二比 2-1 等于三

278
00:10:10,570 --> 00:10:13,770
好吧，如果我给你一个三个二进制数

279
00:10:14,000 --> 00:10:17,070
我的最大值是二的三次方，即八

280
00:10:17,070 --> 00:10:18,470
顺便说一句，如果你想成为一名计算机科学家

281
00:10:18,470 --> 00:10:20,200
你必须非常擅长二的幂

282
00:10:20,970 --> 00:10:24,330
一二四八十六三十二六十四

283
00:10:24,330 --> 00:10:25,170
一点二十八分

284
00:10:25,170 --> 00:10:27,270
二五六五十二十二十四

285
00:10:27,270 --> 00:10:28,100
你可以停在那里

286
00:10:28,100 --> 00:10:30,470
十点二十四十八分之后就很容易了

287
00:10:30,930 --> 00:10:34,930
好的，所以两个的最大功率是最大

288
00:10:34,930 --> 00:10:35,170
对不起

289
00:10:35,170 --> 00:10:38,300
最大的数字是 2 的 3 次方，即 8-1

290
00:10:38,300 --> 00:10:38,600
大概

291
00:10:38,600 --> 00:10:41,530
为什么减一因为我开始数零

292
00:10:41,930 --> 00:10:44,570
所以请注意我有三位二进制数

293
00:10:45,100 --> 00:10:46,100
从右边开始

294
00:10:46,100 --> 00:10:48,470
这是两个到零的位置

295
00:10:48,470 --> 00:10:51,000
两个到一个位置 两个到两个位置

296
00:10:51,500 --> 00:10:52,970
你应该能够说服自己

297
00:10:52,970 --> 00:10:54,570
你可以在这里得到每个数字

298
00:10:54,600 --> 00:10:56,370
通过我刚刚做的转换

299
00:10:56,370 --> 00:10:59,170
所以让我们在这里说五个

300
00:10:59,330 --> 00:11:01,100
那么我怎么知道这是五个

301
00:11:01,100 --> 00:11:03,930
这是二的零，那是多少

302
00:11:04,130 --> 00:11:05,770
那是零所以我不在乎

303
00:11:05,770 --> 00:11:07,900
这是二比二等于四

304
00:11:07,930 --> 00:11:09,700
四加一等于五

305
00:11:09,770 --> 00:11:11,300
请逐一检查

306
00:11:11,300 --> 00:11:13,570
至少在你的脑海里并说服自己

307
00:11:13,670 --> 00:11:15,270
你在这里得到这些数字

308
00:11:15,330 --> 00:11:16,930
好的，这是一个三位二进制数

309
00:11:16,930 --> 00:11:18,500
我可以在零之间数数

310
00:11:18,870 --> 00:11:21,300
和四位二进制数

311
00:11:21,930 --> 00:11:24,330
同一场比赛二对四是16

312
00:11:24,400 --> 00:11:25,800
减一是 15

313
00:11:25,970 --> 00:11:28,570
这是我们四肢着地的最大人数

314
00:11:28,730 --> 00:11:30,870
最小数字当然全为零

315
00:11:31,900 --> 00:11:33,970
再次二到0 2到一

316
00:11:33,970 --> 00:11:35,330
二到三 二到四

317
00:11:35,330 --> 00:11:37,870
让我们看一下例子

318
00:11:38,270 --> 00:11:40,270
这个号码就在这里 11

319
00:11:40,600 --> 00:11:41,770
为什么是11

320
00:11:41,870 --> 00:11:43,000
好吧，让我们从这边走

321
00:11:43,000 --> 00:11:44,370
所以这是二到四

322
00:11:44,370 --> 00:11:47,530
二除四等于 8+2 除二

323
00:11:47,930 --> 00:11:51,130
抱歉，二比一，二比十

324
00:11:51,270 --> 00:11:54,400
二的零等于一，就是 11

325
00:11:54,470 --> 00:11:54,970
然后再次

326
00:11:54,970 --> 00:11:57,330
在这里选择几个数字并说服自己

327
00:11:57,470 --> 00:12:00,670
这些是以 10 为基数的十进制数字

328
00:12:00,700 --> 00:12:03,770
对应这四位二进制数

329
00:12:04,770 --> 00:12:05,570
好的

330
00:12:05,570 --> 00:12:09,200
现在你要补充的问题是我为什么要这样做

331
00:12:09,870 --> 00:12:11,700
对计算机有基础

332
00:12:12,070 --> 00:12:14,730
或者是有原因但事实并非如此

333
00:12:14,730 --> 00:12:15,700
根本上

334
00:12:16,330 --> 00:12:18,170
但这是有充分理由的

335
00:12:18,170 --> 00:12:18,530
这是

336
00:12:18,530 --> 00:12:21,100
表示计算机中的二进制数

337
00:12:21,200 --> 00:12:23,100
非常可靠

338
00:12:23,100 --> 00:12:24,800
让我告诉你我有什么

339
00:12:25,670 --> 00:12:27,930
所以信息当然会存储在计算机上

340
00:12:27,930 --> 00:12:29,300
但就电子而言

341
00:12:29,900 --> 00:12:31,570
这就是计算机的供电方式

342
00:12:31,870 --> 00:12:33,170
所以

343
00:12:33,170 --> 00:12:35,330
我们必须能够表示不同的数字

344
00:12:35,330 --> 00:12:38,370
所以想象一下我想代表说

345
00:12:39,400 --> 00:12:39,930
基数 10

346
00:12:39,930 --> 00:12:42,670
假设我希望我的现代计算机以 10 为基数

347
00:12:42,770 --> 00:12:44,800
这意味着我必须代表数字零

348
00:12:44,800 --> 00:12:46,900
一二三四五六七八九

349
00:12:47,500 --> 00:12:49,070
假设我要表达的方式

350
00:12:49,070 --> 00:12:52,330
让我模拟一下电子的工作原理

351
00:12:52,400 --> 00:12:53,970
我有一个小试管

352
00:12:54,400 --> 00:12:56,770
我要把那个试管装满水

353
00:12:56,900 --> 00:12:59,600
到对应数字的级别

354
00:12:59,700 --> 00:13:00,600
然后那个

355
00:13:00,600 --> 00:13:03,530
试管将对应或代表该数字

356
00:13:03,570 --> 00:13:04,730
所以这里有一个零

357
00:13:04,770 --> 00:13:06,970
它已填满至零级，这是四​​级

358
00:13:07,000 --> 00:13:08,100
它填满了四个

359
00:13:08,300 --> 00:13:09,770
六和七

360
00:13:09,870 --> 00:13:12,370
好的，没有什么问题，非常好

361
00:13:12,470 --> 00:13:15,370
但如果水位有点不稳定怎么办

362
00:13:15,730 --> 00:13:16,970
如果它摇晃怎么办

363
00:13:16,970 --> 00:13:18,770
它在移动一点

364
00:13:18,800 --> 00:13:19,730
这意味着零

365
00:13:19,730 --> 00:13:20,700
可能不小心看起来像

366
00:13:20,700 --> 00:13:22,130
每隔一段时间一个

367
00:13:22,170 --> 00:13:24,200
七可能会意外地看起来像六

368
00:13:24,200 --> 00:13:26,600
或由于有点不稳定而为八

369
00:13:26,600 --> 00:13:28,700
现在显然这不是现代计算机中的水

370
00:13:28,700 --> 00:13:29,930
但这些是电子

371
00:13:30,000 --> 00:13:32,070
电子有一点不稳定

372
00:13:32,070 --> 00:13:33,570
很难保持这一点

373
00:13:33,570 --> 00:13:35,500
水平完全正确

374
00:13:35,500 --> 00:13:36,970
从而区分

375
00:13:37,300 --> 00:13:39,270
10 个不同级别之间

376
00:13:39,270 --> 00:13:41,330
只是在计算机上不太可靠

377
00:13:41,800 --> 00:13:43,400
什么是可靠的

378
00:13:43,400 --> 00:13:45,570
仅区分两件事

379
00:13:45,930 --> 00:13:48,100
这是我的试管，里面装着水

380
00:13:48,100 --> 00:13:49,570
如果为空则为零

381
00:13:49,670 --> 00:13:51,070
如果已满则为 1

382
00:13:51,130 --> 00:13:53,770
现在你可以想象这里是否有一点倾斜

383
00:13:53,770 --> 00:13:55,500
这减少到八，这增加到一

384
00:13:55,500 --> 00:13:56,600
它四处倾斜

385
00:13:56,900 --> 00:13:59,070
我仍然可以区分它们

386
00:13:59,270 --> 00:14:02,000
所以我们想要令人难以置信的表现

387
00:14:02,000 --> 00:14:03,300
彼此不同

388
00:14:03,530 --> 00:14:05,700
当你必须完成 10 个关卡时

389
00:14:06,200 --> 00:14:08,670
如果你愿意的话，你必须有一个更精细的分辨率

390
00:14:08,770 --> 00:14:10,400
如果你只有两个级别

391
00:14:10,400 --> 00:14:10,930
实际上是

392
00:14:10,930 --> 00:14:14,270
更容易应对内部波动

393
00:14:14,470 --> 00:14:16,200
物理表征

394
00:14:16,300 --> 00:14:19,600
简而言之，当我们使用二进制数时

395
00:14:19,770 --> 00:14:21,070
好的

396
00:14:21,070 --> 00:14:22,870
那么此时我们做了什么

397
00:14:23,100 --> 00:14:24,500
我们已经说过了

398
00:14:24,500 --> 00:14:27,800
二进制数是现代计算机的语言

399
00:14:27,800 --> 00:14:30,970
现在还不完全清楚我的意思

400
00:14:30,970 --> 00:14:32,900
我所说的语言是什么意思

401
00:14:32,900 --> 00:14:34,700
是的，所以当谈到数字时

402
00:14:34,700 --> 00:14:37,000
当然我会使用二号基地而不是基地帐篷

403
00:14:37,000 --> 00:14:38,770
但是字母和街道呢

404
00:14:39,100 --> 00:14:40,270
字符串和其他东西

405
00:14:40,330 --> 00:14:42,400
我们稍后会讲到

406
00:14:42,670 --> 00:14:44,330
所以现代计算机的语言是

407
00:14:44,330 --> 00:14:46,530
我们要在二垒说话

408
00:14:46,600 --> 00:14:48,130
我们要在二垒中讨论的原因

409
00:14:48,130 --> 00:14:49,900
是因为可靠性

410
00:14:49,900 --> 00:14:54,270
只需要存储两个状态 0 1

411
00:14:55,070 --> 00:14:56,130
现在此时此刻

412
00:14:56,130 --> 00:14:58,770
我已经向您展示了如何使用 n 来表示

413
00:14:58,770 --> 00:14:59,770
位二进制数

414
00:14:59,770 --> 00:15:01,130
零之间的数字

415
00:15:01,300 --> 00:15:03,670
2 的 n 减一

416
00:15:03,670 --> 00:15:05,970
这是你可以代表的最大数字

417
00:15:06,200 --> 00:15:06,600
但显然

418
00:15:06,600 --> 00:15:08,070
我还有其他想要代表的事情

419
00:15:08,070 --> 00:15:09,270
负数怎么样

420
00:15:09,270 --> 00:15:11,770
浮点数怎么样，字符串怎么样

421
00:15:11,930 --> 00:15:13,470
那么当我们拿起它时我们要做什么

422
00:15:13,530 --> 00:15:14,170
选择后

423
00:15:14,170 --> 00:15:15,170
我们要开始谈论的是

424
00:15:15,170 --> 00:15:16,130
如何做类似的事情

425
00:15:16,130 --> 00:15:16,870
负数

426
00:15:16,870 --> 00:15:18,470
然后我们来讨论分数

427
00:15:18,570 --> 00:15:20,370
然后一旦我们明白了，一旦我们

428
00:15:20,370 --> 00:15:22,470
理解现代计算机的语言

429
00:15:22,470 --> 00:15:23,530
二进制数

430
00:15:23,530 --> 00:15:25,770
我们将讨论计算的本质

431
00:15:25,770 --> 00:15:28,200
计算机实际上是如何计算的

432
00:15:28,530 --> 00:15:31,200
在这些二进制表示上

433
00:15:31,300 --> 00:15:32,200
好吧，就这样吧

434
00:15:32,200 --> 00:15:33,800
我们会在几分钟内取走，很快再见

435
00:15:36,670 --> 00:15:40,470
欢迎回来，我们刚刚讨论了二进制数

436
00:15:40,470 --> 00:15:42,870
以及我们如何表示数字

437
00:15:42,870 --> 00:15:44,300
正数

438
00:15:44,500 --> 00:15:48,000
0 到 2 到 n 减 1 之间

439
00:15:48,170 --> 00:15:50,730
带有结束位二进制数

440
00:15:51,070 --> 00:15:51,670
现在显然

441
00:15:51,670 --> 00:15:53,330
只是正数而已

442
00:15:53,330 --> 00:15:55,100
你需要做的事情的一方面

443
00:15:55,330 --> 00:15:56,700
在现代计算机中

444
00:15:56,870 --> 00:15:58,500
所以你需要能够做诸如消极之类的事情

445
00:15:58,500 --> 00:16:00,100
数字和分数以及其他东西

446
00:16:00,100 --> 00:16:02,500
所以我们先来谈谈负数

447
00:16:03,500 --> 00:16:06,870
那么我们如何再次对负数进行编码

448
00:16:07,130 --> 00:16:09,100
我们没有得到正确的减号

449
00:16:09,100 --> 00:16:10,870
这不像我们正在写的

450
00:16:10,970 --> 00:16:12,700
一张纸上的代数

451
00:16:12,930 --> 00:16:13,500
只有

452
00:16:13,500 --> 00:16:15,600
我们可以在计算机上表示两件事

453
00:16:15,600 --> 00:16:17,730
零和一就是这样

454
00:16:17,930 --> 00:16:20,070
一切都必须由这两个人来完成

455
00:16:20,270 --> 00:16:21,670
信息位

456
00:16:21,730 --> 00:16:24,200
好的，所以我们不能只加一个负号

457
00:16:24,300 --> 00:16:25,730
在不存在的东西面前

458
00:16:25,730 --> 00:16:28,700
所以我们必须以某种方式弄清楚如何使用

459
00:16:28,800 --> 00:16:31,900
一系列的零和一来表示

460
00:16:31,970 --> 00:16:33,330
正数和负数

461
00:16:33,330 --> 00:16:35,170
和分数等等

462
00:16:35,770 --> 00:16:37,300
好吧，这是一个想法

463
00:16:37,530 --> 00:16:41,400
我们可以在末尾前面加一个零

464
00:16:41,570 --> 00:16:44,400
二进制数，表示正数

465
00:16:44,770 --> 00:16:46,900
1 代表负数

466
00:16:46,900 --> 00:16:48,070
我本可以切换这些

467
00:16:48,070 --> 00:16:48,700
没关系

468
00:16:48,700 --> 00:16:51,070
只是我们提出了一些标准

469
00:16:51,530 --> 00:16:53,700
你和我的某种语言

470
00:16:53,700 --> 00:16:55,770
计算机和我达成一致

471
00:16:55,770 --> 00:16:56,730
好的，让我们看看

472
00:16:56,730 --> 00:16:58,270
让我们看看那会是什么样子

473
00:16:59,500 --> 00:17:02,330
所以假设我现在给你三位

474
00:17:02,530 --> 00:17:04,730
有符号的二进制数

475
00:17:04,730 --> 00:17:07,130
请注意，我一直非常小心

476
00:17:07,300 --> 00:17:09,099
当我给你这些二进制数时

477
00:17:09,099 --> 00:17:10,800
告诉你它对应什么

478
00:17:10,800 --> 00:17:12,730
因为如果我刚刚给了你这些

479
00:17:13,270 --> 00:17:16,200
这可能是一个三位无符号二进制数

480
00:17:16,200 --> 00:17:18,170
这将是两人对两人的位置

481
00:17:18,170 --> 00:17:19,930
两个到一位置两个到零

482
00:17:20,369 --> 00:17:22,770
但我现在告诉你这是一个三比特

483
00:17:22,900 --> 00:17:24,569
有符号的二进制数

484
00:17:24,869 --> 00:17:26,530
所以从右边开始

485
00:17:26,530 --> 00:17:28,600
这是 2 到 0 2 到 1

486
00:17:28,770 --> 00:17:30,730
但这就是标志

487
00:17:30,930 --> 00:17:33,070
0 为正 1 为负

488
00:17:33,070 --> 00:17:35,130
看看你在这里注意到的方式

489
00:17:35,200 --> 00:17:37,000
所以这四个都为零

490
00:17:37,100 --> 00:17:39,970
然后数字变为零零 11 011

491
00:17:40,730 --> 00:17:42,400
所有这些都是负面的

492
00:17:42,400 --> 00:17:45,800
同样的事情 0 0 0 1 1 0 1 1

493
00:17:45,870 --> 00:17:47,700
所以你看到这里得到的是负数

494
00:17:47,700 --> 00:17:49,070
这里的正数

495
00:17:49,070 --> 00:17:49,870
好的

496
00:17:50,370 --> 00:17:53,730
所以如果这是我们同意的标志

497
00:17:53,930 --> 00:17:55,870
然后我有一个两位二进制数

498
00:17:55,870 --> 00:17:57,100
我们知道那是什么

499
00:17:57,270 --> 00:17:59,700
这是 0 1 2 3

500
00:17:59,700 --> 00:18:01,330
让我们确保我们理解这一点

501
00:18:01,400 --> 00:18:03,930
这是三，因为它是二的零次方

502
00:18:04,300 --> 00:18:05,670
乘以1+2

503
00:18:05,670 --> 00:18:09,870
1 的幂乘以 1，2+1 等于 3

504
00:18:09,870 --> 00:18:12,400
和我们在上一讲中所做的一样

505
00:18:12,500 --> 00:18:14,930
好的，那么下面的四个数字呢

506
00:18:15,130 --> 00:18:19,400
显然这些都是负数 1 1 1 1 1

507
00:18:19,670 --> 00:18:21,300
那么负数是多少

508
00:18:21,370 --> 00:18:24,170
好吧，这就是两位位置上的任何内容

509
00:18:24,170 --> 00:18:25,270
所以这是三个

510
00:18:25,270 --> 00:18:26,500
所以这是-3

511
00:18:26,670 --> 00:18:29,470
两个是-2 一个是-1

512
00:18:29,600 --> 00:18:30,970
这有点奇怪

513
00:18:30,970 --> 00:18:34,170
现在我有一个 -0 这当然与零相同

514
00:18:34,170 --> 00:18:35,070
所以这有点

515
00:18:35,500 --> 00:18:36,570
有点奇怪

516
00:18:36,570 --> 00:18:37,600
与此表示

517
00:18:37,600 --> 00:18:40,870
我们本质上在 -0 中有两个零和一个正数

518
00:18:41,170 --> 00:18:41,930
那不太好

519
00:18:41,930 --> 00:18:44,970
使用这种类型实际上还有其他问题

520
00:18:44,970 --> 00:18:46,330
标志的前导位

521
00:18:46,330 --> 00:18:47,800
我稍后将向您展示

522
00:18:47,970 --> 00:18:49,730
这实际上不是

523
00:18:50,130 --> 00:18:52,970
现代计算机使用什么，他们不使用这个

524
00:18:53,100 --> 00:18:55,000
这似乎是一件很容易做的事情

525
00:18:55,000 --> 00:18:57,470
坦率地说，这对我们人类有好处

526
00:18:57,470 --> 00:18:58,770
因为我可以看第一部分

527
00:18:58,770 --> 00:18:59,930
只要我知道它是什么

528
00:18:59,930 --> 00:19:01,670
我可以立即告诉你是否呈阳性

529
00:19:01,670 --> 00:19:02,400
或负数

530
00:19:02,400 --> 00:19:05,200
然后我必须解释除此之外的所有内容

531
00:19:05,300 --> 00:19:07,130
但随着计算机的发展

532
00:19:07,130 --> 00:19:09,200
这是一个相当笨拙的表示

533
00:19:09,600 --> 00:19:10,870
而不是做

534
00:19:11,300 --> 00:19:13,270
指定的代表

535
00:19:13,270 --> 00:19:15,100
我们要做的就是所谓的“两人的”

536
00:19:15,200 --> 00:19:17,070
补码表示法

537
00:19:17,100 --> 00:19:19,000
让我来描述一下我的意思

538
00:19:20,300 --> 00:19:22,470
所以我们又需要一个机制

539
00:19:22,700 --> 00:19:25,970
表示正数和负数

540
00:19:25,970 --> 00:19:29,100
好的，所以我将从一个未签名的开始

541
00:19:29,130 --> 00:19:30,570
所以这意味着第一次出价

542
00:19:30,570 --> 00:19:31,900
与标志无关

543
00:19:31,900 --> 00:19:32,700
现在

544
00:19:33,300 --> 00:19:34,870
投标二进制数

545
00:19:35,400 --> 00:19:38,530
最左边的位始终为零

546
00:19:38,530 --> 00:19:40,670
好的，这就是标志

547
00:19:40,670 --> 00:19:42,930
但不是像我之前向你展示的那样

548
00:19:43,070 --> 00:19:46,170
好的，所以这个数字必须为零

549
00:19:46,200 --> 00:19:47,800
为正数

550
00:19:47,800 --> 00:19:50,900
好吧，这当然是二对二

551
00:19:50,900 --> 00:19:52,730
二到一 二到零

552
00:19:52,730 --> 00:19:54,770
所以让我们确保我们理解为什么是六

553
00:19:55,130 --> 00:19:57,100
这是二比一的二

554
00:19:57,130 --> 00:19:58,900
二加二等于四

555
00:19:58,900 --> 00:20:01,670
四加二等于六

556
00:20:01,730 --> 00:20:05,170
好的好的，所以我们从一个未签名的开始

557
00:20:05,530 --> 00:20:08,900
四位或五位或六位或任何你想要的

558
00:20:09,000 --> 00:20:11,200
最左边的位为零

559
00:20:11,200 --> 00:20:12,900
那零当然会

560
00:20:13,170 --> 00:20:14,700
对应正数

561
00:20:14,700 --> 00:20:16,470
但同样不是以上面相同的方式

562
00:20:16,470 --> 00:20:18,400
一会儿你就会明白为什么会这样

563
00:20:19,100 --> 00:20:22,330
现在使该数字变为-6

564
00:20:22,500 --> 00:20:23,530
这就是我要做的

565
00:20:23,530 --> 00:20:25,530
所以我们知道如何计算所有正数

566
00:20:25,530 --> 00:20:28,770
正确的是第四个位置是零

567
00:20:28,770 --> 00:20:30,330
然后你就跑过去

568
00:20:30,400 --> 00:20:31,530
全部

569
00:20:31,570 --> 00:20:35,070
这三个投注的 2 比 3-1 可能性

570
00:20:35,070 --> 00:20:35,870
好的

571
00:20:36,800 --> 00:20:39,330
我该如何制作-6 所以这就是你要做的

572
00:20:39,570 --> 00:20:43,170
取六的表示并翻转位

573
00:20:43,170 --> 00:20:45,170
这称为对位求补

574
00:20:45,170 --> 00:20:49,870
所以 0 变为 1 1 变为 0 1 变为 0

575
00:20:49,930 --> 00:20:50,870
零变为一

576
00:20:50,870 --> 00:20:54,470
这就是每一位都被翻转的补码

577
00:20:54,730 --> 00:20:56,530
请注意，根据定义

578
00:20:56,530 --> 00:20:58,730
第一个位置必须是一个

579
00:20:59,500 --> 00:21:02,670
为什么那么好，因为根据定义，它为零

580
00:21:02,670 --> 00:21:04,600
当我翻转它时，它会变成一个

581
00:21:04,870 --> 00:21:07,770
所以任何有一个的东西

582
00:21:08,570 --> 00:21:12,070
重要地位将为负

583
00:21:12,070 --> 00:21:14,870
但解释不一样

584
00:21:14,930 --> 00:21:16,330
就是我在上面给你展示的

585
00:21:16,330 --> 00:21:19,470
因为那显然不是六个

586
00:21:19,470 --> 00:21:20,930
那是别的事

587
00:21:21,170 --> 00:21:23,670
好吧，所以我们必须弄清楚这实际上意味着什么

588
00:21:23,670 --> 00:21:27,730
好的，补充你的二进制数，然后加一

589
00:21:28,170 --> 00:21:32,270
好的，这是我在最重要位置的 6 0

590
00:21:32,270 --> 00:21:32,900
称赞它

591
00:21:32,900 --> 00:21:33,930
所有的零都变成一

592
00:21:33,930 --> 00:21:36,670
所有的都归零然后加一

593
00:21:36,730 --> 00:21:39,870
那么这里加一是什么意思 1+1 等于二

594
00:21:40,000 --> 00:21:42,870
这意味着我携带一滴零

595
00:21:42,970 --> 00:21:46,270
就在那里，我得到了 1 0 1 0

596
00:21:46,370 --> 00:21:48,000
即-6

597
00:21:48,870 --> 00:21:51,900
现在这个表示有什么奇怪的

598
00:21:51,970 --> 00:21:55,500
如果我看看这三个位就在这里

599
00:21:55,500 --> 00:21:57,170
看起来不像六个

600
00:21:57,330 --> 00:21:59,500
2 到 0 2 到 1 是 2

601
00:21:59,970 --> 00:22:02,870
所以我们不能看着这个就说哦

602
00:22:03,070 --> 00:22:04,330
就像我们做的那样

603
00:22:04,330 --> 00:22:06,330
正数或带符号

604
00:22:06,370 --> 00:22:08,270
非星期二补充符号的事情

605
00:22:08,470 --> 00:22:10,570
这是一个略有不同的表示

606
00:22:10,570 --> 00:22:13,530
看来我们已经倒退了一步

607
00:22:13,530 --> 00:22:14,730
这似乎不太好

608
00:22:14,730 --> 00:22:16,800
看起来更糟，看起来更复杂

609
00:22:17,100 --> 00:22:19,100
但事实证明这并没有写

610
00:22:19,100 --> 00:22:20,070
给我和你

611
00:22:20,170 --> 00:22:21,670
它是为计算机编写的

612
00:22:21,870 --> 00:22:23,300
我马上就会告诉你为什么

613
00:22:23,300 --> 00:22:24,770
这是一个非常好的表现

614
00:22:24,770 --> 00:22:26,100
计算机中的负数

615
00:22:26,100 --> 00:22:27,300
即使对于我们来说

616
00:22:27,330 --> 00:22:29,000
有点难读

617
00:22:29,870 --> 00:22:31,400
好吧，现在让我们看看这个

618
00:22:31,570 --> 00:22:33,300
假设我有一个三比特

619
00:22:33,500 --> 00:22:38,130
使用二进制补码进行签名

620
00:22:38,570 --> 00:22:40,570
好吧，让我们做简单的吧

621
00:22:40,570 --> 00:22:43,000
所以正零到三就是

622
00:22:43,130 --> 00:22:45,770
我们必须在最重要的地方有一个零

623
00:22:45,870 --> 00:22:48,470
所以这意味着只有四个可能的数字

624
00:22:48,470 --> 00:22:50,130
两队战成2-1

625
00:22:50,300 --> 00:22:51,500
和以前一样

626
00:22:51,500 --> 00:22:54,930
0 0 0 1 1 0 1 1 好

627
00:22:54,930 --> 00:22:56,070
所以这显然是三个

628
00:22:56,070 --> 00:23:00,000
二加一等于二等于一等于零好

629
00:23:00,200 --> 00:23:02,730
现在我想要这些的负面影响

630
00:23:02,730 --> 00:23:03,570
现在有这个

631
00:23:03,570 --> 00:23:05,370
我们必须解决零的事情

632
00:23:05,370 --> 00:23:05,770
记住

633
00:23:05,770 --> 00:23:07,700
在上一篇带有签名的表示中

634
00:23:07,700 --> 00:23:10,300
我们得到零的两种不同表示

635
00:23:10,300 --> 00:23:11,730
我们稍后再讨论这个

636
00:23:12,070 --> 00:23:15,500
如何得到正数的负数

637
00:23:15,570 --> 00:23:17,770
我对数字进行补码翻转位

638
00:23:17,770 --> 00:23:20,130
我添加一个，这会给我

639
00:23:20,170 --> 00:23:22,000
负面表征

640
00:23:22,100 --> 00:23:23,700
该正数的

641
00:23:23,700 --> 00:23:25,400
所以让我们继续为所有这些做这件事

642
00:23:25,400 --> 00:23:26,770
我们也会看看会发生什么

643
00:23:26,770 --> 00:23:27,900
零就在那里

644
00:23:29,200 --> 00:23:31,000
好的，让我们从一个开始

645
00:23:31,000 --> 00:23:32,330
我会在一分钟内回到零

646
00:23:32,330 --> 00:23:37,470
所以请补充 0 0 1 即 1 1 0

647
00:23:37,670 --> 00:23:38,870
对此加一

648
00:23:38,870 --> 00:23:40,700
所以你可以用老式的方式做到这一点

649
00:23:40,700 --> 00:23:42,100
你在小学学到了什么

650
00:23:42,130 --> 00:23:44,470
你在这里放一个，然后添加这两个

651
00:23:44,470 --> 00:23:46,200
你添加这两个 你添加这两个

652
00:23:46,470 --> 00:23:47,800
记得做事

653
00:23:48,570 --> 00:23:49,500
一位版本

654
00:23:50,270 --> 00:23:51,370
而是二进制版本

655
00:23:51,370 --> 00:23:54,700
这样 0+1 就是 1 然后就没有东西可以带了

656
00:23:54,700 --> 00:23:58,300
所以 1 1 0 这个加一的补码就是这个

657
00:23:58,370 --> 00:24:02,070
那就是-1 这就是它的表示

658
00:24:02,970 --> 00:24:04,070
让我们来做这个吧

659
00:24:04,100 --> 00:24:05,170
让我们翻转一下

660
00:24:05,170 --> 00:24:10,900
0 1 0 给我 1 0 1 0 变为 1 1 变为 0

661
00:24:10,930 --> 00:24:12,300
请添加一个

662
00:24:12,800 --> 00:24:15,070
好吧，一加一二是多少

663
00:24:15,400 --> 00:24:18,500
二进制 1 0 中的 2 是多少

664
00:24:18,500 --> 00:24:19,930
所以那个人携带

665
00:24:19,930 --> 00:24:22,300
进入这个位置，零下降

666
00:24:22,470 --> 00:24:25,570
那么 1+0 是 1 然后我得到 1

667
00:24:25,570 --> 00:24:29,600
所以我有 1 1 0 即 -2

668
00:24:29,800 --> 00:24:32,670
好的，再次注意这里的这个位置

669
00:24:32,670 --> 00:24:33,930
必须始终是一个

670
00:24:33,930 --> 00:24:35,600
因为当我翻转这些位时

671
00:24:35,600 --> 00:24:38,730
我总是会把零变成一

672
00:24:39,470 --> 00:24:40,400
让我们再做一个

673
00:24:41,170 --> 00:24:44,000
翻转三，即 0 1 1 变为 1 0 0

674
00:24:44,000 --> 00:24:46,200
加一个当然就是 1 0 1

675
00:24:46,300 --> 00:24:48,670
那是-3 好吧

676
00:24:48,800 --> 00:24:50,800
现在让我们看看零会发生什么

677
00:24:51,400 --> 00:24:53,730
顺便你可以看看会发生什么

678
00:24:53,730 --> 00:24:56,470
那么当我补零零时会发生什么

679
00:24:56,500 --> 00:25:01,330
我得到 1 1 1，当我向其中添加 1 时会发生什么

680
00:25:01,500 --> 00:25:02,870
好吧，那我们把这个放在这里吧

681
00:25:02,870 --> 00:25:05,100
我将携带一并放下零

682
00:25:05,270 --> 00:25:05,930
那是两个

683
00:25:05,930 --> 00:25:08,270
我将再次携带一滴零

684
00:25:08,400 --> 00:25:09,100
那是两个

685
00:25:09,100 --> 00:25:12,170
我将再次携带一并放下零

686
00:25:12,300 --> 00:25:13,800
所以我的成绩都是零

687
00:25:13,800 --> 00:25:16,570
然后就是我们称之为溢出的一个

688
00:25:16,730 --> 00:25:17,970
这是第四位

689
00:25:18,270 --> 00:25:20,130
但我只有一个三位数字

690
00:25:20,170 --> 00:25:23,070
第四位它消失了我们无法代表它

691
00:25:23,070 --> 00:25:26,330
所以我最终得到了非常好的零

692
00:25:26,930 --> 00:25:28,600
所以这是一件非常好的事情

693
00:25:28,600 --> 00:25:31,700
二进制补码是零的二进制补码

694
00:25:31,770 --> 00:25:32,730
为零

695
00:25:32,970 --> 00:25:35,930
现在关于两个人的赞美的奇怪的事情之一是

696
00:25:36,000 --> 00:25:38,470
这些数字有点神秘，对吧

697
00:25:38,470 --> 00:25:39,800
如果我给你这个号码

698
00:25:39,800 --> 00:25:42,400
这并不是立即明显的，这对

699
00:25:42,570 --> 00:25:44,300
-1或-3

700
00:25:44,300 --> 00:25:47,500
你必须扭转这个过程才能回来

701
00:25:47,730 --> 00:25:50,000
但我将向您展示计算机上的情况

702
00:25:50,330 --> 00:25:52,370
这个表现太棒了

703
00:25:52,530 --> 00:25:54,870
因为它使算术之类的事情变得非常容易

704
00:25:54,870 --> 00:25:56,770
顺便说一句，我们只有 1 0

705
00:25:56,770 --> 00:25:58,400
这是一件好事

706
00:25:58,900 --> 00:25:59,700
好的

707
00:26:00,270 --> 00:26:05,400
所以一件奇怪的事情是我们似乎丢失了一个号码

708
00:26:06,100 --> 00:26:08,330
为什么我有 0 1 2 3

709
00:26:08,670 --> 00:26:11,530
我有零，这是相同的零

710
00:26:11,530 --> 00:26:12,770
然后我就得到了负一负二

711
00:26:12,770 --> 00:26:13,570
负三

712
00:26:13,670 --> 00:26:15,730
所以我只有七个数字

713
00:26:15,970 --> 00:26:17,500
但有三位

714
00:26:17,500 --> 00:26:19,930
如果这是一个无符号的二进制数

715
00:26:19,930 --> 00:26:22,530
我应该有多少个三位数字

716
00:26:22,800 --> 00:26:24,570
2比3-1

717
00:26:24,730 --> 00:26:26,700
我应该有八个号码

718
00:26:26,700 --> 00:26:30,000
从零到七的七个数字

719
00:26:30,270 --> 00:26:35,770
我只有 1 2 3 4 5 6 7

720
00:26:35,800 --> 00:26:37,670
最后一个数字去哪儿了

721
00:26:38,600 --> 00:26:41,670
嗯，缺少一些东西是的

722
00:26:41,900 --> 00:26:44,770
那么它在哪里让我们看看

723
00:26:47,670 --> 00:26:48,470
哦，那好吧

724
00:26:48,900 --> 00:26:52,200
我看到我有四个以零开头的数字

725
00:26:52,400 --> 00:26:54,130
但我看到他们只有

726
00:26:54,300 --> 00:26:56,600
以一开头的三个数字

727
00:26:57,100 --> 00:26:59,400
所以你能看到缺少哪一个吗

728
00:27:00,900 --> 00:27:04,930
好 1 0 0 它不在这里

729
00:27:05,170 --> 00:27:08,200
好吧，现在 1 0 0 对应什么

730
00:27:08,870 --> 00:27:11,070
嗯，这是一种奇怪的牙齿补数

731
00:27:11,070 --> 00:27:11,700
我不知道

732
00:27:11,700 --> 00:27:13,900
但我知道这是一个负数

733
00:27:14,570 --> 00:27:17,800
那么我如何找出它的积极核心是什么

734
00:27:18,000 --> 00:27:21,400
好吧，我必须反向运行这个过程

735
00:27:21,770 --> 00:27:24,870
那我该怎么办 我必须从这里减去一个

736
00:27:25,370 --> 00:27:28,370
再次补，然后我得到正数

737
00:27:28,370 --> 00:27:30,000
顺便问一下为什么我要再次补充

738
00:27:30,000 --> 00:27:31,300
怎么是相反的

739
00:27:31,370 --> 00:27:35,070
好吧，如果我通过翻转从零到一

740
00:27:35,070 --> 00:27:37,330
我可以通过再次翻转从一到零

741
00:27:37,500 --> 00:27:40,270
所以如果你对一个数字求补两次你就会回到它

742
00:27:40,270 --> 00:27:43,700
所以补码的逆就是补码

743
00:27:44,170 --> 00:27:45,670
好吧，让我们弄清楚这是什么

744
00:27:45,670 --> 00:27:46,600
这个号码是多少

745
00:27:46,600 --> 00:27:49,370
我的意思是你知道这可能是负面的

746
00:27:49,370 --> 00:27:50,970
但让我们相信这一点

747
00:27:51,970 --> 00:27:53,870
好吧，让我们做 1 0 0

748
00:27:53,870 --> 00:27:54,970
我们要减去一个

749
00:27:54,970 --> 00:27:56,970
我们将进行补充，看看我们会得到什么

750
00:27:57,130 --> 00:27:59,730
好吧 一零零减一是多少 好吧

751
00:27:59,770 --> 00:28:01,270
所以你可以通过几种方法来做到这一点

752
00:28:01,270 --> 00:28:02,070
这是一个

753
00:28:02,070 --> 00:28:05,330
你可以按顺序写出二进制数

754
00:28:05,330 --> 00:28:06,400
有 1 0 0

755
00:28:06,400 --> 00:28:07,670
你可以减去一

756
00:28:07,670 --> 00:28:09,330
看到之前的数字

757
00:28:09,470 --> 00:28:11,130
只是 0 1 1

758
00:28:11,300 --> 00:28:12,700
好的好的所以

759
00:28:13,100 --> 00:28:15,300
一零零减一是 0 1 1

760
00:28:15,300 --> 00:28:16,970
让我们补充一下

761
00:28:16,970 --> 00:28:19,500
所以这会给我 1 0 0

762
00:28:19,800 --> 00:28:20,600
啊

763
00:28:20,970 --> 00:28:23,100
那么 1 0 0 是什么

764
00:28:23,100 --> 00:28:25,070
所以现在这是正数

765
00:28:25,200 --> 00:28:27,370
顺便注意一下那里有一个

766
00:28:27,530 --> 00:28:28,800
看起来很奇怪

767
00:28:29,000 --> 00:28:31,800
因为根据定义应该为零

768
00:28:31,970 --> 00:28:34,200
但这是负数

769
00:28:34,200 --> 00:28:35,870
我们只是简单地扭转它

770
00:28:36,170 --> 00:28:39,600
所以这是 2 到 0 2 到 1 2 到 2

771
00:28:39,700 --> 00:28:44,730
这里是 4，这一定意味着这里是 -4

772
00:28:45,130 --> 00:28:46,170
好吧，很好

773
00:28:46,530 --> 00:28:47,330
所以

774
00:28:48,500 --> 00:28:51,130
现在我们有一个有趣的对称性

775
00:28:51,470 --> 00:28:54,670
如果我有一个结束位无符号二进制数

776
00:28:54,670 --> 00:28:56,300
我可以从零开始

777
00:28:56,300 --> 00:28:57,730
到二到联合国减一

778
00:28:57,730 --> 00:29:00,200
所以我有两个到最后的总数

779
00:29:00,200 --> 00:29:03,800
但最大数量将是二的联合国减一

780
00:29:04,400 --> 00:29:05,800
与一个

781
00:29:06,270 --> 00:29:10,600
n 位使用二进制补码进行签名

782
00:29:10,870 --> 00:29:14,370
我从负二到联合国负一

783
00:29:14,470 --> 00:29:16,130
到二到联合国减一

784
00:29:16,500 --> 00:29:19,570
减一，即少一个正数

785
00:29:19,800 --> 00:29:21,170
比负数

786
00:29:21,170 --> 00:29:23,700
让我们确保这对我们有意义 是的

787
00:29:23,900 --> 00:29:27,470
所以在这种情况下我有什么并且是三个

788
00:29:27,800 --> 00:29:29,500
是的，如果我有 n 是三

789
00:29:29,670 --> 00:29:31,200
那么这个表示是什么

790
00:29:31,200 --> 00:29:34,670
所以 3-1 是 2，即 2

791
00:29:35,000 --> 00:29:38,500
二除二等于四，所以这是我的-4

792
00:29:38,500 --> 00:29:43,000
我的比分是 4-1，所以现在是 3

793
00:29:43,200 --> 00:29:45,500
所以有轻微的不对称

794
00:29:45,500 --> 00:29:47,100
顺便问一下为什么会有不对称

795
00:29:47,100 --> 00:29:48,930
只是因为现在只有 1 0

796
00:29:48,930 --> 00:29:50,470
是的，所以你将会有

797
00:29:50,930 --> 00:29:52,570
一侧比另一侧多一个

798
00:29:52,570 --> 00:29:54,330
结果发现你又多了一个负数

799
00:29:54,330 --> 00:29:56,400
事实证明这在实践中根本不重要

800
00:29:56,600 --> 00:29:59,400
但请注意这里轻微的不对称

801
00:30:00,170 --> 00:30:00,970
好的

802
00:30:01,070 --> 00:30:04,070
所以为什么我的意思是这看起来工作量很大

803
00:30:04,070 --> 00:30:07,270
和很多非常多的麻烦来做到这一点来补充

804
00:30:07,370 --> 00:30:10,200
因为现在我无法读取这两个的补数

805
00:30:10,200 --> 00:30:10,570
确实

806
00:30:10,570 --> 00:30:13,100
我得去减一并补它

807
00:30:13,200 --> 00:30:14,300
那么我为什么要这样做

808
00:30:14,300 --> 00:30:15,370
原因之一是

809
00:30:15,370 --> 00:30:17,130
你得到单个零表示

810
00:30:17,130 --> 00:30:18,130
这很好

811
00:30:18,330 --> 00:30:19,670
但这是真正的原因

812
00:30:19,770 --> 00:30:22,770
就是当你用二进制补码做算术运算时

813
00:30:22,900 --> 00:30:23,970
效果很好

814
00:30:23,970 --> 00:30:25,570
让我向你展示它是如何运作的

815
00:30:25,570 --> 00:30:28,130
好吧，让我们回到取消二进制数的符号

816
00:30:28,130 --> 00:30:30,000
让我们做一些二进制算术

817
00:30:30,200 --> 00:30:32,600
假设我想添加 2+2

818
00:30:32,600 --> 00:30:34,270
这当然是我的 10 进制

819
00:30:34,470 --> 00:30:35,770
让我们写出四个

820
00:30:35,770 --> 00:30:37,970
两个的位二进制表示

821
00:30:38,500 --> 00:30:40,200
2 到 0 2 到 1

822
00:30:40,200 --> 00:30:42,000
二对二 二对三

823
00:30:42,130 --> 00:30:45,330
所以二只是一乘二除一

824
00:30:45,330 --> 00:30:46,600
然后其他地方都为零

825
00:30:46,600 --> 00:30:48,370
所以有两个 有两个

826
00:30:48,700 --> 00:30:49,730
好的，我该如何添加

827
00:30:49,800 --> 00:30:51,570
以同样的方式添加以 10 为基数

828
00:30:51,670 --> 00:30:54,600
所以逐列 0+0 为零

829
00:30:54,770 --> 00:30:56,330
一加一等于二

830
00:30:56,670 --> 00:30:58,300
二进制中的二是一

831
00:30:58,300 --> 00:31:00,700
我拿着一，丢掉零

832
00:31:00,870 --> 00:31:04,100
所以现在我有一加零加零就是一

833
00:31:04,270 --> 00:31:05,600
然后我就得到了零

834
00:31:05,800 --> 00:31:06,930
所以那就是

835
00:31:07,870 --> 00:31:10,070
这两个中的四位

836
00:31:10,470 --> 00:31:11,470
对于位数

837
00:31:11,470 --> 00:31:14,070
当然，这口井是什么，有两个

838
00:31:14,300 --> 00:31:16,670
0 2 到一 二到二

839
00:31:16,670 --> 00:31:18,700
那是四个，那当然是四个

840
00:31:19,070 --> 00:31:21,370
所以就像我可以以 10 为基数相加

841
00:31:21,370 --> 00:31:22,600
我可以添加基数二

842
00:31:22,670 --> 00:31:24,900
你只是加起来，但你只需要在基数二中做所有的事情

843
00:31:25,700 --> 00:31:29,200
那么让我们看看如果我们使用老式的它是如何工作的

844
00:31:29,600 --> 00:31:32,770
非管补体的签名表示

845
00:31:33,070 --> 00:31:33,600
好的

846
00:31:33,600 --> 00:31:37,270
所以我们把 -2 中的 2 相加，当然这应该为零

847
00:31:37,300 --> 00:31:40,000
以及老式的指定表示法

848
00:31:40,000 --> 00:31:42,670
二是什么 0 0 1 0

849
00:31:42,730 --> 00:31:44,470
零告诉我这是积极的

850
00:31:44,500 --> 00:31:46,730
我得到了代表每个数字的三位

851
00:31:46,730 --> 00:31:48,070
零和之间

852
00:31:48,100 --> 00:31:49,130
二减一

853
00:31:49,130 --> 00:31:50,400
在这种情况下有七个

854
00:31:50,770 --> 00:31:53,730
现在为了得到这个负值，我只需将该位翻转为 1

855
00:31:53,730 --> 00:31:55,000
一切都保持不变

856
00:31:55,300 --> 00:31:56,730
我喜欢这个代表

857
00:31:56,730 --> 00:31:58,070
我发现它真的很容易阅读

858
00:31:58,070 --> 00:31:59,400
我不必经历这一切

859
00:31:59,400 --> 00:32:00,500
计算的种类

860
00:32:00,500 --> 00:32:02,300
从牙齿赞美回到

861
00:32:03,470 --> 00:32:05,470
常规二进制文件，这样我就可以弄清楚

862
00:32:05,570 --> 00:32:07,470
但让我们看看当我们尝试添加时会发生什么

863
00:32:07,470 --> 00:32:08,570
这两件事

864
00:32:08,870 --> 00:32:10,930
好吧零加零零

865
00:32:11,130 --> 00:32:13,530
一加一等于二

866
00:32:13,530 --> 00:32:16,500
观察二进一落零

867
00:32:16,500 --> 00:32:20,100
所以现在我有一加零加零就是一

868
00:32:20,170 --> 00:32:22,700
然后我得到 0+1 是 1

869
00:32:22,730 --> 00:32:24,770
这就是我得到的就是零

870
00:32:25,330 --> 00:32:26,400
绝对不

871
00:32:26,670 --> 00:32:27,930
所以简单的

872
00:32:28,370 --> 00:32:30,370
即使是简单的，顺便说一句，这是有道理的

873
00:32:30,370 --> 00:32:31,730
它不应该为零，因为

874
00:32:31,800 --> 00:32:32,600
这些不是

875
00:32:32,600 --> 00:32:34,970
数字以与符号相同的方式表示

876
00:32:35,070 --> 00:32:37,000
所以这根本没有意义

877
00:32:37,300 --> 00:32:40,770
然后用符号数进行简单的算术运算

878
00:32:40,770 --> 00:32:41,870
根本行不通

879
00:32:41,870 --> 00:32:43,200
顺便说一句，这并非偶然

880
00:32:43,200 --> 00:32:45,800
取任意两个正负数

881
00:32:45,800 --> 00:32:48,100
尝试将它们相加，你不会得到零

882
00:32:48,100 --> 00:32:49,930
所以这里是 3 这里是 -3

883
00:32:49,930 --> 00:32:51,770
总结一下你会发现这里一团糟

884
00:32:51,800 --> 00:32:53,500
这当然不为零

885
00:32:54,000 --> 00:32:56,570
但是当你用补码来做这件事时

886
00:32:56,670 --> 00:32:59,900
效果真的很好，让我们来看看

887
00:33:00,270 --> 00:33:01,900
好吧，让我们在 -2 中添加两个

888
00:33:01,900 --> 00:33:02,900
现在这是缺点

889
00:33:02,900 --> 00:33:04,800
-2 和补码是什么

890
00:33:04,800 --> 00:33:06,130
好吧，我得计算一下

891
00:33:06,130 --> 00:33:07,900
好吧，让我们来计算一下

892
00:33:08,300 --> 00:33:11,930
所以 -2 是我对这个数字求补并加一

893
00:33:12,100 --> 00:33:16,000
所以请用这里的 0 0 1 0 补足

894
00:33:16,130 --> 00:33:17,800
那些零变成了

895
00:33:17,870 --> 00:33:19,570
那些变成零

896
00:33:19,570 --> 00:33:22,300
然后我添加一个，然后我就得到了这个数字

897
00:33:22,300 --> 00:33:23,400
好的

898
00:33:23,470 --> 00:33:26,800
所以二进制补码是-2

899
00:33:27,200 --> 00:33:28,870
让我们把它放下

900
00:33:28,930 --> 00:33:32,170
现在让我们添加老式的方式

901
00:33:32,470 --> 00:33:34,800
好吧 0+0 为零

902
00:33:35,130 --> 00:33:39,370
1+1是两个进位一个减零

903
00:33:39,500 --> 00:33:40,900
一加一等于二

904
00:33:40,970 --> 00:33:43,370
携带一滴零

905
00:33:43,400 --> 00:33:44,770
一加一等于二

906
00:33:44,800 --> 00:33:47,470
携带最后一次删除零

907
00:33:47,600 --> 00:33:49,170
顺便说一句，这是一个溢出

908
00:33:49,170 --> 00:33:51,930
这是第五位，它变得齐平，不用关心它

909
00:33:51,970 --> 00:33:53,330
现在我的分数为零

910
00:33:53,600 --> 00:33:56,700
所以请注意这个非常漂亮的表示

911
00:33:56,770 --> 00:33:59,870
允许我做简单的位版本

912
00:34:00,170 --> 00:34:01,170
顺便说一句

913
00:34:01,200 --> 00:34:03,000
这就是计算机的神奇之处

914
00:34:03,000 --> 00:34:04,570
进行这些类型的计算

915
00:34:04,570 --> 00:34:06,100
这非常简单

916
00:34:06,100 --> 00:34:08,500
让我们再举一个例子来告诉你这不是侥幸

917
00:34:09,100 --> 00:34:12,370
所以在二进制补码中四位二进制补码

918
00:34:12,370 --> 00:34:13,699
这仍然是一个三

919
00:34:13,699 --> 00:34:18,530
2 到 0 1 2 到 1 就是 2，所以 2+1 是 3

920
00:34:18,870 --> 00:34:19,900
所以这是三个

921
00:34:20,100 --> 00:34:22,100
当然这个数字必须是零

922
00:34:22,100 --> 00:34:23,170
用于号码存入

923
00:34:23,300 --> 00:34:26,370
让我们弄清楚 -3 是多少，可以回到这里

924
00:34:26,370 --> 00:34:27,170
补充

925
00:34:27,300 --> 00:34:30,170
零变成一 那些变成零

926
00:34:30,370 --> 00:34:35,270
添加一个 我从 1 1 0 0 变为 1 1 0 1

927
00:34:35,330 --> 00:34:37,900
右边是-3

928
00:34:38,130 --> 00:34:39,199
把它放下

929
00:34:40,170 --> 00:34:44,699
加起来就可以了 1+1 就是两个进位 一个减零

930
00:34:44,730 --> 00:34:46,770
一加一加零等于二

931
00:34:46,770 --> 00:34:48,570
携带一滴零

932
00:34:48,929 --> 00:34:51,199
一加零加一等于二

933
00:34:51,330 --> 00:34:54,100
携带一滴零最后一滴

934
00:34:54,130 --> 00:34:57,370
一加零加一等于二进位一

935
00:34:57,370 --> 00:34:59,270
这是一个溢出，这是我们的第五位

936
00:34:59,330 --> 00:35:01,330
去掉零，你就得到零

937
00:35:01,730 --> 00:35:03,170
所以当你添加

938
00:35:03,530 --> 00:35:07,000
二和位二的补码二进制数

939
00:35:07,170 --> 00:35:09,930
简单的二进制算术就可以了

940
00:35:09,930 --> 00:35:11,970
顺便说一句，那真的很漂亮

941
00:35:12,170 --> 00:35:13,270
一点也不明显

942
00:35:13,270 --> 00:35:14,870
当我们开始这样做时

943
00:35:14,930 --> 00:35:16,670
看起来我们正在做这件奇怪的事情

944
00:35:16,670 --> 00:35:18,970
这种表示方式对我们来说很难阅读

945
00:35:19,100 --> 00:35:21,700
但事实证明这对计算机来说非常好

946
00:35:21,700 --> 00:35:23,470
因为它允许计算

947
00:35:23,530 --> 00:35:25,570
发生得非常好

948
00:35:25,730 --> 00:35:27,070
好的，这太棒了

949
00:35:27,130 --> 00:35:30,500
我们现在有正数和负数

950
00:35:30,500 --> 00:35:31,970
我们还需要一点

951
00:35:32,070 --> 00:35:33,370
然后我们将开始研究

952
00:35:33,370 --> 00:35:34,900
计算的本质

953
00:35:35,000 --> 00:35:36,530
在二进制数上

954
00:35:36,530 --> 00:35:37,930
好的，几分钟后见

955
00:35:41,900 --> 00:35:42,730
欢迎回来

956
00:35:42,730 --> 00:35:46,200
所以现在我们已经看到了如何表示

957
00:35:46,500 --> 00:35:47,170
积极的

958
00:35:47,170 --> 00:35:49,930
和二进制表示形式的负数

959
00:35:49,930 --> 00:35:52,070
当然还有二进制表示

960
00:35:52,170 --> 00:35:54,270
是现代计算机的语言

961
00:35:54,270 --> 00:35:55,800
我只想多做一点

962
00:35:56,500 --> 00:35:57,930
只是为了确保我们有一个真正坚定的

963
00:35:58,000 --> 00:35:58,900
对这种语言的理解

964
00:35:58,900 --> 00:36:01,330
然后我们就开始讨论计算

965
00:36:01,600 --> 00:36:02,870
让我也再次提醒你

966
00:36:02,870 --> 00:36:05,270
我们有不同类型的二进制数

967
00:36:05,270 --> 00:36:06,530
我们未签名

968
00:36:06,930 --> 00:36:10,770
二进制数，如果你有一个 n 位二进制数

969
00:36:10,930 --> 00:36:14,930
你可以表示从零到二到n减一

970
00:36:15,000 --> 00:36:17,870
定位年份 0 1 2 3 等

971
00:36:18,270 --> 00:36:20,170
如果您有签名代表

972
00:36:20,170 --> 00:36:22,770
你使用第一位来表示符号

973
00:36:22,930 --> 00:36:24,700
0 为正 1 为负

974
00:36:24,870 --> 00:36:26,800
但我们看到这会导致一些问题

975
00:36:26,800 --> 00:36:28,930
多个零和

976
00:36:29,470 --> 00:36:31,370
按位版本似乎不起作用

977
00:36:31,370 --> 00:36:34,330
所以事实上我们将使用二进制补码

978
00:36:35,000 --> 00:36:36,400
对于负数

979
00:36:36,500 --> 00:36:38,370
首先零仍然是正数

980
00:36:38,370 --> 00:36:39,530
一个在第一位

981
00:36:39,800 --> 00:36:40,870
仍为负值

982
00:36:41,000 --> 00:36:43,370
但数字有不同的含义

983
00:36:43,370 --> 00:36:45,400
我们在之前的文章中很好地看到了这一点

984
00:36:45,400 --> 00:36:48,400
讲座使我们能够做加法

985
00:36:48,730 --> 00:36:51,570
带有二进制补码的二进制数

986
00:36:51,600 --> 00:36:53,700
一切都很顺利

987
00:36:53,700 --> 00:36:53,900
所以

988
00:36:53,900 --> 00:36:56,300
只是为了确保我们都在同一页面上

989
00:36:56,370 --> 00:36:58,200
让我们做几个练习

990
00:36:58,470 --> 00:36:59,570
并再次记住

991
00:36:59,570 --> 00:37:02,170
每当我给你一个像这样的二进制数

992
00:37:02,170 --> 00:37:03,270
我必须

993
00:37:03,270 --> 00:37:07,270
我必须告诉你它是如何被代表的

994
00:37:07,800 --> 00:37:10,200
我不得不说，例如这是一个四位

995
00:37:10,470 --> 00:37:14,170
用二进制补码签名

996
00:37:14,300 --> 00:37:16,400
因为如果我只是说这是一个四位二进制数

997
00:37:16,400 --> 00:37:19,200
可能在标志 0 2 2 到 4-1 上

998
00:37:19,370 --> 00:37:22,270
如果这是这里的加号或减号

999
00:37:22,270 --> 00:37:23,870
那么这些数字意味着不同的东西

1000
00:37:23,870 --> 00:37:27,270
所以如果我问你我总是必须告诉你

1001
00:37:27,570 --> 00:37:30,470
0 1 1 1 的十进制是多少

1002
00:37:30,800 --> 00:37:31,930
这就是我问你的全部

1003
00:37:31,930 --> 00:37:32,570
你不得不说

1004
00:37:32,570 --> 00:37:34,570
你没有给我足够的信息

1005
00:37:34,870 --> 00:37:37,700
我需要信息才能解码此内容

1006
00:37:37,870 --> 00:37:40,900
好吧，如果我告诉你这是一个四位

1007
00:37:41,100 --> 00:37:44,400
使用二进制补码进行签名

1008
00:37:44,970 --> 00:37:46,800
这个数字的十进制是多少

1009
00:37:46,800 --> 00:37:48,570
好吧，让我们考虑一下

1010
00:37:48,800 --> 00:37:50,470
我们知道什么

1011
00:37:51,200 --> 00:37:54,000
与该标志对应的位置

1012
00:37:54,070 --> 00:37:55,770
如果为零，则为正数

1013
00:37:55,770 --> 00:37:57,300
如果是一个则为负数

1014
00:37:57,400 --> 00:37:58,400
如果是一个

1015
00:37:58,400 --> 00:37:59,570
这不仅是负面的

1016
00:37:59,570 --> 00:38:01,700
但它是在二进制补码表示中

1017
00:38:01,700 --> 00:38:03,130
我们必须撤消

1018
00:38:03,670 --> 00:38:04,900
但如果是积极的

1019
00:38:04,970 --> 00:38:07,570
我在家我真的知道这个号码是什么

1020
00:38:07,600 --> 00:38:10,800
它只是 0+1 的二比一乘以二

1021
00:38:10,800 --> 00:38:13,470
二乘以1+1 二乘以二

1022
00:38:13,530 --> 00:38:17,870
所以四加二加一就可以了

1023
00:38:17,900 --> 00:38:19,970
当然等于七

1024
00:38:20,530 --> 00:38:22,930
很好，如果结束位

1025
00:38:23,200 --> 00:38:25,700
对以零开头的二进制补码进行符号表示

1026
00:38:25,700 --> 00:38:26,800
这是一个正数

1027
00:38:26,900 --> 00:38:28,500
你只需破译

1028
00:38:28,570 --> 00:38:32,100
最高有效位之后的所有位

1029
00:38:32,470 --> 00:38:35,170
现在另一方面，如果它是 1 0 1 1

1030
00:38:35,370 --> 00:38:36,970
现在我们需要做一些工作

1031
00:38:36,970 --> 00:38:38,330
因为这还不够

1032
00:38:38,330 --> 00:38:40,470
只获取这个数字并尝试转换它

1033
00:38:40,470 --> 00:38:41,770
因为那不是

1034
00:38:41,930 --> 00:38:43,100
正数

1035
00:38:43,700 --> 00:38:46,200
好吧，所以这个告诉我这是负面的

1036
00:38:46,200 --> 00:38:47,800
这意味着我必须撤消

1037
00:38:48,330 --> 00:38:49,500
两人的恭维

1038
00:38:49,500 --> 00:38:51,200
好吧，我是怎么得到双重赞美的

1039
00:38:51,330 --> 00:38:54,100
我补翻转位加一

1040
00:38:54,300 --> 00:38:55,170
我该如何撤消

1041
00:38:55,170 --> 00:38:57,800
我减一，然后再补

1042
00:38:57,800 --> 00:38:59,700
那当然是因为补集

1043
00:38:59,800 --> 00:39:00,930
是它自己的逆

1044
00:39:00,930 --> 00:39:02,700
因为当我从零翻转到一时

1045
00:39:02,730 --> 00:39:05,330
我回去的方式就是从一翻转到零

1046
00:39:05,600 --> 00:39:06,500
好吧，我们就这么做吧

1047
00:39:06,500 --> 00:39:09,730
让我们从 1 0 1 1 中减一

1048
00:39:09,900 --> 00:39:11,970
好吧，如果我在这里放一个然后减去

1049
00:39:11,970 --> 00:39:13,370
该位置变为零

1050
00:39:13,370 --> 00:39:15,400
所以我得到 1 0 1 0

1051
00:39:15,570 --> 00:39:18,530
让我们翻转这些位，使 1 变为 0

1052
00:39:18,530 --> 00:39:20,000
零变成一

1053
00:39:20,070 --> 00:39:21,530
现在我有这个

1054
00:39:21,800 --> 00:39:23,770
太好了，那个位置有一个零

1055
00:39:23,770 --> 00:39:26,000
如果没有，你就做错了什么

1056
00:39:26,330 --> 00:39:28,530
因为当我撤销两个补码时

1057
00:39:28,530 --> 00:39:30,200
我最好得到一个正数

1058
00:39:30,200 --> 00:39:31,600
所以这不是零

1059
00:39:31,870 --> 00:39:34,100
有问题，回去检查一下你的算术

1060
00:39:34,730 --> 00:39:35,770
现在我有什么

1061
00:39:35,770 --> 00:39:37,100
我有一个正数

1062
00:39:37,100 --> 00:39:39,130
我可以像我刚才那样破译

1063
00:39:39,130 --> 00:39:40,000
早些时候做过

1064
00:39:40,370 --> 00:39:43,870
2 到 0 2 到 1 2 到 2

1065
00:39:44,100 --> 00:39:46,130
好吧，二的零就是一

1066
00:39:46,130 --> 00:39:49,100
二除一 二除二等于四

1067
00:39:49,100 --> 00:39:51,330
四加一等于五

1068
00:39:51,500 --> 00:39:52,800
所以这个数字

1069
00:39:53,530 --> 00:39:56,300
它编码为四位

1070
00:39:56,300 --> 00:39:58,970
二进制补码是

1071
00:39:59,330 --> 00:40:00,970
抱歉，这个数字是五

1072
00:40:00,970 --> 00:40:04,370
所以这个数字当然是-5

1073
00:40:05,870 --> 00:40:10,130
好吧，所以练习一下，确保你可以在两者之间进行切换

1074
00:40:11,530 --> 00:40:13,900
二进制数和十进制数

1075
00:40:14,400 --> 00:40:15,400
并确保您

1076
00:40:15,400 --> 00:40:16,600
理解这两个的补码

1077
00:40:16,600 --> 00:40:18,530
加法、减法和补码

1078
00:40:18,530 --> 00:40:19,330
作品

1079
00:40:19,800 --> 00:40:23,070
好的，现在我们有积极的

1080
00:40:23,330 --> 00:40:25,570
和负数好吧

1081
00:40:25,770 --> 00:40:27,670
我们有几种表示负面的方法

1082
00:40:27,670 --> 00:40:29,130
我们将坚持使用二进制补码

1083
00:40:29,130 --> 00:40:29,730
今后

1084
00:40:29,730 --> 00:40:31,870
这就是我们将使用的表示形式

1085
00:40:32,300 --> 00:40:34,870
显然如果我们要进行计算

1086
00:40:34,870 --> 00:40:38,000
算术版 减法 除法

1087
00:40:38,000 --> 00:40:40,930
我们还需要能够对小数进行编码

1088
00:40:40,930 --> 00:40:42,530
我实际上可以花费相当多的钱

1089
00:40:42,600 --> 00:40:43,770
有时间谈论这个

1090
00:40:43,770 --> 00:40:44,670
但我不会

1091
00:40:44,670 --> 00:40:47,770
所以我将简单地提到如何

1092
00:40:48,600 --> 00:40:51,930
小数用二进制表示

1093
00:40:52,600 --> 00:40:54,130
以及他们的代表方式

1094
00:40:54,200 --> 00:40:59,200
有 1 2 3 4 5 个部分

1095
00:40:59,500 --> 00:41:02,000
所以有一个mentissa

1096
00:41:02,170 --> 00:41:04,800
这是正数或负数，这是两部分

1097
00:41:04,970 --> 00:41:06,600
有基地

1098
00:41:06,670 --> 00:41:08,500
然后有一个指数

1099
00:41:08,500 --> 00:41:10,270
也有正负

1100
00:41:10,270 --> 00:41:12,200
所以指数有两部分

1101
00:41:12,200 --> 00:41:13,670
实际指数

1102
00:41:13,670 --> 00:41:15,300
然后是正数还是负数

1103
00:41:15,370 --> 00:41:16,570
和曼蒂萨

1104
00:41:16,670 --> 00:41:18,870
以及是否是正负然后是基数

1105
00:41:19,000 --> 00:41:20,730
例如，我的意思是什么

1106
00:41:20,730 --> 00:41:21,900
如果我想代表

1107
00:41:22,900 --> 00:41:25,530
o 我的尾数为一

1108
00:41:25,530 --> 00:41:29,330
低音会说 b 10 而指数会为零

1109
00:41:29,330 --> 00:41:31,570
如果我想做0.1

1110
00:41:31,670 --> 00:41:34,170
那么这个指数将是负一，所以在沙发上

1111
00:41:34,170 --> 00:41:36,970
所以这只是老式的科学记数法

1112
00:41:37,500 --> 00:41:38,070
并注意

1113
00:41:38,070 --> 00:41:40,570
为什么这很适合表示小数

1114
00:41:40,600 --> 00:41:42,400
因为这是一个整数

1115
00:41:42,530 --> 00:41:44,870
这是一个整数 那是一个整数

1116
00:41:44,900 --> 00:41:47,600
我知道如何处理整数和二进制数

1117
00:41:47,600 --> 00:41:49,570
事实上我知道如何签名

1118
00:41:49,730 --> 00:41:51,600
整数，就是这样

1119
00:41:51,670 --> 00:41:56,130
所以我所要做的就是代表一个有符号整数

1120
00:41:56,670 --> 00:41:59,500
另一个有符号整数是指数中的螳螂

1121
00:41:59,500 --> 00:42:00,800
然后无论基础是什么

1122
00:42:00,800 --> 00:42:02,200
一旦我明白了

1123
00:42:02,700 --> 00:42:04,170
我把它们全部打包在一起

1124
00:42:04,530 --> 00:42:06,530
我有小数

1125
00:42:06,530 --> 00:42:07,800
好的

1126
00:42:08,500 --> 00:42:12,070
所以现在我们已经有足够的语言了

1127
00:42:12,070 --> 00:42:13,670
我们还有更多话题可以谈

1128
00:42:13,670 --> 00:42:14,500
但我要停在这里

1129
00:42:14,500 --> 00:42:16,670
因为我想深入了解计算的本质

1130
00:42:17,000 --> 00:42:17,700
所以此时

1131
00:42:17,700 --> 00:42:19,570
我们拥有现代计算机的语言

1132
00:42:19,570 --> 00:42:20,930
这是二进制数

1133
00:42:21,070 --> 00:42:22,370
我们知道如何表现积极的一面

1134
00:42:22,370 --> 00:42:23,330
数字和负数

1135
00:42:23,330 --> 00:42:24,470
和小数

1136
00:42:24,470 --> 00:42:27,100
好吧，现在我们要开始问自己的是

1137
00:42:27,200 --> 00:42:29,730
我如何进行计算 如何构建计算器

1138
00:42:29,730 --> 00:42:31,370
例如我该怎么做

1139
00:42:31,700 --> 00:42:33,000
在 Excel 电子表格中

1140
00:42:33,000 --> 00:42:34,770
两个数相加 两个数相减

1141
00:42:34,770 --> 00:42:36,400
两个数相除做模

1142
00:42:37,200 --> 00:42:39,070
部门，这就是我们将要看到的

1143
00:42:39,070 --> 00:42:41,900
我们如何从这个二进制表示形式转到

1144
00:42:41,900 --> 00:42:43,330
实际计算

1145
00:42:43,570 --> 00:42:44,570
以及真正会发生什么

1146
00:42:44,570 --> 00:42:47,470
神奇的是它是如此的简单

1147
00:42:47,570 --> 00:42:48,500
真的只会有

1148
00:42:48,500 --> 00:42:50,200
我们必须学习的三件事

1149
00:42:50,300 --> 00:42:51,270
只有三件事

1150
00:42:51,270 --> 00:42:52,770
我们将能够建造

1151
00:42:53,000 --> 00:42:55,770
现代计算机的基础知识

1152
00:42:55,800 --> 00:42:58,570
好的，我们会在几分钟内取走，很快再见

1153
00:43:01,730 --> 00:43:03,570
现在我们准备开始讨论

1154
00:43:03,570 --> 00:43:05,170
计算的本质

1155
00:43:05,200 --> 00:43:08,330
使用二进制数作为表示

1156
00:43:09,370 --> 00:43:10,930
那么让我开始吧

1157
00:43:10,930 --> 00:43:12,330
有一个非常简单的想法

1158
00:43:12,330 --> 00:43:14,700
我会让你考虑一下

1159
00:43:14,870 --> 00:43:17,470
二进制 1 为 true

1160
00:43:17,770 --> 00:43:20,470
二进制 No.0 为 false

1161
00:43:20,470 --> 00:43:21,570
以及我要这样做的原因

1162
00:43:21,570 --> 00:43:23,000
我要介绍的是

1163
00:43:23,270 --> 00:43:24,200
蓝色和逻辑

1164
00:43:24,200 --> 00:43:26,600
他们都熟悉非常简单的概念

1165
00:43:26,770 --> 00:43:27,400
但要做到这一点

1166
00:43:27,400 --> 00:43:29,670
它让思考变得更容易

1167
00:43:29,730 --> 00:43:32,370
我们将根据真假进行手术 好吧

1168
00:43:32,370 --> 00:43:34,100
其中一为二，零为假

1169
00:43:34,100 --> 00:43:36,300
好吧，只是在你的脑海中进行简单的翻译

1170
00:43:36,600 --> 00:43:39,100
好吧，让我提醒你一下

1171
00:43:39,300 --> 00:43:41,400
布尔运算符是

1172
00:43:41,400 --> 00:43:42,700
他们有三个

1173
00:43:42,870 --> 00:43:47,130
逻辑和逻辑或和逻辑非

1174
00:43:47,500 --> 00:43:47,900
好的

1175
00:43:47,900 --> 00:43:52,570
这些有这些词的纯文本阅读

1176
00:43:52,700 --> 00:43:54,200
所以如果我告诉你

1177
00:43:54,330 --> 00:43:58,300
外面阳光明媚，外面很温暖

1178
00:43:58,370 --> 00:43:59,870
这意味着两者都是真的

1179
00:44:00,370 --> 00:44:02,800
如果我告诉你外面阳光明媚

1180
00:44:02,800 --> 00:44:04,570
或者外面很暖和

1181
00:44:04,730 --> 00:44:06,600
一个或两个都为真

1182
00:44:06,730 --> 00:44:09,070
如果我告诉你外面没有阳光

1183
00:44:09,070 --> 00:44:10,500
那么外面没有阳光明媚

1184
00:44:10,500 --> 00:44:13,670
所以它有那种逻辑纯文本阅读的圣人

1185
00:44:13,670 --> 00:44:15,570
但让我继续正式定义它

1186
00:44:15,700 --> 00:44:17,770
所谓的真值表

1187
00:44:18,070 --> 00:44:22,000
所以我的真值表有四行三列

1188
00:44:22,070 --> 00:44:23,570
前两列

1189
00:44:23,570 --> 00:44:26,400
表示我的两个输入的值

1190
00:44:26,400 --> 00:44:28,770
a 和 b 所以当我计算逻辑土地时

1191
00:44:29,070 --> 00:44:33,530
我要求两件事的结束 阳光明媚 温暖

1192
00:44:33,570 --> 00:44:37,300
然后我向你输出它们的逻辑结束

1193
00:44:38,200 --> 00:44:41,130
这里有四种可能性，分别对应

1194
00:44:41,130 --> 00:44:42,730
所有可能的输入

1195
00:44:42,730 --> 00:44:43,870
为什么好

1196
00:44:43,870 --> 00:44:44,730
有两个输入

1197
00:44:44,730 --> 00:44:46,330
他们每个都可以有两个值

1198
00:44:46,330 --> 00:44:48,070
所以有四种排列

1199
00:44:48,170 --> 00:44:50,970
0 0 0 1 1 0 1 1

1200
00:44:50,970 --> 00:44:53,000
我在这里输入的顺序并不重要

1201
00:44:53,070 --> 00:44:55,670
好的，逻辑是什么？

1202
00:44:56,400 --> 00:44:58,530
两个正确的陈述

1203
00:44:58,530 --> 00:45:00,400
所以如果 a 为真且 b 为真

1204
00:45:00,400 --> 00:45:01,670
再次记住我是

1205
00:45:01,770 --> 00:45:04,730
替换这些是正确的

1206
00:45:04,870 --> 00:45:06,000
和假词零

1207
00:45:06,000 --> 00:45:08,870
如果 a 为真且 b 为真

1208
00:45:09,070 --> 00:45:11,700
那么 and 是真的好

1209
00:45:12,130 --> 00:45:15,400
在所有其他情况下，逻辑地都是假的

1210
00:45:15,500 --> 00:45:17,470
所以如果这是真的，这是假的

1211
00:45:17,470 --> 00:45:18,800
那么它们都不是真的

1212
00:45:19,070 --> 00:45:21,730
如果这是假的，这是真的，那么它们都不是真的

1213
00:45:21,730 --> 00:45:22,730
如果它们都是假的

1214
00:45:22,730 --> 00:45:25,270
你最好相信结局也是假的

1215
00:45:25,400 --> 00:45:29,170
所以对于逻辑与运算符来说，唯一的一次

1216
00:45:29,270 --> 00:45:32,970
两件事的结局都是真的

1217
00:45:33,070 --> 00:45:34,470
当它们都为真时

1218
00:45:34,800 --> 00:45:36,470
好的好的简单的计算

1219
00:45:36,470 --> 00:45:38,100
顺便说一句，这是一个计算

1220
00:45:38,200 --> 00:45:39,600
它有一个输入，也有一个输出

1221
00:45:39,600 --> 00:45:42,070
这是一个非常简单的计算，但它是一个计算

1222
00:45:43,330 --> 00:45:45,670
好吧，让我们做逻辑或相同的真值表

1223
00:45:46,130 --> 00:45:47,970
这一面保持完全相同

1224
00:45:48,100 --> 00:45:51,000
两列用于输入 一列用于输出

1225
00:45:51,000 --> 00:45:51,770
有四个

1226
00:45:51,770 --> 00:45:56,270
对应于完全相同的事物的行 0 0 1 0 1 1

1227
00:45:56,570 --> 00:45:58,700
现在记住 or 为 true if

1228
00:45:58,700 --> 00:46:01,970
一项或多项陈述是正确的

1229
00:46:02,100 --> 00:46:04,670
所以这里它们都是真的所以 or 是真的

1230
00:46:04,900 --> 00:46:06,700
a 为真，所以 or 为真

1231
00:46:06,700 --> 00:46:08,500
b 为真，所以 or 为真

1232
00:46:08,500 --> 00:46:10,530
当然这两者都不是真的

1233
00:46:10,570 --> 00:46:13,730
所以他们的 or 是假的

1234
00:46:13,930 --> 00:46:15,500
好吧，这是一个逻辑或

1235
00:46:16,000 --> 00:46:18,670
现在逻辑不再只有一个输入

1236
00:46:18,670 --> 00:46:21,500
所以不是你不做的事不是两件事

1237
00:46:21,500 --> 00:46:25,770
所以现在我只有两列我的输入和我的输出

1238
00:46:25,800 --> 00:46:27,570
我只有两行

1239
00:46:27,570 --> 00:46:29,730
a 可以取哪些值

1240
00:46:29,730 --> 00:46:31,000
是零还是一

1241
00:46:31,330 --> 00:46:32,330
对或错

1242
00:46:32,330 --> 00:46:34,670
点头是有点像补充

1243
00:46:34,700 --> 00:46:39,200
所以，非真即假，非假即真

1244
00:46:39,970 --> 00:46:43,600
这就是三个逻辑运算符

1245
00:46:44,270 --> 00:46:45,730
现在好吧

1246
00:46:45,730 --> 00:46:47,800
我已经说过了，但让我再次强调一下

1247
00:46:47,800 --> 00:46:50,500
你可以将其视为计算

1248
00:46:50,800 --> 00:46:52,970
我有一个输入 a 和 b

1249
00:46:53,130 --> 00:46:54,900
我做了一个计算

1250
00:46:54,900 --> 00:46:56,970
在这种情况下是在真值表中查找

1251
00:46:57,070 --> 00:46:58,500
我有一个输出

1252
00:46:58,600 --> 00:47:01,500
并注意输入是一个布尔变量

1253
00:47:01,500 --> 00:47:03,000
0 1 真 假

1254
00:47:03,300 --> 00:47:06,370
输出也是一个布尔变量 true false

1255
00:47:06,700 --> 00:47:09,700
所以一切都在布尔结构中

1256
00:47:09,730 --> 00:47:10,930
我当然关心这个

1257
00:47:10,930 --> 00:47:12,330
因为我们要建造一台计算机

1258
00:47:12,330 --> 00:47:15,800
只能表示零或一

1259
00:47:16,570 --> 00:47:17,100
好的

1260
00:47:17,100 --> 00:47:21,100
所以现在这就是逻辑和逻辑的美妙之处

1261
00:47:21,300 --> 00:47:23,570
逻辑或逻辑非

1262
00:47:24,000 --> 00:47:26,700
计算这三件事的能力

1263
00:47:26,870 --> 00:47:30,500
在两个二进制输入上或在一个点头上

1264
00:47:30,600 --> 00:47:33,900
是现代计算机的构建模块

1265
00:47:33,900 --> 00:47:35,400
他们已经完全建成

1266
00:47:35,530 --> 00:47:38,530
我能够做到这三个非常简单的事情

1267
00:47:38,700 --> 00:47:41,000
和令人惊讶的简单计算

1268
00:47:41,570 --> 00:47:43,330
所以我要做的就是我要采取

1269
00:47:43,530 --> 00:47:46,400
这个真值表，我只是想把它抽象出来

1270
00:47:46,500 --> 00:47:49,930
渲染它或绘制它或只是描绘它

1271
00:47:50,070 --> 00:47:51,570
因为这件事就在这里

1272
00:47:51,570 --> 00:47:52,930
所以这就是所谓的门

1273
00:47:52,930 --> 00:47:54,100
我们要讨论这个

1274
00:47:54,100 --> 00:47:55,370
更详细一点

1275
00:47:55,570 --> 00:47:56,330
它只是

1276
00:47:56,330 --> 00:47:59,130
将其视为一种图形表示

1277
00:47:59,170 --> 00:48:00,970
这个计算的

1278
00:48:01,500 --> 00:48:03,600
两个输入来自 a 和 b

1279
00:48:03,770 --> 00:48:05,530
这是我的前两栏

1280
00:48:05,570 --> 00:48:07,770
发生一些计算

1281
00:48:07,770 --> 00:48:10,200
确定它们是否都为真

1282
00:48:10,200 --> 00:48:11,600
我们稍后会讨论这个

1283
00:48:11,600 --> 00:48:13,400
我们将如何为您打造这个

1284
00:48:13,600 --> 00:48:15,770
然后输出

1285
00:48:16,100 --> 00:48:18,470
所以这里有零或一

1286
00:48:18,600 --> 00:48:19,600
这里有两列

1287
00:48:19,730 --> 00:48:21,200
零或一出现在这里

1288
00:48:21,200 --> 00:48:23,600
这个和这里的内部是一个计算

1289
00:48:23,600 --> 00:48:26,070
我们不知道它是如何工作的，但它已经被抽象出来了

1290
00:48:26,130 --> 00:48:28,170
但我们稍后会向您展示

1291
00:48:28,530 --> 00:48:31,770
所以这称为逻辑与门

1292
00:48:31,770 --> 00:48:33,400
画成这个大d

1293
00:48:33,530 --> 00:48:35,200
我们经常在那里画一个小点

1294
00:48:35,200 --> 00:48:37,000
因为有时我们的画会变得马虎

1295
00:48:37,000 --> 00:48:39,870
这帮助我们知道这是一个与门

1296
00:48:41,000 --> 00:48:44,530
现在又是一个 orgate，只需实现 or 表

1297
00:48:44,530 --> 00:48:46,870
这里的真值表有同样的事情

1298
00:48:46,870 --> 00:48:49,330
对应于两列的两个输入

1299
00:48:49,500 --> 00:48:52,200
一个输出对应逻辑矿石

1300
00:48:52,270 --> 00:48:55,270
这次画成这样的卷曲

1301
00:48:56,070 --> 00:48:58,970
d 在这里，里面有一个加号

1302
00:48:58,970 --> 00:49:00,970
这是矿石的一种表示方式

1303
00:49:01,870 --> 00:49:04,270
计算 这里有一个计算

1304
00:49:04,270 --> 00:49:06,070
我们还不知道计算是什么

1305
00:49:06,070 --> 00:49:08,330
几分钟后我们会再次看到

1306
00:49:08,330 --> 00:49:10,400
但是有两个二进制数进来

1307
00:49:10,570 --> 00:49:12,130
一个二进制文件出来了

1308
00:49:12,170 --> 00:49:13,300
这是一个计算

1309
00:49:13,300 --> 00:49:16,070
它告诉我这些变量中是否有一个或多个

1310
00:49:16,070 --> 00:49:17,530
是真是假

1311
00:49:18,170 --> 00:49:21,400
最后逻辑结被表示为门

1312
00:49:21,400 --> 00:49:22,730
只有一个输入

1313
00:49:22,770 --> 00:49:25,470
一列一输出一列

1314
00:49:25,470 --> 00:49:28,930
现在它是一个三角形，末端有一个小圆圈

1315
00:49:28,970 --> 00:49:32,000
所以 0 1 进来 01 出来

1316
00:49:32,000 --> 00:49:34,200
那里正在进行一个计算，上面写着

1317
00:49:34,200 --> 00:49:36,000
如何从 1 翻转到 0

1318
00:49:36,300 --> 00:49:37,100
到一个

1319
00:49:37,870 --> 00:49:40,670
好吧，现在如果可以的话

1320
00:49:40,670 --> 00:49:41,930
建造这些东西

1321
00:49:41,930 --> 00:49:44,870
这种逻辑和逻辑或逻辑点头

1322
00:49:44,870 --> 00:49:46,800
从实际的物理事物

1323
00:49:47,070 --> 00:49:50,700
我有计算的构建模块，或者没有

1324
00:49:51,130 --> 00:49:53,070
然后我必须向你展示我实际上可以

1325
00:49:53,070 --> 00:49:54,600
建造一台现代计算机

1326
00:49:54,730 --> 00:49:56,770
只需这三个操作

1327
00:49:56,770 --> 00:49:59,300
这就是现代计算机的魔力

1328
00:49:59,470 --> 00:50:01,000
你不再需要任何东西了吗

1329
00:50:01,000 --> 00:50:02,300
用于基本计算

1330
00:50:02,300 --> 00:50:04,270
显然你的鼠标中有显示器

1331
00:50:04,270 --> 00:50:06,570
以及键盘和所有其他不错的外围设备

1332
00:50:06,570 --> 00:50:08,930
但就核心计算而言

1333
00:50:09,270 --> 00:50:10,800
我们将向您展示如何构建

1334
00:50:10,800 --> 00:50:12,200
现代计算

1335
00:50:12,300 --> 00:50:16,270
由三个简单的逻辑运算符

1336
00:50:16,300 --> 00:50:18,370
好的，所以我要去那里取货

1337
00:50:18,370 --> 00:50:19,700
我将向你展示我们将如何做

1338
00:50:19,700 --> 00:50:20,730
构建逻辑土地

1339
00:50:20,730 --> 00:50:23,370
晶体管的逻辑或逻辑结

1340
00:50:23,370 --> 00:50:24,270
然后我们要开始

1341
00:50:24,270 --> 00:50:26,100
谈论计算的本质

1342
00:50:26,100 --> 00:50:27,130
以及你实际上如何

1343
00:50:27,330 --> 00:50:29,170
把所有这些门拉到一起

1344
00:50:29,300 --> 00:50:30,900
为了进行真正的计算

1345
00:50:30,900 --> 00:50:32,470
所以我们会在几分钟内取走它

1346
00:50:36,700 --> 00:50:37,530
在最后一堂课中

1347
00:50:37,530 --> 00:50:40,000
我向你保证我们能够做到

1348
00:50:40,530 --> 00:50:43,970
仅使用逻辑域进行计算

1349
00:50:43,970 --> 00:50:46,100
逻辑知识 逻辑非

1350
00:50:46,400 --> 00:50:48,000
现在我必须先做什么

1351
00:50:48,070 --> 00:50:51,500
向你展示我如何实际建造这些门

1352
00:50:51,500 --> 00:50:52,200
计算

1353
00:50:52,200 --> 00:50:55,730
和/或本质上不实现这些真值表

1354
00:50:55,900 --> 00:50:58,570
两个输入 一个输出用于 anden 或一个输入

1355
00:50:58,570 --> 00:51:00,470
逻辑结的一个输出

1356
00:51:00,730 --> 00:51:03,000
我将建造这些然后

1357
00:51:03,270 --> 00:51:04,170
在下一个讲座中

1358
00:51:04,170 --> 00:51:06,670
我们实际上将使用这些门

1359
00:51:06,670 --> 00:51:08,000
进行计算

1360
00:51:08,200 --> 00:51:08,670
好的

1361
00:51:08,670 --> 00:51:11,930
所以让我们从建造几个门开始，或者不建造

1362
00:51:12,330 --> 00:51:14,870
我认为现代建筑的基石

1363
00:51:15,600 --> 00:51:17,530
计算机是晶体管

1364
00:51:17,530 --> 00:51:19,670
你几乎肯定听说过这个词

1365
00:51:19,870 --> 00:51:21,470
我将向您展示一个版本

1366
00:51:21,470 --> 00:51:22,870
晶体管有很多版本

1367
00:51:22,870 --> 00:51:23,670
我要给你看一个

1368
00:51:23,670 --> 00:51:25,370
这是特别简化的

1369
00:51:25,670 --> 00:51:26,400
有点过时

1370
00:51:26,400 --> 00:51:28,600
这不是现代晶体管的样子

1371
00:51:28,670 --> 00:51:30,770
但我喜欢这个，因为我认为它特别简单

1372
00:51:30,770 --> 00:51:32,900
解释一下，这是晶体管

1373
00:51:32,900 --> 00:51:35,300
它的结构非常简单

1374
00:51:35,470 --> 00:51:37,300
有力量降临

1375
00:51:37,470 --> 00:51:40,730
晶体管可以控制这里的这个小门

1376
00:51:40,800 --> 00:51:42,170
所以当门打开时

1377
00:51:42,300 --> 00:51:45,130
什么都没有发生，然后当门关闭时

1378
00:51:45,200 --> 00:51:46,600
一切都会经历

1379
00:51:47,000 --> 00:51:49,500
那么我的意思是什么 所以这是两种状态

1380
00:51:49,500 --> 00:51:51,870
顺便说一句，你可以将它们视为零和一

1381
00:51:51,870 --> 00:51:54,500
显然如果你愿意的话你可以考虑一下

1382
00:51:54,500 --> 00:51:56,770
水是从软管流下来的吗

1383
00:51:56,800 --> 00:52:00,270
这里软管被挤压所以没有东西掉下来

1384
00:52:00,270 --> 00:52:01,770
如果我在这里读一下

1385
00:52:01,770 --> 00:52:03,100
我会说没有水

1386
00:52:03,130 --> 00:52:04,530
出来这里

1387
00:52:04,530 --> 00:52:06,100
我已解开水

1388
00:52:06,130 --> 00:52:08,200
所以它直接下来，我有水

1389
00:52:08,200 --> 00:52:09,200
我有力量

1390
00:52:09,270 --> 00:52:10,970
我这里有信号

1391
00:52:10,970 --> 00:52:11,600
很明显

1392
00:52:11,600 --> 00:52:13,670
这不会是水，而是电

1393
00:52:13,700 --> 00:52:15,500
我可以阻止电流流动

1394
00:52:15,500 --> 00:52:16,800
在这种情况下我有零

1395
00:52:17,400 --> 00:52:18,200
就在那里

1396
00:52:18,330 --> 00:52:20,900
我可以让电力通过，我有一个

1397
00:52:20,900 --> 00:52:22,970
这是我的二进制表示

1398
00:52:23,500 --> 00:52:26,930
这些晶体管代表两种状态之一

1399
00:52:26,930 --> 00:52:28,870
零或一

1400
00:52:29,300 --> 00:52:30,730
现在我要给你看的是

1401
00:52:30,730 --> 00:52:32,800
是我如何组合这些晶体管

1402
00:52:32,800 --> 00:52:35,300
这是物理实现

1403
00:52:35,400 --> 00:52:37,770
计算机语言的

1404
00:52:37,770 --> 00:52:40,900
零或一以便计算 and or or not

1405
00:52:41,070 --> 00:52:42,070
然后我要给你看

1406
00:52:42,070 --> 00:52:43,770
我该如何从 and or or not

1407
00:52:43,870 --> 00:52:44,100
到

1408
00:52:44,100 --> 00:52:46,900
实际计算，例如加法和乘法

1409
00:52:47,170 --> 00:52:50,370
好吧，让我们从逻辑开始

1410
00:52:50,670 --> 00:52:53,500
那么我们对逻辑和二进一出了解多少

1411
00:52:53,530 --> 00:52:55,800
两个输入 a 和 b

1412
00:52:55,970 --> 00:52:57,670
可以是零或一

1413
00:52:57,670 --> 00:53:00,770
现在我们知道这种转变可以代表一个

1414
00:53:00,970 --> 00:53:04,270
a 并且该晶体管可以代表 b

1415
00:53:04,570 --> 00:53:09,330
所以这是我打开这些门的表现

1416
00:53:09,330 --> 00:53:12,200
所以我这里有一个零 我这里也有一个零

1417
00:53:12,370 --> 00:53:13,730
我在这里有权力

1418
00:53:13,730 --> 00:53:16,930
所以我做了什么我把这些晶体管串联起来

1419
00:53:17,400 --> 00:53:19,500
所以我的力量下降了

1420
00:53:19,900 --> 00:53:21,770
晶体管之一是

1421
00:53:21,770 --> 00:53:24,370
这就是输入 a 和输出

1422
00:53:24,670 --> 00:53:27,000
进入下一个晶体管

1423
00:53:27,270 --> 00:53:28,770
那么为什么这样可以呢

1424
00:53:28,930 --> 00:53:31,300
好吧，因为这是 0 1

1425
00:53:31,300 --> 00:53:35,200
这是什么 0 1 所以一切都很好，都是输入

1426
00:53:35,270 --> 00:53:37,070
一个的输出可以是另一个的输入

1427
00:53:37,070 --> 00:53:38,700
只是电量下降了

1428
00:53:39,000 --> 00:53:40,130
可以，然后呢

1429
00:53:40,130 --> 00:53:41,000
让我们想想

1430
00:53:41,000 --> 00:53:44,070
这两个晶体管可以处于的各种状态

1431
00:53:44,070 --> 00:53:45,870
所以这是状态零零

1432
00:53:46,300 --> 00:53:48,800
所以如果权力来到这里并且这是零

1433
00:53:48,800 --> 00:53:50,130
这是一个零

1434
00:53:50,170 --> 00:53:51,670
那么下面的读数是多少

1435
00:53:51,670 --> 00:53:53,600
在我的小仪表里

1436
00:53:53,900 --> 00:53:54,770
当然是零

1437
00:53:54,770 --> 00:53:57,300
没有发生任何事情，事实上它被阻止了两次

1438
00:53:58,330 --> 00:53:59,130
让我们

1439
00:53:59,770 --> 00:54:01,670
将这些位之一设置为 1

1440
00:54:01,670 --> 00:54:02,970
所以电力下降了

1441
00:54:03,000 --> 00:54:06,300
这个晶体管零的读数是多少

1442
00:54:06,400 --> 00:54:08,100
所以如果零进入这里

1443
00:54:08,100 --> 00:54:09,500
它被允许流过

1444
00:54:09,670 --> 00:54:11,400
但那里什么也没有

1445
00:54:11,500 --> 00:54:14,270
所以这里的读数当然必须为零

1446
00:54:14,400 --> 00:54:16,000
所以输入零

1447
00:54:16,000 --> 00:54:18,170
输入一输出零

1448
00:54:19,000 --> 00:54:20,300
好吧，让我们翻转那些

1449
00:54:20,570 --> 00:54:20,930
比方说

1450
00:54:20,930 --> 00:54:23,100
我们让电源通过第一个晶体管

1451
00:54:23,100 --> 00:54:24,130
但不是第二个

1452
00:54:24,130 --> 00:54:25,370
这里读什么

1453
00:54:25,470 --> 00:54:28,600
所以我们这里有电，但随后就停了

1454
00:54:28,600 --> 00:54:31,300
所以读数又为零

1455
00:54:31,670 --> 00:54:33,800
所以再一个对一一

1456
00:54:34,000 --> 00:54:36,000
所以现在我已经清楚地了解了

1457
00:54:36,000 --> 00:54:36,770
电力下降

1458
00:54:36,770 --> 00:54:37,970
通过第一个晶体管

1459
00:54:37,970 --> 00:54:39,400
通过第二个晶体管

1460
00:54:39,530 --> 00:54:41,330
现在我读了一本

1461
00:54:41,370 --> 00:54:42,970
所以输出是一

1462
00:54:43,500 --> 00:54:45,370
好吧，让我们想想

1463
00:54:45,370 --> 00:54:46,130
让我们看看全部

1464
00:54:46,130 --> 00:54:48,330
将四个放在一起，看看会是什么样子

1465
00:54:48,700 --> 00:54:53,000
因此，通过两个输入零零，我得到的输出为 0 0 1

1466
00:54:53,000 --> 00:54:57,070
我得到的输出为 0 1 0 我得到的输出为 0 1 1

1467
00:54:57,070 --> 00:54:58,900
我得到的输出为一

1468
00:54:59,100 --> 00:55:01,530
这是什么，这是一颗玛瑙

1469
00:55:01,530 --> 00:55:03,200
它是一个 and 运算符

1470
00:55:03,530 --> 00:55:05,000
所以想想这些

1471
00:55:06,100 --> 00:55:09,270
这里从左到右作为真值表的列

1472
00:55:09,270 --> 00:55:13,270
四行 0 0 0 1 1 0 1 1

1473
00:55:13,400 --> 00:55:14,730
想想这个

1474
00:55:14,870 --> 00:55:17,570
作为最后一列，这是计算

1475
00:55:18,000 --> 00:55:20,700
所以我建造了一个安玛特

1476
00:55:20,700 --> 00:55:23,970
我已经构建了可以设置两个输入的东西

1477
00:55:24,000 --> 00:55:27,070
这是我的输入，我可以决定这些值是什么

1478
00:55:27,200 --> 00:55:30,930
并通过简单地将这些晶体管串联起来

1479
00:55:31,070 --> 00:55:33,730
我计算了一个逻辑和

1480
00:55:34,170 --> 00:55:37,300
太好了，我现在可以计算逻辑地了

1481
00:55:37,300 --> 00:55:39,570
现在我只需要能够做或不做

1482
00:55:39,730 --> 00:55:40,970
所以让我们做或者

1483
00:55:41,930 --> 00:55:44,170
好吧，只是提醒你，那是一个末日之门

1484
00:55:44,700 --> 00:55:45,730
所以让我们做一个 Orgate

1485
00:55:45,730 --> 00:55:47,530
现在我知道我需要两个晶体管

1486
00:55:47,530 --> 00:55:49,130
因为我有两个正确的输入

1487
00:55:49,130 --> 00:55:50,100
这是我的输入

1488
00:55:50,100 --> 00:55:52,370
我现在只是将它们设置为零和一

1489
00:55:53,500 --> 00:55:55,170
让我们考虑一下 o'er 的本质

1490
00:55:55,170 --> 00:55:56,600
现在我们已经考虑过了

1491
00:55:56,600 --> 00:55:57,900
当你把它们放进去时会发生什么

1492
00:55:57,900 --> 00:55:59,500
两个串联的晶体管

1493
00:55:59,700 --> 00:56:01,200
所以这是一个 and 的原因

1494
00:56:01,200 --> 00:56:02,600
git 是获得权力的唯一途径

1495
00:56:02,600 --> 00:56:03,930
从最顶部到最底部

1496
00:56:03,930 --> 00:56:05,170
两者都是一个

1497
00:56:05,470 --> 00:56:07,970
是的，只有一次 and 为真

1498
00:56:08,470 --> 00:56:11,070
但在矿石中我想要一些东西出来

1499
00:56:11,070 --> 00:56:12,470
如果一是一

1500
00:56:12,500 --> 00:56:14,930
如果另一个是一个或者他们都是一个

1501
00:56:15,400 --> 00:56:15,900
所以我不想

1502
00:56:15,900 --> 00:56:17,400
我不能把它们串联起来，因为

1503
00:56:17,470 --> 00:56:19,200
一个人拥有 vito 权力

1504
00:56:19,500 --> 00:56:21,400
但我不希望任何人拥有vito权力

1505
00:56:21,730 --> 00:56:24,100
如果不是把它们放进去又怎么样

1506
00:56:24,100 --> 00:56:25,600
系列从上到下

1507
00:56:25,870 --> 00:56:28,770
我把它们并联起来，就像这样会发生什么

1508
00:56:28,900 --> 00:56:30,770
所以让我们考虑一下功率下降的情况

1509
00:56:30,770 --> 00:56:32,970
我沿着顶部分配力量

1510
00:56:33,370 --> 00:56:37,130
我把它们放入两个晶体管中

1511
00:56:37,400 --> 00:56:40,730
所以这个阻止了流动，但这个允许它

1512
00:56:40,900 --> 00:56:43,130
和结果，这就是我的

1513
00:56:43,330 --> 00:56:45,170
只要其中一个打开

1514
00:56:45,330 --> 00:56:46,870
我要在这里买一个

1515
00:56:46,930 --> 00:56:47,500
现在我注意到了

1516
00:56:47,500 --> 00:56:48,770
顺便说一句，如果我切换这些

1517
00:56:48,770 --> 00:56:50,400
如果这是一个 1 那个是 0

1518
00:56:50,400 --> 00:56:51,470
我这里还有一个

1519
00:56:51,470 --> 00:56:53,070
这些的顺序并不重要

1520
00:56:53,770 --> 00:56:55,370
好吧，如果他们都是一个会发生什么

1521
00:56:55,370 --> 00:56:56,200
完全没问题

1522
00:56:56,200 --> 00:56:58,170
我的另一端仍然有电源

1523
00:56:58,270 --> 00:57:01,100
很好，如果它们都为零会发生什么

1524
00:57:01,100 --> 00:57:03,700
停电 停在这里 停在这里

1525
00:57:03,700 --> 00:57:05,170
所以我这里有一个零

1526
00:57:05,170 --> 00:57:06,330
我刚刚做了什么

1527
00:57:06,500 --> 00:57:07,700
我建了一个器官门

1528
00:57:07,970 --> 00:57:11,270
如果这是 1 0 或 0 1

1529
00:57:11,270 --> 00:57:14,070
电力通过，因为它们是并行的

1530
00:57:14,370 --> 00:57:15,870
如果他们都是一个

1531
00:57:15,900 --> 00:57:17,870
力量来了，我有一个

1532
00:57:17,900 --> 00:57:20,470
当且仅当

1533
00:57:20,770 --> 00:57:22,370
这两个值都为零

1534
00:57:22,600 --> 00:57:24,870
然后没有电源通过，我得到零

1535
00:57:24,970 --> 00:57:26,800
这就是 orgate 的定义

1536
00:57:27,000 --> 00:57:28,970
当然是2进1出

1537
00:57:28,970 --> 00:57:30,200
顺便说一句，力量只是

1538
00:57:30,200 --> 00:57:31,170
提供给您的

1539
00:57:31,170 --> 00:57:32,730
由于您的电池或电源插头

1540
00:57:32,730 --> 00:57:34,200
所以你不必担心电源在哪里

1541
00:57:34,200 --> 00:57:35,000
来自

1542
00:57:36,400 --> 00:57:38,000
好吧，我们在一个奥门中结束了

1543
00:57:38,130 --> 00:57:41,570
它们都是通过放置两个晶体管来构建的

1544
00:57:41,570 --> 00:57:43,700
它仅代表两个状态之一

1545
00:57:43,700 --> 00:57:46,470
安门的并行二进制

1546
00:57:46,500 --> 00:57:48,130
抱歉系列中的安门

1547
00:57:48,130 --> 00:57:50,130
并并行地为一个 orgate

1548
00:57:50,300 --> 00:57:51,870
现在我们必须建造一扇敲门

1549
00:57:52,070 --> 00:57:55,000
好吧，结门只有一个输入和一个输出

1550
00:57:55,070 --> 00:57:57,000
所以让我在这里引导你

1551
00:57:57,000 --> 00:57:59,400
这是一个有点不同的图片

1552
00:57:59,870 --> 00:58:01,270
电力下降

1553
00:58:01,370 --> 00:58:02,900
这是这里的输出

1554
00:58:02,900 --> 00:58:04,800
我稍后会向您描述这个电阻器

1555
00:58:04,800 --> 00:58:06,130
所以电力下降了

1556
00:58:06,300 --> 00:58:08,500
这就是我们的输出的地方

1557
00:58:08,500 --> 00:58:09,700
现在它是垃圾

1558
00:58:09,700 --> 00:58:11,270
我们会忽略它

1559
00:58:11,370 --> 00:58:13,200
所以我要在这里连接输入

1560
00:58:13,200 --> 00:58:15,200
我可以控制那个晶体管门

1561
00:58:15,530 --> 00:58:17,600
这将是我的输出

1562
00:58:17,970 --> 00:58:19,700
当然这仍然是力量

1563
00:58:19,700 --> 00:58:21,100
这是一个电阻

1564
00:58:21,100 --> 00:58:22,600
那么电阻有什么作用

1565
00:58:22,930 --> 00:58:24,470
电阻说看

1566
00:58:24,730 --> 00:58:26,200
力量可以通过这里

1567
00:58:26,200 --> 00:58:27,730
但我不喜欢经过那里

1568
00:58:27,730 --> 00:58:29,700
我宁愿不去那里

1569
00:58:30,000 --> 00:58:32,370
所以如果没有其他路线可走

1570
00:58:32,900 --> 00:58:34,700
你可以这样出来

1571
00:58:34,930 --> 00:58:35,730
所以将会发生的是

1572
00:58:35,730 --> 00:58:36,730
电力将会下降到这里

1573
00:58:36,730 --> 00:58:37,870
它想去这里

1574
00:58:37,870 --> 00:58:39,570
但这是完全关闭的

1575
00:58:39,970 --> 00:58:42,600
所以功率实际上会通过电阻

1576
00:58:42,600 --> 00:58:43,400
但

1577
00:58:43,930 --> 00:58:48,130
如果这允许电源通过这种方式

1578
00:58:48,330 --> 00:58:50,270
无缝无摩擦

1579
00:58:50,270 --> 00:58:51,900
所以功率会直线下降

1580
00:58:51,930 --> 00:58:53,900
并且它不会通过电阻出去

1581
00:58:53,900 --> 00:58:55,130
然后这是一个零

1582
00:58:55,570 --> 00:58:57,400
啊，这看起来就像我们想要的

1583
00:58:57,530 --> 00:59:00,170
在上一张幻灯片中，我的输入为零

1584
00:59:00,330 --> 00:59:02,170
这将不允许电源通过

1585
00:59:02,170 --> 00:59:03,870
所以电源必须通过电阻输出

1586
00:59:03,870 --> 00:59:05,170
我在那里得到了一个

1587
00:59:05,300 --> 00:59:08,930
从零到一现在电源可以通过

1588
00:59:08,930 --> 00:59:11,170
被推到垃圾堆里，不在乎

1589
00:59:11,330 --> 00:59:13,170
但这里没有电源

1590
00:59:13,170 --> 00:59:15,770
因为它不想通过电阻

1591
00:59:15,970 --> 00:59:17,130
我有敲门

1592
00:59:17,400 --> 00:59:18,100
现在敲门

1593
00:59:18,100 --> 00:59:20,100
当然我只需要一个晶体管

1594
00:59:20,170 --> 00:59:22,100
还有那个小电阻

1595
00:59:22,130 --> 00:59:25,100
所有这些当然都是物理上可以实现的

1596
00:59:25,970 --> 00:59:27,670
好吧，我们做了什么

1597
00:59:27,670 --> 00:59:30,130
我们采取了这个非常非常简单的小事

1598
00:59:30,130 --> 00:59:31,370
这个小小的晶体管

1599
00:59:31,370 --> 00:59:32,130
顺便说一句，这些是

1600
00:59:32,130 --> 00:59:33,200
这是一个魔法

1601
00:59:33,530 --> 00:59:35,530
压缩所有计算

1602
00:59:35,530 --> 00:59:37,500
到口袋里的手机上

1603
00:59:37,700 --> 00:59:40,000
是因为那些晶体管每年

1604
00:59:40,000 --> 00:59:42,670
变得越来越小，越来越小

1605
00:59:42,800 --> 00:59:43,770
我可以打包

1606
00:59:43,970 --> 00:59:45,800
其中数百万和数十亿

1607
00:59:45,870 --> 00:59:47,070
变成一平方厘米

1608
00:59:47,070 --> 00:59:48,730
并拥有惊人的计算能力

1609
00:59:48,730 --> 00:59:50,000
因为他们是

1610
00:59:50,170 --> 00:59:53,170
所有现代计算的支柱

1611
00:59:53,530 --> 00:59:55,930
我们可以建造逻辑土地

1612
00:59:55,930 --> 01:00:00,500
逻辑或逻辑非来自串联的两个晶体管

1613
01:00:00,500 --> 01:00:03,600
对于并联的一个和两个晶体管蕨类或

1614
01:00:03,700 --> 01:00:06,700
和晶体管安装小电阻器不

1615
01:00:07,200 --> 01:00:09,370
所以现在我必须让你相信

1616
01:00:09,370 --> 01:00:11,800
这足以进行现代计算

1617
01:00:11,800 --> 01:00:14,130
顺便说一句，这似乎是一个真正的延伸

1618
01:00:14,130 --> 01:00:17,300
你可能相信我可以建造这些门

1619
01:00:17,300 --> 01:00:19,130
超级简单的计算

1620
01:00:19,170 --> 01:00:22,600
但我如何从这些门进入实际计算

1621
01:00:22,930 --> 01:00:24,270
这就是我们接下来要看到的

1622
01:00:24,270 --> 01:00:25,400
那么一会儿见


