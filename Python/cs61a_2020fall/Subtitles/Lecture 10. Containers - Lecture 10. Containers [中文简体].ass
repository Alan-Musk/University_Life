[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: Lecture 10. Containers - Lecture 10. Containers
ScriptType: v4.00+
PlayResX: 1280
PlayResY: 720
Timer: 10.0000
WrapStyle: 0
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: TopLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,7,32,32,32,0
Style: TopCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,8,32,32,32,0
Style: TopRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,9,32,32,32,0
Style: BottomLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,1,32,32,32,0
Style: BottomCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,2,32,32,32,0
Style: BottomRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,3,32,32,32,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.53,0:00:04.73,BottomCenter,,0,0,0,,61一讲第10期公告
Dialogue: 0,0:00:06.37,0:00:08.90,BottomCenter,,0,0,0,,期中一次改级请求将于周一截止
Dialogue: 0,0:00:09.40,0:00:10.10,BottomCenter,,0,0,0,,请确定
Dialogue: 0,0:00:10.10,0:00:12.17,BottomCenter,,0,0,0,,指向你期中考试录音的链接
Dialogue: 0,0:00:12.17,0:00:13.07,BottomCenter,,0,0,0,,继续工作
Dialogue: 0,0:00:13.07,0:00:14.00,BottomCenter,,0,0,0,,到周一
Dialogue: 0,0:00:14.97,0:00:15.27,BottomCenter,,0,0,0,,你会
Dialogue: 0,0:00:15.27,0:00:17.50,BottomCenter,,0,0,0,,如果您需要保留更长时间，请联系我们
Dialogue: 0,0:00:17.50,0:00:20.13,BottomCenter,,0,0,0,,但如果您没有收到我们的消息，您可以将其删除
Dialogue: 0,0:00:20.33,0:00:21.77,BottomCenter,,0,0,0,,或不，这完全取决于你
Dialogue: 0,0:00:21.77,0:00:21.93,BottomCenter,,0,0,0,,但
Dialogue: 0,0:00:21.93,0:00:23.90,BottomCenter,,0,0,0,,如果您想释放谷歌驱动器上的一些空间
Dialogue: 0,0:00:23.90,0:00:27.33,BottomCenter,,0,0,0,,或者任何你可以在周二删除它们的东西
Dialogue: 0,0:00:27.80,0:00:29.33,BottomCenter,,0,0,0,,作业二周四到期
Dialogue: 0,0:00:29.93,0:00:32.13,BottomCenter,,0,0,0,,完全可选的生猪策略竞赛
Dialogue: 0,0:00:32.17,0:00:34.00,BottomCenter,,0,0,0,,将于周一结束
Dialogue: 0,0:00:34.47,0:00:37.33,BottomCenter,,0,0,0,,让我们看看到目前为止有多少人提交了
Dialogue: 0,0:00:38.97,0:00:39.87,BottomCenter,,0,0,0,,很多
Dialogue: 0,0:00:40.73,0:00:43.07,BottomCenter,,0,0,0,,我们有 112 份意见书
Dialogue: 0,0:00:43.50,0:00:45.20,BottomCenter,,0,0,0,,斯坦福仍然垫底
Dialogue: 0,0:00:45.90,0:00:48.73,BottomCenter,,0,0,0,,我们有四人并列第一名
Dialogue: 0,0:00:49.67,0:00:51.80,BottomCenter,,0,0,0,,这在很多年里都不会发生
Dialogue: 0,0:00:52.73,0:00:54.27,BottomCenter,,0,0,0,,但只是因为你现在赢了
Dialogue: 0,0:00:54.27,0:00:56.60,BottomCenter,,0,0,0,,并不意味着你会赢得整个比赛
Dialogue: 0,0:00:56.80,0:00:57.87,BottomCenter,,0,0,0,,这并不奇异
Dialogue: 0,0:00:57.87,0:01:00.92,BottomCenter,,0,0,0,,有人会保存他们最好的作品
Dialogue: 0,0:01:01.00,0:01:02.27,BottomCenter,,0,0,0,,直到最后一刻
Dialogue: 0,0:01:02.70,0:01:04.50,BottomCenter,,0,0,0,,所以我们看看今年会发生什么
Dialogue: 0,0:01:05.93,0:01:08.53,BottomCenter,,0,0,0,,我很高兴看到很多人参与
Dialogue: 0,0:01:10.29,0:01:11.93,BottomCenter,,0,0,0,,这周我们将有一个实验室
Dialogue: 0,0:01:12.12,0:01:13.56,BottomCenter,,0,0,0,,实验室预计周二截止
Dialogue: 0,0:01:13.76,0:01:15.59,BottomCenter,,0,0,0,,周一参加迎新活动
Dialogue: 0,0:01:15.59,0:01:17.50,BottomCenter,,0,0,0,,周一完成实验
Dialogue: 0,0:01:17.59,0:01:19.06,BottomCenter,,0,0,0,,这真的只在星期二做
Dialogue: 0,0:01:19.06,0:01:21.79,BottomCenter,,0,0,0,,万一由于某种原因你周一无法完成它
Dialogue: 0,0:01:22.87,0:01:26.20,BottomCenter,,0,0,0,,我们将在周三的教程中进行讨论
Dialogue: 0,0:01:26.40,0:01:28.59,BottomCenter,,0,0,0,,周五的考试准备部分
Dialogue: 0,0:01:29.33,0:01:31.53,BottomCenter,,0,0,0,,周一与讲师一起进行选举 q amp a
Dialogue: 0,0:01:31.53,0:01:33.37,BottomCenter,,0,0,0,,周三和周五早上
Dialogue: 0,0:01:34.76,0:01:36.50,BottomCenter,,0,0,0,,今天的讲座不全是关于递归
Dialogue: 0,0:01:36.50,0:01:39.26,BottomCenter,,0,0,0,,但其中散布着一些递归示例
Dialogue: 0,0:01:39.90,0:01:42.40,BottomCenter,,0,0,0,,相反，今天我们讨论如何命名
Dialogue: 0,0:01:42.40,0:01:43.40,BottomCenter,,0,0,0,,多个值
Dialogue: 0,0:01:43.40,0:01:45.56,BottomCenter,,0,0,0,,使用容器捆绑在一起
Dialogue: 0,0:01:46.37,0:01:48.37,BottomCenter,,0,0,0,,我们还将讨论一些关于字符串的内容
Dialogue: 0,0:01:48.37,0:01:49.70,BottomCenter,,0,0,0,,因为那些是相关的
Dialogue: 0,0:01:49.97,0:01:52.26,BottomCenter,,0,0,0,,它们有点像装满信件的容器
Dialogue: 0,0:01:53.17,0:01:54.20,BottomCenter,,0,0,0,,好的，我们开始吧
Dialogue: 0,0:01:55.70,0:01:59.40,BottomCenter,,0,0,0,,列表是Python中的内置数据类型
Dialogue: 0,0:01:59.40,0:02:01.59,BottomCenter,,0,0,0,,随处可见的
Dialogue: 0,0:02:03.93,0:02:06.29,BottomCenter,,0,0,0,,为了创建一个列表，我们编写一个列表文字
Dialogue: 0,0:02:10.16,0:02:13.09,BottomCenter,,0,0,0,,将该列表值绑定到名称
Dialogue: 0,0:02:13.12,0:02:15.06,BottomCenter,,0,0,0,,我们只使用赋值语句
Dialogue: 0,0:02:15.06,0:02:16.80,BottomCenter,,0,0,0,,所以这里有一些奇数
Dialogue: 0,0:02:16.87,0:02:18.33,BottomCenter,,0,0,0,,我可以得到
Dialogue: 0,0:02:18.56,0:02:23.53,BottomCenter,,0,0,0,,索引零或一或二或三处的元素
Dialogue: 0,0:02:24.53,0:02:27.50,BottomCenter,,0,0,0,,我还可以获得元素的数量
Dialogue: 0,0:02:29.66,0:02:30.50,BottomCenter,,0,0,0,,现在注意到
Dialogue: 0,0:02:30.50,0:02:32.00,BottomCenter,,0,0,0,,最后一个元素的索引是
Dialogue: 0,0:02:32.00,0:02:34.19,BottomCenter,,0,0,0,,比元素的长度少一
Dialogue: 0,0:02:34.27,0:02:36.09,BottomCenter,,0,0,0,,所以思考这个指数的正确方法
Dialogue: 0,0:02:36.09,0:02:38.40,BottomCenter,,0,0,0,,是从开始处的偏移量
Dialogue: 0,0:02:39.87,0:02:42.90,BottomCenter,,0,0,0,,从开始的零偏移量只是开始
Dialogue: 0,0:02:43.53,0:02:46.72,BottomCenter,,0,0,0,,然后这是那之后的一张，然后是那之后的两张
Dialogue: 0,0:02:46.72,0:02:47.77,BottomCenter,,0,0,0,,之后是三个
Dialogue: 0,0:02:49.53,0:02:51.50,BottomCenter,,0,0,0,,现在这只是一个调用表达式
Dialogue: 0,0:02:51.50,0:02:53.69,BottomCenter,,0,0,0,,这是一个元素选择表达式
Dialogue: 0,0:02:53.69,0:02:55.90,BottomCenter,,0,0,0,,你有一些需要评估的表达式
Dialogue: 0,0:02:55.90,0:02:57.16,BottomCenter,,0,0,0,,这给了你一个清单
Dialogue: 0,0:02:57.19,0:02:59.97,BottomCenter,,0,0,0,,然后你必须评估索引
Dialogue: 0,0:03:00.72,0:03:03.40,BottomCenter,,0,0,0,,所以可以在其中放入任意表达式
Dialogue: 0,0:03:03.40,0:03:04.90,BottomCenter,,0,0,0,,这些地方之一
Dialogue: 0,0:03:04.90,0:03:07.80,BottomCenter,,0,0,0,,并以我想要的任何方式组合结果
Dialogue: 0,0:03:08.00,0:03:11.96,BottomCenter,,0,0,0,,所以我可以说赔率 3 赔率 2
Dialogue: 0,0:03:12.56,0:03:14.19,BottomCenter,,0,0,0,,这给了我第二名
Dialogue: 0,0:03:14.27,0:03:16.97,BottomCenter,,0,0,0,,然后我可以用它作为赔率的索引
Dialogue: 0,0:03:18.47,0:03:20.97,BottomCenter,,0,0,0,,这意味着你可以在这里放置任意表达式
Dialogue: 0,0:03:20.97,0:03:22.50,BottomCenter,,0,0,0,,首先评估哪个
Dialogue: 0,0:03:22.50,0:03:23.97,BottomCenter,,0,0,0,,那里有一个任意的表达
Dialogue: 0,0:03:24.00,0:03:25.09,BottomCenter,,0,0,0,,得到评估
Dialogue: 0,0:03:25.09,0:03:27.33,BottomCenter,,0,0,0,,第二次，然后一旦你在这里有了价值
Dialogue: 0,0:03:27.33,0:03:28.33,BottomCenter,,0,0,0,,这是一个列表
Dialogue: 0,0:03:28.33,0:03:30.40,BottomCenter,,0,0,0,,这里的值是一个整数
Dialogue: 0,0:03:30.47,0:03:33.33,BottomCenter,,0,0,0,,您可以查找列表中的特定元素
Dialogue: 0,0:03:35.19,0:03:37.80,BottomCenter,,0,0,0,,因此，在处理列表时，我们使用列表文字
Dialogue: 0,0:03:37.80,0:03:40.30,BottomCenter,,0,0,0,,我们还可以写出表达式来描述
Dialogue: 0,0:03:40.30,0:03:41.90,BottomCenter,,0,0,0,,列表中的每个元素
Dialogue: 0,0:03:42.12,0:03:43.27,BottomCenter,,0,0,0,,在这种情况下
Dialogue: 0,0:03:43.27,0:03:46.19,BottomCenter,,0,0,0,,数字将绑定到相等的列表
Dialogue: 0,0:03:46.87,0:03:49.09,BottomCenter,,0,0,0,,不管我们是否写下数字
Dialogue: 0,0:03:49.09,0:03:51.72,BottomCenter,,0,0,0,,或计算结果为这些数字的表达式
Dialogue: 0,0:03:52.77,0:03:55.33,BottomCenter,,0,0,0,,获取我们要求 len 的元素数量
Dialogue: 0,0:03:55.97,0:03:58.40,BottomCenter,,0,0,0,,列表的 len 是一个内置函数
Dialogue: 0,0:03:59.27,0:04:02.56,BottomCenter,,0,0,0,,如果我想找到按其索引选择的元素
Dialogue: 0,0:04:02.80,0:04:06.53,BottomCenter,,0,0,0,,我可以使用元素选择语法，也可以使用
Dialogue: 0,0:04:06.87,0:04:10.00,BottomCenter,,0,0,0,,操作员模块中的获取项目功能
Dialogue: 0,0:04:10.30,0:04:11.77,BottomCenter,,0,0,0,,具有相同的效果
Dialogue: 0,0:04:14.16,0:04:15.50,BottomCenter,,0,0,0,,为了结合
Dialogue: 0,0:04:15.56,0:04:19.17,BottomCenter,,0,0,0,,两个列表在一起或形成列表的重复
Dialogue: 0,0:04:19.17,0:04:21.52,BottomCenter,,0,0,0,,我实际上只是加法和乘法
Dialogue: 0,0:04:21.97,0:04:24.26,BottomCenter,,0,0,0,,所以如果我把这个清单说成七
Dialogue: 0,0:04:25.00,0:04:27.39,BottomCenter,,0,0,0,,加上数字列表乘以二
Dialogue: 0,0:04:27.97,0:04:29.10,BottomCenter,,0,0,0,,数字相乘
Dialogue: 0,0:04:29.10,0:04:31.93,BottomCenter,,0,0,0,,list times two 只是将其元素复制两次
Dialogue: 0,0:04:32.06,0:04:33.52,BottomCenter,,0,0,0,,然后添加那些
Dialogue: 0,0:04:33.52,0:04:36.87,BottomCenter,,0,0,0,,到列表末尾到七给我一个长列表
Dialogue: 0,0:04:36.87,0:04:38.32,BottomCenter,,0,0,0,,有 10 个元素
Dialogue: 0,0:04:39.19,0:04:40.56,BottomCenter,,0,0,0,,我也可以使用
Dialogue: 0,0:04:40.56,0:04:44.12,BottomCenter,,0,0,0,,运算符模块中的 add 和 mull 函数
Dialogue: 0,0:04:46.17,0:04:50.10,BottomCenter,,0,0,0,,最后，列表的元素不必是整数
Dialogue: 0,0:04:50.12,0:04:53.00,BottomCenter,,0,0,0,,它们可以是任何东西，包括其他列表
Dialogue: 0,0:04:53.26,0:04:55.26,BottomCenter,,0,0,0,,所以这里我有一个列表文字
Dialogue: 0,0:04:56.97,0:04:59.37,BottomCenter,,0,0,0,,与另外两个嵌套列表文字
Dialogue: 0,0:05:00.06,0:05:03.19,BottomCenter,,0,0,0,,我创建的是一个包含两个元素的列表
Dialogue: 0,0:05:03.30,0:05:05.69,BottomCenter,,0,0,0,,每个都是包含两个元素的列表
Dialogue: 0,0:05:05.69,0:05:06.80,BottomCenter,,0,0,0,,这是整数
Dialogue: 0,0:05:07.52,0:05:13.10,BottomCenter,,0,0,0,,所以要求元素对中的第 1 号元素给了我
Dialogue: 0,0:05:13.19,0:05:17.00,BottomCenter,,0,0,0,,这个元素是一个包含 30 和 40 的列表
Dialogue: 0,0:05:17.87,0:05:21.30,BottomCenter,,0,0,0,,所以在这里你看到有一个组合表达式
Dialogue: 0,0:05:21.37,0:05:23.73,BottomCenter,,0,0,0,,在本例中是元素选择表达式
Dialogue: 0,0:05:24.00,0:05:25.12,BottomCenter,,0,0,0,,给我一个清单
Dialogue: 0,0:05:25.17,0:05:26.89,BottomCenter,,0,0,0,,然后我从中选择一个元素
Dialogue: 0,0:05:26.89,0:05:28.37,BottomCenter,,0,0,0,,为了获得第30名
Dialogue: 0,0:05:32.52,0:05:34.87,BottomCenter,,0,0,0,,列表包含其他值
Dialogue: 0,0:05:35.37,0:05:38.80,BottomCenter,,0,0,0,,它们的值代表其他值的集合
Dialogue: 0,0:05:39.80,0:05:43.19,BottomCenter,,0,0,0,,当你有一个值包含另一个值时
Dialogue: 0,0:05:44.00,0:05:45.67,BottomCenter,,0,0,0,,你可能会问这个问题
Dialogue: 0,0:05:45.89,0:05:49.30,BottomCenter,,0,0,0,,元素是否出现在列表中
Dialogue: 0,0:05:50.12,0:05:52.06,BottomCenter,,0,0,0,,实际上有内置的运算符
Dialogue: 0,0:05:52.06,0:05:54.17,BottomCenter,,0,0,0,,用于测试某个元素是否出现
Dialogue: 0,0:05:54.26,0:05:56.87,BottomCenter,,0,0,0,,在复合值（例如容器）中
Dialogue: 0,0:05:57.87,0:05:59.60,BottomCenter,,0,0,0,,假设我有数字
Dialogue: 0,0:05:59.69,0:06:01.52,BottomCenter,,0,0,0,,这是一八二加八
Dialogue: 0,0:06:02.17,0:06:04.47,BottomCenter,,0,0,0,,我可以问的是一位数字
Dialogue: 0,0:06:05.32,0:06:06.87,BottomCenter,,0,0,0,,python 将返回 true
Dialogue: 0,0:06:07.10,0:06:08.69,BottomCenter,,0,0,0,,所以 in 是一个运算符
Dialogue: 0,0:06:10.69,0:06:11.97,BottomCenter,,0,0,0,,评估
Dialogue: 0,0:06:12.19,0:06:14.10,BottomCenter,,0,0,0,,一位和数字
Dialogue: 0,0:06:14.10,0:06:17.32,BottomCenter,,0,0,0,,然后判断1是否出现在数字中
Dialogue: 0,0:06:18.19,0:06:19.30,BottomCenter,,0,0,0,,八是数字
Dialogue: 0,0:06:19.30,0:06:21.47,BottomCenter,,0,0,0,,事实上它在那里两次并不重要
Dialogue: 0,0:06:21.47,0:06:22.32,BottomCenter,,0,0,0,,它在那里
Dialogue: 0,0:06:22.67,0:06:24.47,BottomCenter,,0,0,0,,五不是数字
Dialogue: 0,0:06:24.80,0:06:27.37,BottomCenter,,0,0,0,,所以如果我说五位数字我就会得到错误
Dialogue: 0,0:06:27.37,0:06:29.50,BottomCenter,,0,0,0,,但既然我说的五不是数字
Dialogue: 0,0:06:29.50,0:06:30.93,BottomCenter,,0,0,0,,这是另一个运算符
Dialogue: 0,0:06:30.97,0:06:33.87,BottomCenter,,0,0,0,,这相当于说数字不是五
Dialogue: 0,0:06:34.89,0:06:36.80,BottomCenter,,0,0,0,,让我们看一些其他的例子
Dialogue: 0,0:06:38.80,0:06:40.06,BottomCenter,,0,0,0,,所以这是数字
Dialogue: 0,0:06:40.73,0:06:42.93,BottomCenter,,0,0,0,,数字 1 为真
Dialogue: 0,0:06:43.17,0:06:45.73,BottomCenter,,0,0,0,,五位数字是假的
Dialogue: 0,0:06:46.37,0:06:51.50,BottomCenter,,0,0,0,,现在它必须是值，因为一不等于一
Dialogue: 0,0:06:51.50,0:06:53.73,BottomCenter,,0,0,0,,如果我说数字一
Dialogue: 0,0:06:53.87,0:06:56.80,BottomCenter,,0,0,0,,字符串 1 不存在，只有整数
Dialogue: 0,0:06:58.56,0:07:01.73,BottomCenter,,0,0,0,,我们也在寻找一个单独的元素
Dialogue: 0,0:07:01.97,0:07:05.80,BottomCenter,,0,0,0,,如果我说的是数字序列一八
Dialogue: 0,0:07:06.89,0:07:08.10,BottomCenter,,0,0,0,,它说假的
Dialogue: 0,0:07:08.39,0:07:10.26,BottomCenter,,0,0,0,,但那是一和八
Dialogue: 0,0:07:10.60,0:07:13.17,BottomCenter,,0,0,0,,这不是旅馆经营者所做的
Dialogue: 0,0:07:13.17,0:07:15.37,BottomCenter,,0,0,0,,它不寻找子序列
Dialogue: 0,0:07:15.39,0:07:18.06,BottomCenter,,0,0,0,,相反，它会寻找单个元素
Dialogue: 0,0:07:18.87,0:07:22.37,BottomCenter,,0,0,0,,如果我说的是一二
Dialogue: 0,0:07:22.67,0:07:26.80,BottomCenter,,0,0,0,,包含一和二的嵌套列表
Dialogue: 0,0:07:27.87,0:07:28.87,BottomCenter,,0,0,0,,那是真的
Dialogue: 0,0:07:28.87,0:07:31.26,BottomCenter,,0,0,0,,因为它就在那里作为一个元素
Dialogue: 0,0:07:31.32,0:07:32.52,BottomCenter,,0,0,0,,此列表中的
Dialogue: 0,0:07:33.47,0:07:35.30,BottomCenter,,0,0,0,,但如果嵌套得太深
Dialogue: 0,0:07:37.10,0:07:38.60,BottomCenter,,0,0,0,,然后它就不再存在了
Dialogue: 0,0:07:39.32,0:07:42.00,BottomCenter,,0,0,0,,所以这是一个不搜索的简单运算符
Dialogue: 0,0:07:42.12,0:07:42.93,BottomCenter,,0,0,0,,通过一个结构
Dialogue: 0,0:07:42.93,0:07:44.76,BottomCenter,,0,0,0,,试图找到任何匹配的东西
Dialogue: 0,0:07:44.76,0:07:46.93,BottomCenter,,0,0,0,,并说它只是逐个元素地进行
Dialogue: 0,0:07:46.93,0:07:48.47,BottomCenter,,0,0,0,,并查看是否相等
Dialogue: 0,0:07:48.47,0:07:50.06,BottomCenter,,0,0,0,,到您正在寻找的元素
Dialogue: 0,0:07:53.67,0:07:56.26,BottomCenter,,0,0,0,,因为序列是计算的基础
Dialogue: 0,0:07:57.06,0:08:00.50,BottomCenter,,0,0,0,,人们已经发展出新的表述方式
Dialogue: 0,0:08:00.60,0:08:04.69,BottomCenter,,0,0,0,,帮助我们操作或迭代序列
Dialogue: 0,0:08:04.97,0:08:06.93,BottomCenter,,0,0,0,,其中之一是四个声明
Dialogue: 0,0:08:07.26,0:08:07.87,BottomCenter,,0,0,0,,所以四个
Dialogue: 0,0:08:07.87,0:08:10.26,BottomCenter,,0,0,0,,语句是迭代序列的一种方式
Dialogue: 0,0:08:10.26,0:08:11.60,BottomCenter,,0,0,0,,我给你看一个例子
Dialogue: 0,0:08:11.69,0:08:13.93,BottomCenter,,0,0,0,,然后我会确切地告诉你它是如何运作的
Dialogue: 0,0:08:16.69,0:08:17.89,BottomCenter,,0,0,0,,我会写一个函数
Dialogue: 0,0:08:17.97,0:08:19.39,BottomCenter,,0,0,0,,计算计数
Dialogue: 0,0:08:19.39,0:08:21.80,BottomCenter,,0,0,0,,序列 s 中的次数
Dialogue: 0,0:08:21.87,0:08:23.67,BottomCenter,,0,0,0,,出现一些值
Dialogue: 0,0:08:26.97,0:08:28.69,BottomCenter,,0,0,0,,数数
Dialogue: 0,0:08:29.89,0:08:34.10,BottomCenter,,0,0,0,,该值出现的次数
Dialogue: 0,0:08:35.29,0:08:38.07,BottomCenter,,0,0,0,,在序列 s 中
Dialogue: 0,0:08:41.60,0:08:42.97,BottomCenter,,0,0,0,,并使用 while 语句
Dialogue: 0,0:08:42.97,0:08:46.87,BottomCenter,,0,0,0,,我可能会写一些像总索引等于零的东西
Dialogue: 0,0:08:46.87,0:08:47.66,BottomCenter,,0,0,0,,零
Dialogue: 0,0:08:48.79,0:08:50.60,BottomCenter,,0,0,0,,虽然是这样
Dialogue: 0,0:08:50.73,0:08:54.39,BottomCenter,,0,0,0,,该索引小于序列的长度
Dialogue: 0,0:08:54.70,0:08:57.10,BottomCenter,,0,0,0,,我要看看这个元素
Dialogue: 0,0:08:57.52,0:08:58.33,BottomCenter,,0,0,0,,在
Dialogue: 0,0:08:59.26,0:09:00.12,BottomCenter,,0,0,0,,指数
Dialogue: 0,0:09:01.26,0:09:02.37,BottomCenter,,0,0,0,,的
Dialogue: 0,0:09:02.66,0:09:03.07,BottomCenter,,0,0,0,,所以现在
Dialogue: 0,0:09:03.07,0:09:05.97,BottomCenter,,0,0,0,,我选择了索引的一个特定元素
Dialogue: 0,0:09:06.26,0:09:08.73,BottomCenter,,0,0,0,,如果我从索引零开始
Dialogue: 0,0:09:08.73,0:09:10.60,BottomCenter,,0,0,0,,我会选择零元素
Dialogue: 0,0:09:10.60,0:09:12.26,BottomCenter,,0,0,0,,如果我稍后更改索引
Dialogue: 0,0:09:12.37,0:09:14.57,BottomCenter,,0,0,0,,然后我稍后会得到另一个元素
Dialogue: 0,0:09:14.57,0:09:16.20,BottomCenter,,0,0,0,,所以在某个时刻
Dialogue: 0,0:09:16.26,0:09:19.10,BottomCenter,,0,0,0,,我将重新绑定索引到索引加一
Dialogue: 0,0:09:19.10,0:09:21.26,BottomCenter,,0,0,0,,这样我就可以迈过
Dialogue: 0,0:09:21.37,0:09:23.10,BottomCenter,,0,0,0,,列表的所有元素
Dialogue: 0,0:09:24.16,0:09:25.47,BottomCenter,,0,0,0,,我该如何处理这个元素
Dialogue: 0,0:09:25.47,0:09:27.73,BottomCenter,,0,0,0,,好吧，我想知道是否
Dialogue: 0,0:09:28.26,0:09:31.89,BottomCenter,,0,0,0,,元素等于我正在寻找的这个值
Dialogue: 0,0:09:31.97,0:09:35.20,BottomCenter,,0,0,0,,如果是这样，我会将总计更改为总计加一
Dialogue: 0,0:09:38.39,0:09:40.50,BottomCenter,,0,0,0,,最后我可以返回总计
Dialogue: 0,0:09:42.60,0:09:44.10,BottomCenter,,0,0,0,,那么到目前为止我做了什么
Dialogue: 0,0:09:44.20,0:09:46.26,BottomCenter,,0,0,0,,我必须找到一个名为 count 的函数
Dialogue: 0,0:09:46.37,0:09:48.16,BottomCenter,,0,0,0,,以某种顺序进行
Dialogue: 0,0:09:48.87,0:09:51.26,BottomCenter,,0,0,0,,并计算说的次数
Dialogue: 0,0:09:51.47,0:09:53.60,BottomCenter,,0,0,0,,一个出现在该序列中
Dialogue: 0,0:09:53.60,0:09:56.33,BottomCenter,,0,0,0,,哦，这是三倍 1 2 3
Dialogue: 0,0:09:57.37,0:09:59.60,BottomCenter,,0,0,0,,好的，这是一个有用的码头测试
Dialogue: 0,0:09:59.60,0:10:01.66,BottomCenter,,0,0,0,,让我们把它粘贴到那里
Dialogue: 0,0:10:03.60,0:10:06.12,BottomCenter,,0,0,0,,然后我们会讨论这个实现
Dialogue: 0,0:10:07.00,0:10:09.00,BottomCenter,,0,0,0,,好吧，让我们尝试让它变得更短
Dialogue: 0,0:10:09.73,0:10:10.87,BottomCenter,,0,0,0,,我们在这里看到一件事
Dialogue: 0,0:10:10.87,0:10:13.29,BottomCenter,,0,0,0,,是总数是反弹总数加一
Dialogue: 0,0:10:13.37,0:10:15.92,BottomCenter,,0,0,0,,python 中实际上有这样做的简写
Dialogue: 0,0:10:15.92,0:10:18.47,BottomCenter,,0,0,0,,我只能说总加等于一
Dialogue: 0,0:10:18.70,0:10:21.07,BottomCenter,,0,0,0,,这是一个不同的赋值运算符
Dialogue: 0,0:10:21.16,0:10:24.10,BottomCenter,,0,0,0,,科学总数是之前的总数
Dialogue: 0,0:10:24.16,0:10:25.33,BottomCenter,,0,0,0,,然后还有一个
Dialogue: 0,0:10:25.73,0:10:28.52,BottomCenter,,0,0,0,,我可以在这里做同样的事情并简化
Dialogue: 0,0:10:29.20,0:10:31.29,BottomCenter,,0,0,0,,好的，我们已经取得了一些进展
Dialogue: 0,0:10:31.29,0:10:32.76,BottomCenter,,0,0,0,,但我认为我们可以做得更好
Dialogue: 0,0:10:34.47,0:10:37.70,BottomCenter,,0,0,0,,这个实现的重点就在这里
Dialogue: 0,0:10:38.16,0:10:40.26,BottomCenter,,0,0,0,,剩下的只是做工作
Dialogue: 0,0:10:40.26,0:10:41.37,BottomCenter,,0,0,0,,迭代的
Dialogue: 0,0:10:41.37,0:10:43.16,BottomCenter,,0,0,0,,序列中的所有元素
Dialogue: 0,0:10:43.39,0:10:44.97,BottomCenter,,0,0,0,,这是很常见的事情
Dialogue: 0,0:10:45.00,0:10:46.97,BottomCenter,,0,0,0,,我们对此有特别声明
Dialogue: 0,0:10:47.07,0:10:48.37,BottomCenter,,0,0,0,,称为四声明
Dialogue: 0,0:10:49.20,0:10:51.66,BottomCenter,,0,0,0,,四个语句让我们忘记
Dialogue: 0,0:10:51.66,0:10:53.70,BottomCenter,,0,0,0,,完全关于该指数
Dialogue: 0,0:10:54.00,0:10:57.52,BottomCenter,,0,0,0,,而不是说 while index 小于 len s
Dialogue: 0,0:10:57.52,0:11:00.79,BottomCenter,,0,0,0,,我只是说对于 s 中的每个元素
Dialogue: 0,0:11:02.52,0:11:04.73,BottomCenter,,0,0,0,,并取代这两行
Dialogue: 0,0:11:04.76,0:11:08.20,BottomCenter,,0,0,0,,并允许我摆脱索引增量
Dialogue: 0,0:11:08.29,0:11:09.26,BottomCenter,,0,0,0,,在底部
Dialogue: 0,0:11:09.76,0:11:12.70,BottomCenter,,0,0,0,,所以现在如果我读出这个实现的内容
Dialogue: 0,0:11:12.70,0:11:13.79,BottomCenter,,0,0,0,,它说我要保留
Dialogue: 0,0:11:13.79,0:11:15.73,BottomCenter,,0,0,0,,追踪总次数
Dialogue: 0,0:11:15.89,0:11:17.60,BottomCenter,,0,0,0,,我看到了 s 的价值
Dialogue: 0,0:11:17.60,0:11:20.66,BottomCenter,,0,0,0,,对于 s 中的每个元素，如果元素是该值
Dialogue: 0,0:11:20.66,0:11:22.89,BottomCenter,,0,0,0,,然后我将总数加一
Dialogue: 0,0:11:28.79,0:11:31.92,BottomCenter,,0,0,0,,如果我运行码头测试，我会看到它尝试计数
Dialogue: 0,0:11:32.16,0:11:33.60,BottomCenter,,0,0,0,,此序列中的一个
Dialogue: 0,0:11:33.60,0:11:34.89,BottomCenter,,0,0,0,,它期待三个
Dialogue: 0,0:11:34.97,0:11:37.00,BottomCenter,,0,0,0,,这正是它返回的结果
Dialogue: 0,0:11:37.20,0:11:38.73,BottomCenter,,0,0,0,,一项测试通过
Dialogue: 0,0:11:41.33,0:11:44.16,BottomCenter,,0,0,0,,好的，这是序列迭代的一个例子
Dialogue: 0,0:11:45.39,0:11:47.20,BottomCenter,,0,0,0,,我们使用了四个语句
Dialogue: 0,0:11:47.97,0:11:49.20,BottomCenter,,0,0,0,,以及它是如何运作的
Dialogue: 0,0:11:49.47,0:11:51.70,BottomCenter,,0,0,0,,那么发生的事情是这样的
Dialogue: 0,0:11:51.70,0:11:53.29,BottomCenter,,0,0,0,,name 元素已绑定
Dialogue: 0,0:11:53.29,0:11:55.50,BottomCenter,,0,0,0,,在当前环境的第一帧中
Dialogue: 0,0:11:55.89,0:11:57.26,BottomCenter,,0,0,0,,顺便说一下，不是新框架
Dialogue: 0,0:11:57.26,0:11:59.79,BottomCenter,,0,0,0,,没有用四个语句引入新的框架
Dialogue: 0,0:12:00.89,0:12:02.47,BottomCenter,,0,0,0,,但名称元素已绑定
Dialogue: 0,0:12:02.50,0:12:05.10,BottomCenter,,0,0,0,,然后执行这四个语句的套件
Dialogue: 0,0:12:05.52,0:12:06.16,BottomCenter,,0,0,0,,然后是名字
Dialogue: 0,0:12:06.16,0:12:07.79,BottomCenter,,0,0,0,,元素与下一个事物绑定
Dialogue: 0,0:12:08.20,0:12:09.60,BottomCenter,,0,0,0,,我们再次执行这个
Dialogue: 0,0:12:10.66,0:12:12.66,BottomCenter,,0,0,0,,所以当你有四个陈述时
Dialogue: 0,0:12:12.66,0:12:15.60,BottomCenter,,0,0,0,,它将执行语句套件
Dialogue: 0,0:12:15.60,0:12:16.66,BottomCenter,,0,0,0,,多次
Dialogue: 0,0:12:16.66,0:12:18.66,BottomCenter,,0,0,0,,这是 s 中的元素数量
Dialogue: 0,0:12:18.79,0:12:20.50,BottomCenter,,0,0,0,,一个元素将被绑定到不同的
Dialogue: 0,0:12:20.50,0:12:22.07,BottomCenter,,0,0,0,,每次 s 的元素
Dialogue: 0,0:12:24.57,0:12:27.07,BottomCenter,,0,0,0,,所以这是执行程序
Dialogue: 0,0:12:27.52,0:12:30.73,BottomCenter,,0,0,0,,该语句的语法如下所示
Dialogue: 0,0:12:30.73,0:12:31.52,BottomCenter,,0,0,0,,你需要一个名字
Dialogue: 0,0:12:31.52,0:12:33.79,BottomCenter,,0,0,0,,你需要一个表情，你需要一个甜蜜
Dialogue: 0,0:12:35.07,0:12:37.47,BottomCenter,,0,0,0,,当您评估标头时发生的第一件事
Dialogue: 0,0:12:37.47,0:12:41.70,BottomCenter,,0,0,0,,必须产生可迭代值的表达式
Dialogue: 0,0:12:42.16,0:12:44.07,BottomCenter,,0,0,0,,现在我说我们正在迭代
Dialogue: 0,0:12:44.10,0:12:46.66,BottomCenter,,0,0,0,,可迭代值与此相关
Dialogue: 0,0:12:46.97,0:12:49.73,BottomCenter,,0,0,0,,但这是一个我不会精确定义的术语
Dialogue: 0,0:12:49.73,0:12:51.07,BottomCenter,,0,0,0,,几个星期
Dialogue: 0,0:12:51.92,0:12:53.70,BottomCenter,,0,0,0,,但现在想想
Dialogue: 0,0:12:53.89,0:12:57.26,BottomCenter,,0,0,0,,该表达式需要计算为一个序列
Dialogue: 0,0:12:57.89,0:12:59.52,BottomCenter,,0,0,0,,稍后我们会看到还有其他
Dialogue: 0,0:12:59.52,0:13:02.29,BottomCenter,,0,0,0,,除了序列之外我们还可以放入其中的东西
Dialogue: 0,0:13:02.33,0:13:04.10,BottomCenter,,0,0,0,,并迭代这些
Dialogue: 0,0:13:04.89,0:13:06.57,BottomCenter,,0,0,0,,但现在想想
Dialogue: 0,0:13:06.57,0:13:08.79,BottomCenter,,0,0,0,,我需要一个给我序列的表达式
Dialogue: 0,0:13:08.92,0:13:11.87,BottomCenter,,0,0,0,,我需要为该序列中的每个元素命名
Dialogue: 0,0:13:12.29,0:13:14.20,BottomCenter,,0,0,0,,然后对于序列中的每个元素
Dialogue: 0,0:13:14.26,0:13:16.07,BottomCenter,,0,0,0,,我们将该名称绑定到元素
Dialogue: 0,0:13:16.07,0:13:17.29,BottomCenter,,0,0,0,,在当前帧中
Dialogue: 0,0:13:17.37,0:13:18.79,BottomCenter,,0,0,0,,然后执行套件
Dialogue: 0,0:13:22.29,0:13:23.73,BottomCenter,,0,0,0,,另一项很酷的功能
Dialogue: 0,0:13:23.73,0:13:26.00,BottomCenter,,0,0,0,,关于四个陈述是，你实际上可以
Dialogue: 0,0:13:26.00,0:13:27.73,BottomCenter,,0,0,0,,进行序列解包
Dialogue: 0,0:13:27.89,0:13:30.79,BottomCenter,,0,0,0,,就在四个语句的标题内
Dialogue: 0,0:13:31.50,0:13:33.92,BottomCenter,,0,0,0,,假设我有一个列表列表
Dialogue: 0,0:13:34.33,0:13:36.10,BottomCenter,,0,0,0,,我在这里称之为对
Dialogue: 0,0:13:36.76,0:13:39.33,BottomCenter,,0,0,0,,我想数一下有多少对
Dialogue: 0,0:13:39.37,0:13:41.57,BottomCenter,,0,0,0,,这是同一个元素两次
Dialogue: 0,0:13:42.29,0:13:44.20,BottomCenter,,0,0,0,,所以我将逐一介绍
Dialogue: 0,0:13:45.33,0:13:48.37,BottomCenter,,0,0,0,,我想说的是一个和两个一样不
Dialogue: 0,0:13:48.50,0:13:50.52,BottomCenter,,0,0,0,,两个和两个一样吗 是
Dialogue: 0,0:13:50.52,0:13:53.10,BottomCenter,,0,0,0,,所以相同的计数将比以前多 1
Dialogue: 0,0:13:53.50,0:13:54.92,BottomCenter,,0,0,0,,三两个不同
Dialogue: 0,0:13:54.97,0:13:56.87,BottomCenter,,0,0,0,,但四和四是一样的
Dialogue: 0,0:13:56.87,0:13:59.00,BottomCenter,,0,0,0,,所以我们将再次增加相同的计数
Dialogue: 0,0:13:59.70,0:14:01.50,BottomCenter,,0,0,0,,现在这四个语句是什么样子的
Dialogue: 0,0:14:01.50,0:14:02.39,BottomCenter,,0,0,0,,可以做到这一点
Dialogue: 0,0:14:05.00,0:14:06.12,BottomCenter,,0,0,0,,这只是
Dialogue: 0,0:14:06.12,0:14:07.76,BottomCenter,,0,0,0,,适用于一系列固定的
Dialogue: 0,0:14:07.76,0:14:09.07,BottomCenter,,0,0,0,,长度序列
Dialogue: 0,0:14:09.12,0:14:11.12,BottomCenter,,0,0,0,,例如一系列对
Dialogue: 0,0:14:11.66,0:14:13.07,BottomCenter,,0,0,0,,但在那种情况下
Dialogue: 0,0:14:13.12,0:14:16.73,BottomCenter,,0,0,0,,然后你可以将每一对解压成单独的名称
Dialogue: 0,0:14:16.73,0:14:20.33,BottomCenter,,0,0,0,,所以你可以成对地说 for x 逗号 y
Dialogue: 0,0:14:20.60,0:14:22.52,BottomCenter,,0,0,0,,作为对序列的对
Dialogue: 0,0:14:22.73,0:14:23.60,BottomCenter,,0,0,0,,x 和 y
Dialogue: 0,0:14:23.60,0:14:26.89,BottomCenter,,0,0,0,,实际上现在绑定到每对中的元素
Dialogue: 0,0:14:27.07,0:14:28.89,BottomCenter,,0,0,0,,而不是这对本身
Dialogue: 0,0:14:29.26,0:14:31.66,BottomCenter,,0,0,0,,此时您可以检查 x 是否等于 y
Dialogue: 0,0:14:31.97,0:14:34.26,BottomCenter,,0,0,0,,如果这是真的，那么将相同的计数更改为 b
Dialogue: 0,0:14:34.26,0:14:35.47,BottomCenter,,0,0,0,,相同的计数加一
Dialogue: 0,0:14:36.66,0:14:38.07,BottomCenter,,0,0,0,,所以你要给每个人起一个名字
Dialogue: 0,0:14:38.07,0:14:40.29,BottomCenter,,0,0,0,,这里是固定长度序列中的元素
Dialogue: 0,0:14:40.70,0:14:43.16,BottomCenter,,0,0,0,,这就是所谓的序列拆包
Dialogue: 0,0:14:44.29,0:14:47.16,BottomCenter,,0,0,0,,这看起来就像多重赋值
Dialogue: 0,0:14:47.16,0:14:51.26,BottomCenter,,0,0,0,,当你说 x kama y 等于某对时
Dialogue: 0,0:14:51.70,0:14:53.39,BottomCenter,,0,0,0,,这里每个名字 x 和 y
Dialogue: 0,0:14:53.79,0:14:57.70,BottomCenter,,0,0,0,,绑定到某个对中的某个特定值
Dialogue: 0,0:15:00.52,0:15:02.97,BottomCenter,,0,0,0,,范围是另一种序列类型
Dialogue: 0,0:15:03.57,0:15:07.16,BottomCenter,,0,0,0,,这意味着它们是序列，但不是列表
Dialogue: 0,0:15:08.89,0:15:10.87,BottomCenter,,0,0,0,,范围代表
Dialogue: 0,0:15:11.12,0:15:14.00,BottomCenter,,0,0,0,,连续整数序列
Dialogue: 0,0:15:15.10,0:15:15.52,BottomCenter,,0,0,0,,实际上
Dialogue: 0,0:15:15.52,0:15:17.97,BottomCenter,,0,0,0,,它们可以表示各种整数序列
Dialogue: 0,0:15:17.97,0:15:20.12,BottomCenter,,0,0,0,,但我们只会关注那些
Dialogue: 0,0:15:20.12,0:15:21.60,BottomCenter,,0,0,0,,具有连续的整数
Dialogue: 0,0:15:21.60,0:15:23.10,BottomCenter,,0,0,0,,所以向上数
Dialogue: 0,0:15:24.37,0:15:27.97,BottomCenter,,0,0,0,,想象一条充满整数的无限数轴
Dialogue: 0,0:15:28.26,0:15:29.89,BottomCenter,,0,0,0,,这是一小片
Dialogue: 0,0:15:30.52,0:15:33.66,BottomCenter,,0,0,0,,安排的作用是挑选一个
Dialogue: 0,0:15:34.10,0:15:37.52,BottomCenter,,0,0,0,,这条长数轴内的有限长度
Dialogue: 0,0:15:38.20,0:15:41.92,BottomCenter,,0,0,0,,通过给出起始值和结束值
Dialogue: 0,0:15:43.57,0:15:46.66,BottomCenter,,0,0,0,,并选择之间的所有整数
Dialogue: 0,0:15:46.66,0:15:48.20,BottomCenter,,0,0,0,,递增顺序
Dialogue: 0,0:15:49.52,0:15:51.73,BottomCenter,,0,0,0,,现在我绘制的方式很重要
Dialogue: 0,0:15:52.66,0:15:57.20,BottomCenter,,0,0,0,,这两个都是 0.2 就在指示的数字之前
Dialogue: 0,0:15:57.57,0:15:59.37,BottomCenter,,0,0,0,,在数轴上
Dialogue: 0,0:15:59.97,0:16:05.37,BottomCenter,,0,0,0,,这意味着 -2 实际上包含在范围内
Dialogue: 0,0:16:05.73,0:16:07.33,BottomCenter,,0,0,0,,从-2到2
Dialogue: 0,0:16:07.87,0:16:10.29,BottomCenter,,0,0,0,,但2号不在范围内
Dialogue: 0,0:16:11.00,0:16:13.89,BottomCenter,,0,0,0,,所以它包括这个起始值
Dialogue: 0,0:16:14.00,0:16:16.87,BottomCenter,,0,0,0,,但不包括最终值
Dialogue: 0,0:16:17.92,0:16:19.37,BottomCenter,,0,0,0,,现在真是一件奇怪的事情
Dialogue: 0,0:16:19.73,0:16:22.07,BottomCenter,,0,0,0,,嗯，它实际上让很多事情变得更简单
Dialogue: 0,0:16:22.07,0:16:22.97,BottomCenter,,0,0,0,,准确地做到这一点
Dialogue: 0,0:16:22.97,0:16:23.76,BottomCenter,,0,0,0,,那样
Dialogue: 0,0:16:24.52,0:16:26.57,BottomCenter,,0,0,0,,你可以计算一个范围的长度
Dialogue: 0,0:16:26.57,0:16:27.92,BottomCenter,,0,0,0,,只需减去
Dialogue: 0,0:16:27.92,0:16:29.97,BottomCenter,,0,0,0,,起始值与结束值
Dialogue: 0,0:16:30.16,0:16:32.97,BottomCenter,,0,0,0,,所以二减负二等于四
Dialogue: 0,0:16:33.16,0:16:34.89,BottomCenter,,0,0,0,,这里有四个元素
Dialogue: 0,0:16:34.89,0:16:35.97,BottomCenter,,0,0,0,,如你看到的
Dialogue: 0,0:16:37.50,0:16:39.37,BottomCenter,,0,0,0,,元素选择也很容易
Dialogue: 0,0:16:39.52,0:16:42.52,BottomCenter,,0,0,0,,您只需获取起始值并添加索引
Dialogue: 0,0:16:42.60,0:16:44.12,BottomCenter,,0,0,0,,索引从零开始
Dialogue: 0,0:16:44.33,0:16:46.97,BottomCenter,,0,0,0,,所以元素索引零是-2
Dialogue: 0,0:16:47.16,0:16:48.73,BottomCenter,,0,0,0,,和元素索引 3
Dialogue: 0,0:16:49.07,0:16:51.60,BottomCenter,,0,0,0,,负2加三等于一
Dialogue: 0,0:16:53.66,0:16:55.87,BottomCenter,,0,0,0,,好的，它有元素选择的长度
Dialogue: 0,0:16:55.87,0:16:57.47,BottomCenter,,0,0,0,,所以它一定是一个序列
Dialogue: 0,0:16:57.57,0:16:59.10,BottomCenter,,0,0,0,,即使这不是一个列表
Dialogue: 0,0:16:59.52,0:17:00.57,BottomCenter,,0,0,0,,现在你如何转换
Dialogue: 0,0:17:00.57,0:17:02.79,BottomCenter,,0,0,0,,如果您想查看元素，请转到列表
Dialogue: 0,0:17:03.12,0:17:03.92,BottomCenter,,0,0,0,,出色地
Dialogue: 0,0:17:04.40,0:17:06.56,BottomCenter,,0,0,0,,你可以使用所谓的列表构造函数
Dialogue: 0,0:17:06.56,0:17:08.26,BottomCenter,,0,0,0,,这是一个内置函数
Dialogue: 0,0:17:08.70,0:17:10.20,BottomCenter,,0,0,0,,刚刚调用的成本清单
Dialogue: 0,0:17:10.36,0:17:12.59,BottomCenter,,0,0,0,,当你在任何其他序列上调用它时
Dialogue: 0,0:17:12.76,0:17:14.40,BottomCenter,,0,0,0,,它会给你一个列表
Dialogue: 0,0:17:14.52,0:17:17.36,BottomCenter,,0,0,0,,充满该序列的元素
Dialogue: 0,0:17:18.56,0:17:20.47,BottomCenter,,0,0,0,,所以范围本身并不是列表
Dialogue: 0,0:17:20.47,0:17:22.79,BottomCenter,,0,0,0,,但调用 list 确实会给你一个列表
Dialogue: 0,0:17:22.79,0:17:24.17,BottomCenter,,0,0,0,,所有这些元素
Dialogue: 0,0:17:24.90,0:17:26.47,BottomCenter,,0,0,0,,这是列表构造函数
Dialogue: 0,0:17:27.32,0:17:30.09,BottomCenter,,0,0,0,,现在范围的一个特殊功能是，如果您
Dialogue: 0,0:17:30.09,0:17:31.59,BottomCenter,,0,0,0,,省略其中一个数字
Dialogue: 0,0:17:31.59,0:17:33.36,BottomCenter,,0,0,0,,所以你只指定一个数字
Dialogue: 0,0:17:33.67,0:17:35.79,BottomCenter,,0,0,0,,这被视为最终值
Dialogue: 0,0:17:36.06,0:17:38.76,BottomCenter,,0,0,0,,隐式起始值为零
Dialogue: 0,0:17:39.06,0:17:42.93,BottomCenter,,0,0,0,,所以列出范围四是 0 1 2 3
Dialogue: 0,0:17:42.93,0:17:45.36,BottomCenter,,0,0,0,,包括零但不包括四
Dialogue: 0,0:17:49.09,0:17:49.76,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:17:49.76,0:17:53.59,BottomCenter,,0,0,0,,所以如果我创建一个从五到八的范围
Dialogue: 0,0:17:53.97,0:17:56.17,BottomCenter,,0,0,0,,这不是一个列表，而是一个范围
Dialogue: 0,0:17:56.90,0:18:01.06,BottomCenter,,0,0,0,,如果我想要一个列表，我必须调用该值的列表
Dialogue: 0,0:18:01.26,0:18:01.90,BottomCenter,,0,0,0,,此时
Dialogue: 0,0:18:01.90,0:18:04.13,BottomCenter,,0,0,0,,我会确切地看到里面有什么元素
Dialogue: 0,0:18:04.40,0:18:06.06,BottomCenter,,0,0,0,,现在如果我知道范围是什么
Dialogue: 0,0:18:06.13,0:18:08.36,BottomCenter,,0,0,0,,我已经知道现在是五六七了
Dialogue: 0,0:18:08.79,0:18:10.90,BottomCenter,,0,0,0,,但如果我想要一张支票
Dialogue: 0,0:18:10.97,0:18:13.56,BottomCenter,,0,0,0,,并确保它包括起始
Dialogue: 0,0:18:13.56,0:18:16.40,BottomCenter,,0,0,0,,值但不包括最终值
Dialogue: 0,0:18:16.40,0:18:18.00,BottomCenter,,0,0,0,,我可以打电话给名单
Dialogue: 0,0:18:18.26,0:18:19.93,BottomCenter,,0,0,0,,确定地发现
Dialogue: 0,0:18:21.29,0:18:23.36,BottomCenter,,0,0,0,,现在范围最多为四个
Dialogue: 0,0:18:24.06,0:18:26.79,BottomCenter,,0,0,0,,是一个从零开始到四的范围
Dialogue: 0,0:18:27.00,0:18:28.79,BottomCenter,,0,0,0,,如果我列出这些值
Dialogue: 0,0:18:28.79,0:18:31.97,BottomCenter,,0,0,0,,我会看到它是零一二三
Dialogue: 0,0:18:33.20,0:18:35.73,BottomCenter,,0,0,0,,那么我们可以用这个范围做什么
Dialogue: 0,0:18:36.56,0:18:38.26,BottomCenter,,0,0,0,,嗯，有很多情况
Dialogue: 0,0:18:38.29,0:18:39.50,BottomCenter,,0,0,0,,你想要的顺序
Dialogue: 0,0:18:39.50,0:18:43.13,BottomCenter,,0,0,0,,恰好是一个递增整数的序列
Dialogue: 0,0:18:45.20,0:18:47.70,BottomCenter,,0,0,0,,所以如果我想要一些下面的所有整数
Dialogue: 0,0:18:47.70,0:18:48.76,BottomCenter,,0,0,0,,某个数字 n
Dialogue: 0,0:18:49.40,0:18:53.09,BottomCenter,,0,0,0,,我可以通过跟踪总数来做到这一点
Dialogue: 0,0:18:54.29,0:18:56.59,BottomCenter,,0,0,0,,抓取每个元素 I
Dialogue: 0,0:18:57.00,0:19:00.93,BottomCenter,,0,0,0,,范围最多但不包括 n
Dialogue: 0,0:19:01.56,0:19:04.09,BottomCenter,,0,0,0,,并将总计更改为总计加上 I
Dialogue: 0,0:19:05.09,0:19:06.73,BottomCenter,,0,0,0,,然后返回总数
Dialogue: 0,0:19:11.56,0:19:15.09,BottomCenter,,0,0,0,,此时如果我低于五
Dialogue: 0,0:19:15.73,0:19:18.86,BottomCenter,,0,0,0,,我将添加一、二、三、四和零
Dialogue: 0,0:19:19.09,0:19:20.20,BottomCenter,,0,0,0,,这会给我标签
Dialogue: 0,0:19:24.13,0:19:28.52,BottomCenter,,0,0,0,,现在有些情况你实际上并不关心
Dialogue: 0,0:19:29.00,0:19:30.90,BottomCenter,,0,0,0,,关于整数本身
Dialogue: 0,0:19:30.90,0:19:34.20,BottomCenter,,0,0,0,,你只想做某事固定次数
Dialogue: 0,0:19:34.79,0:19:37.20,BottomCenter,,0,0,0,,所以如果我想
Dialogue: 0,0:19:38.86,0:19:39.67,BottomCenter,,0,0,0,,说
Dialogue: 0,0:19:40.50,0:19:41.86,BottomCenter,,0,0,0,,熊去吧
Dialogue: 0,0:19:44.26,0:19:47.90,BottomCenter,,0,0,0,,是典型写法的三倍
Dialogue: 0,0:19:47.93,0:19:50.40,BottomCenter,,0,0,0,,是这样的四个语句
Dialogue: 0,0:19:52.06,0:19:54.93,BottomCenter,,0,0,0,,或者如果我现在欢呼它会说熊走吧熊
Dialogue: 0,0:19:54.93,0:19:56.47,BottomCenter,,0,0,0,,现在去熊吧
Dialogue: 0,0:19:56.47,0:19:56.90,BottomCenter,,0,0,0,,范围
Dialogue: 0,0:19:56.90,0:19:59.59,BottomCenter,,0,0,0,,三表示范围内有三个元素
Dialogue: 0,0:20:01.79,0:20:04.76,BottomCenter,,0,0,0,,我们给每个元素命名但是
Dialogue: 0,0:20:05.06,0:20:06.90,BottomCenter,,0,0,0,,我们实际上并不关心那个名字是什么
Dialogue: 0,0:20:06.90,0:20:08.76,BottomCenter,,0,0,0,,因为我们没有在任何地方使用它
Dialogue: 0,0:20:09.47,0:20:12.73,BottomCenter,,0,0,0,,所以一个约定是使用一个下划线
Dialogue: 0,0:20:12.73,0:20:14.73,BottomCenter,,0,0,0,,字符或空白
Dialogue: 0,0:20:14.97,0:20:15.73,BottomCenter,,0,0,0,,只是只是
Dialogue: 0,0:20:15.73,0:20:17.97,BottomCenter,,0,0,0,,让其他程序员知道你实际上不是
Dialogue: 0,0:20:17.97,0:20:19.70,BottomCenter,,0,0,0,,将在任何地方使用这个名字
Dialogue: 0,0:20:20.50,0:20:22.79,BottomCenter,,0,0,0,,如果我把 x 放在那里就可以了
Dialogue: 0,0:20:22.93,0:20:24.40,BottomCenter,,0,0,0,,但我永远不会用那个x
Dialogue: 0,0:20:24.40,0:20:26.67,BottomCenter,,0,0,0,,所以我在那里放什么并不重要
Dialogue: 0,0:20:27.00,0:20:29.90,BottomCenter,,0,0,0,,这表明你根本不在乎
Dialogue: 0,0:20:31.36,0:20:33.32,BottomCenter,,0,0,0,,我们将再举一个例子
Dialogue: 0,0:20:33.32,0:20:34.73,BottomCenter,,0,0,0,,我会让你做一些练习
Dialogue: 0,0:20:34.73,0:20:35.56,BottomCenter,,0,0,0,,我要让你写
Dialogue: 0,0:20:35.56,0:20:37.00,BottomCenter,,0,0,0,,迭代和递归
Dialogue: 0,0:20:37.00,0:20:37.90,BottomCenter,,0,0,0,,所以你可以看到
Dialogue: 0,0:20:38.06,0:20:41.00,BottomCenter,,0,0,0,,如何同时思考这两件事
Dialogue: 0,0:20:41.73,0:20:43.97,BottomCenter,,0,0,0,,好吧，这是我希望我们合作的第一个项目
Dialogue: 0,0:20:44.79,0:20:48.09,BottomCenter,,0,0,0,,我希望我们写一个递归函数求和
Dialogue: 0,0:20:48.26,0:20:51.20,BottomCenter,,0,0,0,,这需要我们输入一个数字列表
Dialogue: 0,0:20:51.36,0:20:53.73,BottomCenter,,0,0,0,,并将它们全部加起来并给我总和
Dialogue: 0,0:20:54.17,0:20:54.90,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:20:54.90,0:20:55.52,BottomCenter,,0,0,0,,这是一个很好的练习
Dialogue: 0,0:20:55.52,0:20:57.70,BottomCenter,,0,0,0,,如果你想做一个，只需迭代地执行此操作
Dialogue: 0,0:20:57.97,0:20:58.86,BottomCenter,,0,0,0,,几乎所有的
Dialogue: 0,0:20:58.86,0:21:01.13,BottomCenter,,0,0,0,,我们递归地做将会有一个迭代组件
Dialogue: 0,0:21:01.13,0:21:02.13,BottomCenter,,0,0,0,,反之亦然
Dialogue: 0,0:21:02.26,0:21:03.36,BottomCenter,,0,0,0,,他们可能会更容易一些
Dialogue: 0,0:21:03.36,0:21:04.52,BottomCenter,,0,0,0,,他们可能有点难
Dialogue: 0,0:21:04.52,0:21:05.79,BottomCenter,,0,0,0,,或者它们可能是相同的
Dialogue: 0,0:21:06.36,0:21:07.29,BottomCenter,,0,0,0,,所以如果你想休息一下
Dialogue: 0,0:21:07.29,0:21:08.59,BottomCenter,,0,0,0,,继续吧，写这篇采访
Dialogue: 0,0:21:08.59,0:21:09.73,BottomCenter,,0,0,0,,这是一个很好的练习
Dialogue: 0,0:21:10.20,0:21:12.17,BottomCenter,,0,0,0,,好的，首先要做的就是
Dialogue: 0,0:21:12.17,0:21:12.73,BottomCenter,,0,0,0,,看看
Dialogue: 0,0:21:12.73,0:21:14.76,BottomCenter,,0,0,0,,无论您何时编写代码，这始终是正确的
Dialogue: 0,0:21:14.76,0:21:16.52,BottomCenter,,0,0,0,,但当您编写或光标代码时更是如此
Dialogue: 0,0:21:16.52,0:21:18.29,BottomCenter,,0,0,0,,你必须认真考虑
Dialogue: 0,0:21:18.47,0:21:20.00,BottomCenter,,0,0,0,,你想做什么
Dialogue: 0,0:21:20.29,0:21:22.70,BottomCenter,,0,0,0,,所以考虑一下递归定义
Dialogue: 0,0:21:22.93,0:21:26.67,BottomCenter,,0,0,0,,两部分基本情况，然后是递归情况
Dialogue: 0,0:21:26.67,0:21:27.59,BottomCenter,,0,0,0,,那么这里的基本情况是什么
Dialogue: 0,0:21:27.59,0:21:29.13,BottomCenter,,0,0,0,,我能想到两种可能
Dialogue: 0,0:21:29.26,0:21:29.59,BottomCenter,,0,0,0,,一个是
Dialogue: 0,0:21:29.59,0:21:32.13,BottomCenter,,0,0,0,,我给你一个列表，其中只有一个元素
Dialogue: 0,0:21:32.17,0:21:35.17,BottomCenter,,0,0,0,,该列表中所有元素的总和是多少
Dialogue: 0,0:21:35.36,0:21:36.47,BottomCenter,,0,0,0,,只是那一个元素
Dialogue: 0,0:21:36.70,0:21:37.97,BottomCenter,,0,0,0,,另一个基本情况是什么
Dialogue: 0,0:21:38.13,0:21:41.86,BottomCenter,,0,0,0,,是的，就像以前一样，如果列表为空
Dialogue: 0,0:21:41.93,0:21:42.86,BottomCenter,,0,0,0,,我们来做那个吧
Dialogue: 0,0:21:42.86,0:21:44.09,BottomCenter,,0,0,0,,这样我们就可以继续进行交易
Dialogue: 0,0:21:44.09,0:21:45.26,BottomCenter,,0,0,0,,与空列表
Dialogue: 0,0:21:45.36,0:21:47.59,BottomCenter,,0,0,0,,那么现在你要问的问题是什么
Dialogue: 0,0:21:47.70,0:21:49.06,BottomCenter,,0,0,0,,我对空列表的总和
Dialogue: 0,0:21:49.06,0:21:50.93,BottomCenter,,0,0,0,,我认为返回零是合理的
Dialogue: 0,0:21:50.93,0:21:53.67,BottomCenter,,0,0,0,,我们可以说所有这些元素中的一些元素为零
Dialogue: 0,0:21:53.67,0:21:55.26,BottomCenter,,0,0,0,,所以让我们继续编写基本案例
Dialogue: 0,0:21:55.52,0:21:58.13,BottomCenter,,0,0,0,,如果列表等于空列表，那么
Dialogue: 0,0:21:58.70,0:21:59.67,BottomCenter,,0,0,0,,得分回来 得分回来
Dialogue: 0,0:21:59.67,0:22:00.29,BottomCenter,,0,0,0,,我也可以说
Dialogue: 0,0:22:00.29,0:22:02.59,BottomCenter,,0,0,0,,如果列表的长度等于零
Dialogue: 0,0:22:02.79,0:22:03.59,BottomCenter,,0,0,0,,那会有
Dialogue: 0,0:22:04.06,0:22:05.67,BottomCenter,,0,0,0,,也测试了空列表
Dialogue: 0,0:22:05.76,0:22:07.47,BottomCenter,,0,0,0,,退货不
Dialogue: 0,0:22:07.47,0:22:10.86,BottomCenter,,0,0,0,,不要忘记您正在返回值
Dialogue: 0,0:22:10.90,0:22:14.52,BottomCenter,,0,0,0,,因为你正在递归地构建一个表达式
Dialogue: 0,0:22:15.17,0:22:18.06,BottomCenter,,0,0,0,,正如我们在阶乘和字符串反转中看到的那样
Dialogue: 0,0:22:18.06,0:22:20.52,BottomCenter,,0,0,0,,所以这里要非常非常小心好吗
Dialogue: 0,0:22:20.70,0:22:22.93,BottomCenter,,0,0,0,,递归 递归的定义是什么
Dialogue: 0,0:22:23.73,0:22:26.40,BottomCenter,,0,0,0,,那么，将二四一加五相加是什么意思
Dialogue: 0,0:22:26.86,0:22:29.20,BottomCenter,,0,0,0,,好吧，思考它的一种方法是
Dialogue: 0,0:22:29.56,0:22:33.29,BottomCenter,,0,0,0,,我所有这些元素的总和是二加
Dialogue: 0,0:22:33.29,0:22:35.90,BottomCenter,,0,0,0,,好吧，无论列表中的其余部分是什么
Dialogue: 0,0:22:35.97,0:22:38.06,BottomCenter,,0,0,0,,所以我可以剥掉第一个元素
Dialogue: 0,0:22:38.17,0:22:42.06,BottomCenter,,0,0,0,,保留它并将其添加到我的五分之一的总结中
Dialogue: 0,0:22:42.13,0:22:43.32,BottomCenter,,0,0,0,,是的，听起来不错
Dialogue: 0,0:22:43.32,0:22:45.86,BottomCenter,,0,0,0,,顺便说一句，这听起来很像阶乘
Dialogue: 0,0:22:46.06,0:22:47.90,BottomCenter,,0,0,0,,右和阶乘作为结束时间
Dialogue: 0,0:22:47.90,0:22:49.97,BottomCenter,,0,0,0,,无论其他一切的答案是什么
Dialogue: 0,0:22:50.00,0:22:52.52,BottomCenter,,0,0,0,,所以在这里我只是采用而不是装饰一个值
Dialogue: 0,0:22:52.67,0:22:53.93,BottomCenter,,0,0,0,,列表中的一个元素
Dialogue: 0,0:22:53.93,0:22:54.97,BottomCenter,,0,0,0,,然后总结其他所有内容
Dialogue: 0,0:22:54.97,0:22:56.76,BottomCenter,,0,0,0,,这有点像我们对反转所做的
Dialogue: 0,0:22:56.97,0:22:58.56,BottomCenter,,0,0,0,,我们从列表中删除了一个元素
Dialogue: 0,0:22:58.59,0:22:59.52,BottomCenter,,0,0,0,,我们把它放在最后
Dialogue: 0,0:22:59.52,0:23:01.59,BottomCenter,,0,0,0,,然后我们把前面的一切都颠倒过来
Dialogue: 0,0:23:01.73,0:23:02.67,BottomCenter,,0,0,0,,同样的事情在这里
Dialogue: 0,0:23:03.06,0:23:04.29,BottomCenter,,0,0,0,,好吧，所以我要做的是
Dialogue: 0,0:23:04.29,0:23:05.93,BottomCenter,,0,0,0,,剥掉第一个元素
Dialogue: 0,0:23:06.06,0:23:08.06,BottomCenter,,0,0,0,,然后我要补充一点
Dialogue: 0,0:23:08.17,0:23:10.52,BottomCenter,,0,0,0,,到其他一切的递归调用
Dialogue: 0,0:23:10.52,0:23:12.79,BottomCenter,,0,0,0,,好的，这应该很简单
Dialogue: 0,0:23:13.13,0:23:16.13,BottomCenter,,0,0,0,,所以如果 l 空列表返回零，否则
Dialogue: 0,0:23:16.36,0:23:18.40,BottomCenter,,0,0,0,,抓取零元素
Dialogue: 0,0:23:18.86,0:23:22.20,BottomCenter,,0,0,0,,并递归地添加到其他所有内容中
Dialogue: 0,0:23:22.20,0:23:23.20,BottomCenter,,0,0,0,,用我的诗篇呼唤
Dialogue: 0,0:23:23.20,0:23:26.00,BottomCenter,,0,0,0,,所以它开始了一个冒号运算符说
Dialogue: 0,0:23:26.00,0:23:27.00,BottomCenter,,0,0,0,,开始于
Dialogue: 0,0:23:27.13,0:23:29.93,BottomCenter,,0,0,0,,位置一是列表的第二个元素
Dialogue: 0,0:23:30.06,0:23:31.32,BottomCenter,,0,0,0,,直到最后
Dialogue: 0,0:23:31.86,0:23:32.86,BottomCenter,,0,0,0,,抓住那个清单
Dialogue: 0,0:23:32.93,0:23:34.90,BottomCenter,,0,0,0,,递归地调用我的总和
Dialogue: 0,0:23:34.90,0:23:36.86,BottomCenter,,0,0,0,,然后这最终会返回
Dialogue: 0,0:23:37.29,0:23:39.56,BottomCenter,,0,0,0,,四加五加一等于 10
Dialogue: 0,0:23:39.56,0:23:42.73,BottomCenter,,0,0,0,,它将把它加到二，我就会得到答案
Dialogue: 0,0:23:42.73,0:23:45.52,BottomCenter,,0,0,0,,再说一遍，返回那里很重要
Dialogue: 0,0:23:45.52,0:23:47.47,BottomCenter,,0,0,0,,你正在构建一个表达式
Dialogue: 0,0:23:47.76,0:23:51.56,BottomCenter,,0,0,0,,你必须将一些东西返回到以前的状态
Dialogue: 0,0:23:51.79,0:23:52.97,BottomCenter,,0,0,0,,函数调用
Dialogue: 0,0:23:53.06,0:23:56.26,BottomCenter,,0,0,0,,无论是递归还是谁从
Dialogue: 0,0:23:56.67,0:23:57.47,BottomCenter,,0,0,0,,外部
Dialogue: 0,0:23:58.09,0:24:00.40,BottomCenter,,0,0,0,,好吧，让我们确保我们理解它是如何工作的
Dialogue: 0,0:24:00.40,0:24:01.20,BottomCenter,,0,0,0,,让我们
Dialogue: 0,0:24:01.32,0:24:04.06,BottomCenter,,0,0,0,,通过此列表查看一个示例，其中包含四个
Dialogue: 0,0:24:04.06,0:24:07.20,BottomCenter,,0,0,0,,元素 我的和 2 4 1 5
Dialogue: 0,0:24:07.20,0:24:08.70,BottomCenter,,0,0,0,,好吧，让我们进入代码
Dialogue: 0,0:24:08.79,0:24:09.90,BottomCenter,,0,0,0,,列表不为空
Dialogue: 0,0:24:09.90,0:24:11.56,BottomCenter,,0,0,0,,所以剥掉第一个元素
Dialogue: 0,0:24:11.56,0:24:14.56,BottomCenter,,0,0,0,,并将其添加到其他所有内容的递归调用中
Dialogue: 0,0:24:14.56,0:24:17.32,BottomCenter,,0,0,0,,所以这是 2 加上我的 4 1 5 之和
Dialogue: 0,0:24:17.86,0:24:19.50,BottomCenter,,0,0,0,,好吧，我完成了吗？
Dialogue: 0,0:24:19.67,0:24:22.40,BottomCenter,,0,0,0,,我想添加两件事，但那是一个函数调用
Dialogue: 0,0:24:22.40,0:24:24.36,BottomCenter,,0,0,0,,所以我最终不得不去调用一些函数
Dialogue: 0,0:24:24.50,0:24:25.59,BottomCenter,,0,0,0,,并得到答案
Dialogue: 0,0:24:25.59,0:24:26.79,BottomCenter,,0,0,0,,然后我就可以回来了
Dialogue: 0,0:24:27.17,0:24:29.09,BottomCenter,,0,0,0,,好吧，我的 4 1 5 的总和是多少
Dialogue: 0,0:24:29.20,0:24:30.93,BottomCenter,,0,0,0,,来到这里，这里不是空的
Dialogue: 0,0:24:30.97,0:24:32.09,BottomCenter,,0,0,0,,剥离第一个元素
Dialogue: 0,0:24:32.09,0:24:34.09,BottomCenter,,0,0,0,,对接下来的两个元素进行递归调用
Dialogue: 0,0:24:34.26,0:24:36.50,BottomCenter,,0,0,0,,四加上我的一五之和
Dialogue: 0,0:24:36.50,0:24:38.73,BottomCenter,,0,0,0,,我完成了吗？不，我仍然需要这个
Dialogue: 0,0:24:39.06,0:24:41.26,BottomCenter,,0,0,0,,剥离第一个元素递归调用
Dialogue: 0,0:24:41.32,0:24:43.29,BottomCenter,,0,0,0,,剥离第一个元素递归调用
Dialogue: 0,0:24:43.29,0:24:45.52,BottomCenter,,0,0,0,,啊哈，你可以看到我们已经到达那里了
Dialogue: 0,0:24:45.52,0:24:47.67,BottomCenter,,0,0,0,,现在这个小家伙已经完成了
Dialogue: 0,0:24:47.67,0:24:50.06,BottomCenter,,0,0,0,,为什么因为它符合基本情况
Dialogue: 0,0:24:50.32,0:24:52.32,BottomCenter,,0,0,0,,并注意基本情况不需要做任何工作
Dialogue: 0,0:24:52.32,0:24:53.50,BottomCenter,,0,0,0,,它达到零
Dialogue: 0,0:24:53.97,0:24:57.32,BottomCenter,,0,0,0,,所以现在五个加上我的一些空列表说
Dialogue: 0,0:24:57.32,0:24:59.90,BottomCenter,,0,0,0,,请向我的一些空列表返回零
Dialogue: 0,0:24:59.90,0:25:02.20,BottomCenter,,0,0,0,,现在我有一个表达式五
Dialogue: 0,0:25:02.67,0:25:05.20,BottomCenter,,0,0,0,,现在我有了五个总和的答案
Dialogue: 0,0:25:05.26,0:25:08.06,BottomCenter,,0,0,0,,这样我就可以把它加到我的五的总和上
Dialogue: 0,0:25:08.20,0:25:11.93,BottomCenter,,0,0,0,,现在我已经知道一五之和是六了
Dialogue: 0,0:25:12.17,0:25:15.97,BottomCenter,,0,0,0,,现在我有了 4 1 5 之和的答案，它是 10
Dialogue: 0,0:25:16.06,0:25:20.67,BottomCenter,,0,0,0,,现在我终于有了答案，那就是 12
Dialogue: 0,0:25:21.70,0:25:22.36,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:25:22.36,0:25:23.36,BottomCenter,,0,0,0,,好吧，让我们练习一下
Dialogue: 0,0:25:23.36,0:25:25.67,BottomCenter,,0,0,0,,我会给你们两个背靠背的
Dialogue: 0,0:25:25.97,0:25:28.67,BottomCenter,,0,0,0,,第一个是正确的迭代函数
Dialogue: 0,0:25:28.97,0:25:31.17,BottomCenter,,0,0,0,,这需要我们输入一个整数结尾
Dialogue: 0,0:25:31.17,0:25:32.79,BottomCenter,,0,0,0,,只是一个正整数
Dialogue: 0,0:25:34.00,0:25:36.86,BottomCenter,,0,0,0,,并返回第一个结束整数的总和
Dialogue: 0,0:25:36.86,0:25:38.26,BottomCenter,,0,0,0,,例如，有五个
Dialogue: 0,0:25:38.26,0:25:40.40,BottomCenter,,0,0,0,,将返回一加二加二加四加五
Dialogue: 0,0:25:40.47,0:25:42.36,BottomCenter,,0,0,0,,所以这看起来很像阶乘
Dialogue: 0,0:25:42.56,0:25:45.70,BottomCenter,,0,0,0,,所以请迭代 while 循环四循环
Dialogue: 0,0:25:45.70,0:25:47.06,BottomCenter,,0,0,0,,我不在乎你怎么做
Dialogue: 0,0:25:47.29,0:25:48.97,BottomCenter,,0,0,0,,然后当你完成后
Dialogue: 0,0:25:49.13,0:25:53.20,BottomCenter,,0,0,0,,请做完全相同的事情，但递归地做
Dialogue: 0,0:25:53.20,0:25:55.20,BottomCenter,,0,0,0,,好的，背靠背进行两次练习
Dialogue: 0,0:25:55.76,0:25:56.86,BottomCenter,,0,0,0,,继续并暂停视频
Dialogue: 0,0:25:57.09,0:25:58.56,BottomCenter,,0,0,0,,花一些时间做这两件事
Dialogue: 0,0:25:59.00,0:25:59.90,BottomCenter,,0,0,0,,我认为迭代
Dialogue: 0,0:26:00.00,0:26:01.56,BottomCenter,,0,0,0,,你应该能够很快完成
Dialogue: 0,0:26:01.67,0:26:02.36,BottomCenter,,0,0,0,,然后又
Dialogue: 0,0:26:02.36,0:26:04.56,BottomCenter,,0,0,0,,思考递归调用的本质
Dialogue: 0,0:26:04.56,0:26:06.40,BottomCenter,,0,0,0,,基本情况递归调用
Dialogue: 0,0:26:06.50,0:26:09.20,BottomCenter,,0,0,0,,然后回来我们会同时解决这个问题
Dialogue: 0,0:26:12.17,0:26:15.26,BottomCenter,,0,0,0,,好吧，我希望你能得到这两个问题的答案
Dialogue: 0,0:26:15.56,0:26:17.32,BottomCenter,,0,0,0,,所以让我向你展示我的解决方案
Dialogue: 0,0:26:17.73,0:26:19.32,BottomCenter,,0,0,0,,呃迭代的
Dialogue: 0,0:26:19.59,0:26:20.76,BottomCenter,,0,0,0,,呃，所以一些iter
Dialogue: 0,0:26:20.76,0:26:23.00,BottomCenter,,0,0,0,,我要区分两种类型的呃
Dialogue: 0,0:26:23.00,0:26:24.52,BottomCenter,,0,0,0,,函数作为输入和
Dialogue: 0,0:26:24.52,0:26:25.90,BottomCenter,,0,0,0,,再说一次我不会检查我是否
Dialogue: 0,0:26:25.90,0:26:26.76,BottomCenter,,0,0,0,,作为正积分
Dialogue: 0,0:26:26.76,0:26:27.97,BottomCenter,,0,0,0,,我们不会担心这个
Dialogue: 0,0:26:28.06,0:26:30.70,BottomCenter,,0,0,0,,我将把一个变量初始化为一些
Dialogue: 0,0:26:31.17,0:26:31.40,BottomCenter,,0,0,0,,对不起
Dialogue: 0,0:26:31.40,0:26:34.09,BottomCenter,,0,0,0,,我将初始化一个名为 some 的变量为零
Dialogue: 0,0:26:34.20,0:26:35.79,BottomCenter,,0,0,0,,然后我要迭代
Dialogue: 0,0:26:36.17,0:26:38.17,BottomCenter,,0,0,0,,值 0 和 n 之间
Dialogue: 0,0:26:38.17,0:26:40.00,BottomCenter,,0,0,0,,请注意，这是一比一的差距
Dialogue: 0,0:26:40.00,0:26:41.70,BottomCenter,,0,0,0,,可能会让你们中的一些人感到困扰的错误
Dialogue: 0,0:26:41.93,0:26:43.79,BottomCenter,,0,0,0,,如果我想使用 for 循环
Dialogue: 0,0:26:44.47,0:26:46.26,BottomCenter,,0,0,0,,在 0 和 n 之间迭代
Dialogue: 0,0:26:46.26,0:26:48.00,BottomCenter,,0,0,0,,我必须从零到n加一
Dialogue: 0,0:26:48.00,0:26:50.79,BottomCenter,,0,0,0,,因为最后一个值不包含在内
Dialogue: 0,0:26:51.50,0:26:53.06,BottomCenter,,0,0,0,,所以我的价值
Dialogue: 0,0:26:53.13,0:26:54.93,BottomCenter,,0,0,0,,在 for 的体内
Dialogue: 0,0:26:54.93,0:26:57.50,BottomCenter,,0,0,0,,循环将采用值 0 1 2 3 4
Dialogue: 0,0:26:57.50,0:27:00.29,BottomCenter,,0,0,0,,直到n我想用这些做什么
Dialogue: 0,0:27:00.36,0:27:01.56,BottomCenter,,0,0,0,,我想总结一下
Dialogue: 0,0:27:01.73,0:27:04.09,BottomCenter,,0,0,0,,所以我想说 some 等于之前的总和
Dialogue: 0,0:27:04.09,0:27:07.00,BottomCenter,,0,0,0,,另外我顺便注意到与阶乘不同
Dialogue: 0,0:27:07.17,0:27:09.59,BottomCenter,,0,0,0,,我们有效地初始化 b 的地方
Dialogue: 0,0:27:09.59,0:27:11.76,BottomCenter,,0,0,0,,因为我们是计算产品
Dialogue: 0,0:27:11.76,0:27:13.90,BottomCenter,,0,0,0,,一是产品的标识
Dialogue: 0,0:27:14.00,0:27:16.70,BottomCenter,,0,0,0,,当然，在某些情况下我们必须将其初始化为零
Dialogue: 0,0:27:16.90,0:27:21.97,BottomCenter,,0,0,0,,好的，每次迭代运行一些我们添加 0 1 2 3 4 5
Dialogue: 0,0:27:22.00,0:27:23.79,BottomCenter,,0,0,0,,然后最终我们返回一些
Dialogue: 0,0:27:23.79,0:27:25.17,BottomCenter,,0,0,0,,在最后这里
Dialogue: 0,0:27:25.20,0:27:26.93,BottomCenter,,0,0,0,,并且相对简单
Dialogue: 0,0:27:27.00,0:27:28.52,BottomCenter,,0,0,0,,现在你可能已经做了一点 while 循环
Dialogue: 0,0:27:28.56,0:27:29.67,BottomCenter,,0,0,0,,完全没问题
Dialogue: 0,0:27:30.13,0:27:32.26,BottomCenter,,0,0,0,,我认为四个循环可能更干净
Dialogue: 0,0:27:32.26,0:27:34.13,BottomCenter,,0,0,0,,因为如果你计算整数
Dialogue: 0,0:27:34.13,0:27:35.36,BottomCenter,,0,0,0,,零到某个数字
Dialogue: 0,0:27:35.67,0:27:37.20,BottomCenter,,0,0,0,,你没有理由和野生动物打交道
Dialogue: 0,0:27:37.20,0:27:39.20,BottomCenter,,0,0,0,,你没有理由初始化变量
Dialogue: 0,0:27:39.73,0:27:41.79,BottomCenter,,0,0,0,,执行条件，然后递增变量
Dialogue: 0,0:27:42.00,0:27:43.52,BottomCenter,,0,0,0,,让 python 为你做繁重的工作
Dialogue: 0,0:27:43.52,0:27:45.26,BottomCenter,,0,0,0,,所以我认为可能是四个
Dialogue: 0,0:27:45.32,0:27:48.32,BottomCenter,,0,0,0,,这个版本有点紧，有点米
Dialogue: 0,0:27:48.76,0:27:52.00,BottomCenter,,0,0,0,,因为它非常适合确切的范围
Dialogue: 0,0:27:52.29,0:27:53.20,BottomCenter,,0,0,0,,为您设计
Dialogue: 0,0:27:53.76,0:27:57.36,BottomCenter,,0,0,0,,好吧，现在让我们做一下递归定义
Dialogue: 0,0:27:58.59,0:27:59.86,BottomCenter,,0,0,0,,基本情况很简单
Dialogue: 0,0:28:00.47,0:28:02.26,BottomCenter,,0,0,0,,如果 end 为零则返回零
Dialogue: 0,0:28:02.26,0:28:05.86,BottomCenter,,0,0,0,,是的，如果我要求你对前零数求和
Dialogue: 0,0:28:06.00,0:28:07.47,BottomCenter,,0,0,0,,我已经无事可做了
Dialogue: 0,0:28:07.47,0:28:09.06,BottomCenter,,0,0,0,,好的，很好，所以这很容易
Dialogue: 0,0:28:09.29,0:28:11.47,BottomCenter,,0,0,0,,那么递归定义是什么
Dialogue: 0,0:28:11.52,0:28:12.52,BottomCenter,,0,0,0,,好吧，走着瞧
Dialogue: 0,0:28:12.97,0:28:16.59,BottomCenter,,0,0,0,,n 的总和是
Dialogue: 0,0:28:17.97,0:28:19.00,BottomCenter,,0,0,0,,让我们从这边开始
Dialogue: 0,0:28:19.00,0:28:20.50,BottomCenter,,0,0,0,,五加四加二三一
Dialogue: 0,0:28:20.56,0:28:23.56,BottomCenter,,0,0,0,,所以我们肯定可以同意这是五加
Dialogue: 0,0:28:23.56,0:28:25.76,BottomCenter,,0,0,0,,四的递归
Dialogue: 0,0:28:26.17,0:28:27.56,BottomCenter,,0,0,0,,四就是四
Dialogue: 0,0:28:27.97,0:28:30.17,BottomCenter,,0,0,0,,递归调用 递归调用三
Dialogue: 0,0:28:30.20,0:28:31.59,BottomCenter,,0,0,0,,它就像阶乘一样
Dialogue: 0,0:28:31.59,0:28:34.00,BottomCenter,,0,0,0,,只是我们是求和而不是相乘
Dialogue: 0,0:28:34.00,0:28:34.86,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:28:34.93,0:28:37.00,BottomCenter,,0,0,0,,让我们看看递归调用是什么样的
Dialogue: 0,0:28:37.17,0:28:40.40,BottomCenter,,0,0,0,,所以如果 n 不为零，我将取数字 n
Dialogue: 0,0:28:40.52,0:28:42.59,BottomCenter,,0,0,0,,我要把它加起来而不是相乘
Dialogue: 0,0:28:42.59,0:28:44.79,BottomCenter,,0,0,0,,递归调用 n 减一
Dialogue: 0,0:28:45.40,0:28:46.29,BottomCenter,,0,0,0,,最终
Dialogue: 0,0:28:46.76,0:28:48.52,BottomCenter,,0,0,0,,所以我会在这里进行递归调用
Dialogue: 0,0:28:48.52,0:28:51.09,BottomCenter,,0,0,0,,我会继续构建这个表达式，这样它就可以了
Dialogue: 0,0:28:51.32,0:28:52.47,BottomCenter,,0,0,0,,加n减一
Dialogue: 0,0:28:52.47,0:28:54.76,BottomCenter,,0,0,0,,加n减2一路向下启动
Dialogue: 0,0:28:55.17,0:28:57.17,BottomCenter,,0,0,0,,直到我们达到零
Dialogue: 0,0:28:57.32,0:28:58.29,BottomCenter,,0,0,0,,基本情况
Dialogue: 0,0:28:58.59,0:29:00.36,BottomCenter,,0,0,0,,好的，很好，我希望你能明白
Dialogue: 0,0:29:00.36,0:29:02.79,BottomCenter,,0,0,0,,顺便说一句，你们中的一些人可能会遇到错误
Dialogue: 0,0:29:03.26,0:29:05.97,BottomCenter,,0,0,0,,python或jupiter笔记本说递归
Dialogue: 0,0:29:07.00,0:29:08.20,BottomCenter,,0,0,0,,超过长度
Dialogue: 0,0:29:08.32,0:29:11.13,BottomCenter,,0,0,0,,那是因为它有点像无限循环
Dialogue: 0,0:29:11.32,0:29:14.00,BottomCenter,,0,0,0,,你继续递归递归调用
Dialogue: 0,0:29:14.00,0:29:15.76,BottomCenter,,0,0,0,,它没有抓住你的基本情况
Dialogue: 0,0:29:15.90,0:29:17.97,BottomCenter,,0,0,0,,它有点等同于它的迭代
Dialogue: 0,0:29:17.97,0:29:19.47,BottomCenter,,0,0,0,,你没有停止循环
Dialogue: 0,0:29:19.67,0:29:21.47,BottomCenter,,0,0,0,,这只是意味着你的逻辑有问题
Dialogue: 0,0:29:21.47,0:29:22.86,BottomCenter,,0,0,0,,或者你的代码中有一点错误
Dialogue: 0,0:29:22.86,0:29:23.86,BottomCenter,,0,0,0,,所以如果你看到这个
Dialogue: 0,0:29:24.50,0:29:29.47,BottomCenter,,0,0,0,,堆栈溢出或立方体溢出或递归限制
Dialogue: 0,0:29:29.59,0:29:31.50,BottomCenter,,0,0,0,,超过了，出了问题
Dialogue: 0,0:29:31.50,0:29:33.86,BottomCenter,,0,0,0,,与代码上的停止条件
Dialogue: 0,0:29:34.17,0:29:34.93,BottomCenter,,0,0,0,,现在好了
Dialogue: 0,0:29:34.93,0:29:35.70,BottomCenter,,0,0,0,,在此刻
Dialogue: 0,0:29:35.70,0:29:37.67,BottomCenter,,0,0,0,,我们已经看到了许多递归调用的例子
Dialogue: 0,0:29:37.67,0:29:39.47,BottomCenter,,0,0,0,,我将是第一个承认他们是
Dialogue: 0,0:29:39.50,0:29:40.73,BottomCenter,,0,0,0,,相对简单
Dialogue: 0,0:29:40.76,0:29:42.93,BottomCenter,,0,0,0,,并且没有明显的好处
Dialogue: 0,0:29:43.20,0:29:46.09,BottomCenter,,0,0,0,,通过迭代递归地做某事
Dialogue: 0,0:29:46.70,0:29:47.90,BottomCenter,,0,0,0,,我要向你展示的最后一个例子
Dialogue: 0,0:29:47.90,0:29:49.20,BottomCenter,,0,0,0,,我想向你展示力量
Dialogue: 0,0:29:49.20,0:29:52.17,BottomCenter,,0,0,0,,递归的真正力量和美丽
Dialogue: 0,0:29:52.29,0:29:53.40,BottomCenter,,0,0,0,,我们要解决一个
Dialogue: 0,0:29:53.40,0:29:55.52,BottomCenter,,0,0,0,,递归地相当复杂的问题
Dialogue: 0,0:29:55.67,0:29:56.70,BottomCenter,,0,0,0,,你将会看到如何
Dialogue: 0,0:29:56.70,0:29:59.17,BottomCenter,,0,0,0,,真正优雅的递归可以是当它做得非常好时
Dialogue: 0,0:29:59.17,0:29:59.52,BottomCenter,,0,0,0,,很好
Dialogue: 0,0:29:59.52,0:30:01.52,BottomCenter,,0,0,0,,所以我们回来后会再捡起它
Dialogue: 0,0:30:03.79,0:30:06.06,BottomCenter,,0,0,0,,列表推导式
Dialogue: 0,0:30:06.13,0:30:07.76,BottomCenter,,0,0,0,,是一种强大的形式
Dialogue: 0,0:30:07.76,0:30:10.70,BottomCenter,,0,0,0,,python语言中的组合
Dialogue: 0,0:30:11.59,0:30:13.59,BottomCenter,,0,0,0,,和列表理解
Dialogue: 0,0:30:14.09,0:30:15.93,BottomCenter,,0,0,0,,就像你在这里看到的那样
Dialogue: 0,0:30:16.50,0:30:17.97,BottomCenter,,0,0,0,,在这第二行
Dialogue: 0,0:30:19.06,0:30:22.40,BottomCenter,,0,0,0,,接受现有列表，在本例中为数字列表
Dialogue: 0,0:30:23.56,0:30:26.29,BottomCenter,,0,0,0,,并从中计算一个新列表
Dialogue: 0,0:30:26.86,0:30:28.97,BottomCenter,,0,0,0,,根据某种表达
Dialogue: 0,0:30:30.29,0:30:33.59,BottomCenter,,0,0,0,,所以这个人根据字母的眼睛建立了一份清单
Dialogue: 0,0:30:33.93,0:30:36.17,BottomCenter,,0,0,0,,3468 中的每只眼睛
Dialogue: 0,0:30:36.29,0:30:39.56,BottomCenter,,0,0,0,,其中字母是字母的序列，它给了我
Dialogue: 0,0:30:39.73,0:30:42.86,BottomCenter,,0,0,0,,演示哦，是时候演示一下了
Dialogue: 0,0:30:44.20,0:30:45.32,BottomCenter,,0,0,0,,让我们从简单开始
Dialogue: 0,0:30:45.93,0:30:48.50,BottomCenter,,0,0,0,,我将创建一个名为 odds 的列表
Dialogue: 0,0:30:49.47,0:30:52.17,BottomCenter,,0,0,0,,其中有一三五七九
Dialogue: 0,0:30:53.06,0:30:56.20,BottomCenter,,0,0,0,,现在列表理解可以说明
Dialogue: 0,0:30:56.29,0:30:59.47,BottomCenter,,0,0,0,,我想要 x 加一的计算机列表
Dialogue: 0,0:30:59.67,0:31:01.70,BottomCenter,,0,0,0,,对于赔率中的每个 x
Dialogue: 0,0:31:02.56,0:31:05.17,BottomCenter,,0,0,0,,这会给我 2 4 6 8 10
Dialogue: 0,0:31:05.59,0:31:08.79,BottomCenter,,0,0,0,,一变成二，三变成四等等
Dialogue: 0,0:31:09.79,0:31:10.86,BottomCenter,,0,0,0,,这发生了
Dialogue: 0,0:31:10.86,0:31:12.52,BottomCenter,,0,0,0,,通过评估 x 加一
Dialogue: 0,0:31:12.52,0:31:14.20,BottomCenter,,0,0,0,,一遍又一遍的表达
Dialogue: 0,0:31:14.56,0:31:17.52,BottomCenter,,0,0,0,,x 依次绑定到每个
Dialogue: 0,0:31:19.67,0:31:22.09,BottomCenter,,0,0,0,,有一个更复杂的形式
Dialogue: 0,0:31:23.17,0:31:24.93,BottomCenter,,0,0,0,,列表理解的
Dialogue: 0,0:31:25.97,0:31:28.36,BottomCenter,,0,0,0,,不仅包括一个表达式
Dialogue: 0,0:31:28.36,0:31:30.00,BottomCenter,,0,0,0,,如何计算先生们
Dialogue: 0,0:31:32.52,0:31:33.36,BottomCenter,,0,0,0,,一个名字
Dialogue: 0,0:31:33.79,0:31:36.32,BottomCenter,,0,0,0,,然后是你想要计算的序列
Dialogue: 0,0:31:36.90,0:31:37.97,BottomCenter,,0,0,0,,但是也
Dialogue: 0,0:31:38.73,0:31:42.13,BottomCenter,,0,0,0,,if 一词后跟某个条件
Dialogue: 0,0:31:42.67,0:31:47.13,BottomCenter,,0,0,0,,比如 25% x 等于 0
Dialogue: 0,0:31:48.56,0:31:53.50,BottomCenter,,0,0,0,,这意味着我只想保留元素 x 如果
Dialogue: 0,0:31:53.90,0:31:57.17,BottomCenter,,0,0,0,,就是 x 能被整除的情况
Dialogue: 0,0:31:57.56,0:31:58.76,BottomCenter,,0,0,0,,进入数字25
Dialogue: 0,0:31:59.20,0:32:02.52,BottomCenter,,0,0,0,,所以 25 除以 x 余数为零
Dialogue: 0,0:32:02.56,0:32:05.73,BottomCenter,,0,0,0,,使用余数运算符或模运算符
Dialogue: 0,0:32:07.29,0:32:09.73,BottomCenter,,0,0,0,,所以有人进入 25 25 次
Dialogue: 0,0:32:09.73,0:32:12.40,BottomCenter,,0,0,0,,五变成二十五五次
Dialogue: 0,0:32:12.47,0:32:16.09,BottomCenter,,0,0,0,,但三七和九不能整除25
Dialogue: 0,0:32:17.09,0:32:18.06,BottomCenter,,0,0,0,,所以这
Dialogue: 0,0:32:19.06,0:32:21.09,BottomCenter,,0,0,0,,列表理解的一部分
Dialogue: 0,0:32:21.17,0:32:22.32,BottomCenter,,0,0,0,,让我选择
Dialogue: 0,0:32:22.40,0:32:25.00,BottomCenter,,0,0,0,,我只想保留列表中的一部分
Dialogue: 0,0:32:26.52,0:32:29.90,BottomCenter,,0,0,0,,我可以对这些进行有趣的组合
Dialogue: 0,0:32:30.09,0:32:32.67,BottomCenter,,0,0,0,,所以我可以说我想要 x 加一
Dialogue: 0,0:32:32.70,0:32:35.26,BottomCenter,,0,0,0,,对于这些均匀地挑战 25 的元素
Dialogue: 0,0:32:35.36,0:32:36.86,BottomCenter,,0,0,0,,然后我就得不到五分之一
Dialogue: 0,0:32:36.86,0:32:38.97,BottomCenter,,0,0,0,,但我会得到两个和六个
Dialogue: 0,0:32:39.93,0:32:41.76,BottomCenter,,0,0,0,,所以这些是列表理解
Dialogue: 0,0:32:42.86,0:32:45.17,BottomCenter,,0,0,0,,我当然可以将它们放在一个函数中
Dialogue: 0,0:32:45.67,0:32:47.67,BottomCenter,,0,0,0,,例如我可能有
Dialogue: 0,0:32:47.79,0:32:50.73,BottomCenter,,0,0,0,,计算设备的函数
Dialogue: 0,0:32:51.06,0:32:52.86,BottomCenter,,0,0,0,,某个数字 n
Dialogue: 0,0:32:53.70,0:32:55.00,BottomCenter,,0,0,0,,以及它会如何做到这一点
Dialogue: 0,0:32:55.32,0:32:56.73,BottomCenter,,0,0,0,,好吧，它只会返回
Dialogue: 0,0:32:57.50,0:32:59.26,BottomCenter,,0,0,0,,分裂一切的人
Dialogue: 0,0:32:59.67,0:33:00.52,BottomCenter,,0,0,0,,进而
Dialogue: 0,0:33:01.40,0:33:04.97,BottomCenter,,0,0,0,,x 表示 x 的范围从 2 一直到
Dialogue: 0,0:33:04.97,0:33:06.36,BottomCenter,,0,0,0,,但不包括在
Dialogue: 0,0:33:09.36,0:33:10.52,BottomCenter,,0,0,0,,如果是这样的话
Dialogue: 0,0:33:10.93,0:33:11.73,BottomCenter,,0,0,0,,那
Dialogue: 0,0:33:12.47,0:33:14.73,BottomCenter,,0,0,0,,end 除以 x 等于零
Dialogue: 0,0:33:17.70,0:33:19.86,BottomCenter,,0,0,0,,那么一口井的设备是什么？
Dialogue: 0,0:33:19.86,0:33:21.36,BottomCenter,,0,0,0,,这是一种特殊情况
Dialogue: 0,0:33:21.56,0:33:22.59,BottomCenter,,0,0,0,,四个怎么样
Dialogue: 0,0:33:22.79,0:33:24.26,BottomCenter,,0,0,0,,好吧，你有一和二
Dialogue: 0,0:33:24.86,0:33:26.93,BottomCenter,,0,0,0,,九个怎么样，你有一和三
Dialogue: 0,0:33:27.09,0:33:29.32,BottomCenter,,0,0,0,,八个怎么样，你有一二四
Dialogue: 0,0:33:29.40,0:33:30.76,BottomCenter,,0,0,0,,十二还有更多
Dialogue: 0,0:33:31.50,0:33:33.47,BottomCenter,,0,0,0,,18 有多个设备
Dialogue: 0,0:33:33.47,0:33:35.56,BottomCenter,,0,0,0,,这些都是整数
Dialogue: 0,0:33:36.59,0:33:38.79,BottomCenter,,0,0,0,,均匀地除一些数n
Dialogue: 0,0:33:40.93,0:33:42.86,BottomCenter,,0,0,0,,弦乐是我的最爱
Dialogue: 0,0:33:43.56,0:33:45.20,BottomCenter,,0,0,0,,字符串是一种抽象
Dialogue: 0,0:33:45.40,0:33:48.00,BottomCenter,,0,0,0,,文本数据的表示
Dialogue: 0,0:33:49.00,0:33:51.17,BottomCenter,,0,0,0,,我称它们为抽象，因为我们不在乎
Dialogue: 0,0:33:51.17,0:33:53.73,BottomCenter,,0,0,0,,关于它们的编码方式的详细信息
Dialogue: 0,0:33:54.73,0:33:56.70,BottomCenter,,0,0,0,,但它们确实代表了信息
Dialogue: 0,0:33:57.00,0:33:58.76,BottomCenter,,0,0,0,,它们可以代表数字
Dialogue: 0,0:33:58.76,0:33:59.79,BottomCenter,,0,0,0,,以及我们写作的方式
Dialogue: 0,0:33:59.79,0:34:01.97,BottomCenter,,0,0,0,,数字都可以用字符串来表示
Dialogue: 0,0:34:01.97,0:34:03.79,BottomCenter,,0,0,0,,这里我们有科学记数法
Dialogue: 0,0:34:03.93,0:34:05.50,BottomCenter,,0,0,0,,我们有一些观点
Dialogue: 0,0:34:05.67,0:34:07.76,BottomCenter,,0,0,0,,所有这些都只是字符串
Dialogue: 0,0:34:07.76,0:34:08.96,BottomCenter,,0,0,0,,告诉我们信息
Dialogue: 0,0:34:09.40,0:34:11.00,BottomCenter,,0,0,0,,它们可以代表语言
Dialogue: 0,0:34:11.50,0:34:13.40,BottomCenter,,0,0,0,,并作为想象
Dialogue: 0,0:34:13.40,0:34:16.13,BottomCenter,,0,0,0,,身体呈现未知事物的形式
Dialogue: 0,0:34:16.13,0:34:17.40,BottomCenter,,0,0,0,,和诗人的笔
Dialogue: 0,0:34:17.59,0:34:20.50,BottomCenter,,0,0,0,,将它们变成形状并赋予空虚的虚无
Dialogue: 0,0:34:20.57,0:34:23.26,BottomCenter,,0,0,0,,当地的居住地和名字
Dialogue: 0,0:34:24.13,0:34:27.40,BottomCenter,,0,0,0,,我记得莎士比亚写仲夏夜之梦的时候
Dialogue: 0,0:34:27.57,0:34:32.13,BottomCenter,,0,0,0,,他在谈论计算机科学和抽象
Dialogue: 0,0:34:33.59,0:34:36.17,BottomCenter,,0,0,0,,您还可以使用字符串来表示程序
Dialogue: 0,0:34:36.30,0:34:39.26,BottomCenter,,0,0,0,,所以这是一个定义柯里函数的字符串
Dialogue: 0,0:34:39.73,0:34:42.46,BottomCenter,,0,0,0,,python 源文件只是字符串
Dialogue: 0,0:34:42.46,0:34:45.19,BottomCenter,,0,0,0,,所以如果我把它放在源文件中并执行它
Dialogue: 0,0:34:45.32,0:34:47.92,BottomCenter,,0,0,0,,那么我就定义了柯里函数
Dialogue: 0,0:34:48.53,0:34:49.57,BottomCenter,,0,0,0,,顺便说一下
Dialogue: 0,0:34:49.76,0:34:54.07,BottomCenter,,0,0,0,,如果我启动一个 python 并准确地创建该字符串
Dialogue: 0,0:34:54.30,0:34:55.96,BottomCenter,,0,0,0,,咖喱羊肉f
Dialogue: 0,0:34:56.32,0:34:59.36,BottomCenter,,0,0,0,,羔羊 x 羔羊 y
Dialogue: 0,0:34:59.76,0:35:01.59,BottomCenter,,0,0,0,,x 组合 y 的 f
Dialogue: 0,0:35:03.73,0:35:04.96,BottomCenter,,0,0,0,,这只是一个字符串
Dialogue: 0,0:35:05.36,0:35:08.17,BottomCenter,,0,0,0,,但如果我执行该字符串
Dialogue: 0,0:35:08.90,0:35:11.26,BottomCenter,,0,0,0,,那么我刚刚定义了咖喱
Dialogue: 0,0:35:15.53,0:35:17.53,BottomCenter,,0,0,0,,如果我柯里化 add 函数
Dialogue: 0,0:35:17.67,0:35:20.13,BottomCenter,,0,0,0,,使用之前只是一个字符串
Dialogue: 0,0:35:20.86,0:35:23.90,BottomCenter,,0,0,0,,事实上我可以将数字相加
Dialogue: 0,0:35:25.17,0:35:27.13,BottomCenter,,0,0,0,,关于字符串的一些细节
Dialogue: 0,0:35:27.13,0:35:28.19,BottomCenter,,0,0,0,,你可能已经发现了
Dialogue: 0,0:35:28.19,0:35:29.40,BottomCenter,,0,0,0,,已经贯穿整个课程
Dialogue: 0,0:35:29.40,0:35:30.69,BottomCenter,,0,0,0,,但我现在就讲一下
Dialogue: 0,0:35:31.86,0:35:34.40,BottomCenter,,0,0,0,,有三种不同的方式来写下一个字符串
Dialogue: 0,0:35:34.86,0:35:36.50,BottomCenter,,0,0,0,,我可以使用单引号
Dialogue: 0,0:35:36.86,0:35:38.50,BottomCenter,,0,0,0,,我可以使用双引号
Dialogue: 0,0:35:38.80,0:35:39.92,BottomCenter,,0,0,0,,他们是一样的
Dialogue: 0,0:35:39.96,0:35:42.13,BottomCenter,,0,0,0,,除了如果你加上撇号
Dialogue: 0,0:35:42.36,0:35:44.13,BottomCenter,,0,0,0,,在双引号字符串的中间
Dialogue: 0,0:35:44.13,0:35:45.46,BottomCenter,,0,0,0,,效果很好
Dialogue: 0,0:35:46.00,0:35:47.50,BottomCenter,,0,0,0,,但如果你在中间这样做
Dialogue: 0,0:35:47.50,0:35:48.80,BottomCenter,,0,0,0,,单引号字符串
Dialogue: 0,0:35:49.19,0:35:50.53,BottomCenter,,0,0,0,,那么它就会结束字符串
Dialogue: 0,0:35:51.67,0:35:52.30,BottomCenter,,0,0,0,,你不必
Dialogue: 0,0:35:52.30,0:35:54.30,BottomCenter,,0,0,0,,只需将英文字符放入字符串中即可
Dialogue: 0,0:35:54.80,0:35:55.59,BottomCenter,,0,0,0,,停止了
Dialogue: 0,0:35:56.13,0:35:57.17,BottomCenter,,0,0,0,,很好
Dialogue: 0,0:35:58.17,0:36:00.96,BottomCenter,,0,0,0,,单引号和双引号字符串是等效的
Dialogue: 0,0:36:01.90,0:36:03.67,BottomCenter,,0,0,0,,三重引号字符串
Dialogue: 0,0:36:04.90,0:36:06.69,BottomCenter,,0,0,0,,可以跨越多行
Dialogue: 0,0:36:07.17,0:36:09.40,BottomCenter,,0,0,0,,所以我经常将它们用于码头字符串
Dialogue: 0,0:36:09.53,0:36:11.09,BottomCenter,,0,0,0,,因为很多时候
Dialogue: 0,0:36:11.09,0:36:12.92,BottomCenter,,0,0,0,,停靠字符串将扩展多行
Dialogue: 0,0:36:12.92,0:36:14.36,BottomCenter,,0,0,0,,当您添加停靠测试时
Dialogue: 0,0:36:15.96,0:36:18.90,BottomCenter,,0,0,0,,现在当我评估这个多行字符串时
Dialogue: 0,0:36:19.40,0:36:22.50,BottomCenter,,0,0,0,,当它最后向我显示时，所有内容都适合一条线
Dialogue: 0,0:36:23.76,0:36:25.13,BottomCenter,,0,0,0,,发生了什么事
Dialogue: 0,0:36:25.17,0:36:27.50,BottomCenter,,0,0,0,,它使用特殊符号进行编码
Dialogue: 0,0:36:27.50,0:36:30.00,BottomCenter,,0,0,0,,一行的末尾在另一行的开头
Dialogue: 0,0:36:30.36,0:36:32.00,BottomCenter,,0,0,0,,这称为换行
Dialogue: 0,0:36:33.00,0:36:36.53,BottomCenter,,0,0,0,,所以每当你在一行中看到反斜杠时
Dialogue: 0,0:36:36.90,0:36:39.07,BottomCenter,,0,0,0,,转义以下字符
Dialogue: 0,0:36:39.69,0:36:42.57,BottomCenter,,0,0,0,,这意味着这两个角色在一起
Dialogue: 0,0:36:42.92,0:36:45.67,BottomCenter,,0,0,0,,反斜杠和后面的字符
Dialogue: 0,0:36:46.00,0:36:50.19,BottomCenter,,0,0,0,,实际上只是字母序列中的一件事
Dialogue: 0,0:36:50.19,0:36:51.57,BottomCenter,,0,0,0,,这就是字符串
Dialogue: 0,0:36:52.17,0:36:55.92,BottomCenter,,0,0,0,,这个反斜杠 n 表示换行，这意味着
Dialogue: 0,0:36:56.26,0:36:57.46,BottomCenter,,0,0,0,,开始一个新行
Dialogue: 0,0:36:58.96,0:37:00.40,BottomCenter,,0,0,0,,字符串或序列
Dialogue: 0,0:37:00.67,0:37:02.32,BottomCenter,,0,0,0,,长度和元素选择
Dialogue: 0,0:37:03.09,0:37:05.40,BottomCenter,,0,0,0,,操作与您期望的类似
Dialogue: 0,0:37:05.90,0:37:08.67,BottomCenter,,0,0,0,,所以伯克利市的长度是八
Dialogue: 0,0:37:08.69,0:37:10.30,BottomCenter,,0,0,0,,这意味着它们是八个字母
Dialogue: 0,0:37:10.30,0:37:12.13,BottomCenter,,0,0,0,,每个字母称为字符
Dialogue: 0,0:37:13.59,0:37:14.40,BottomCenter,,0,0,0,,现在
Dialogue: 0,0:37:14.59,0:37:17.69,BottomCenter,,0,0,0,,实际上元素选择具有相同的索引方案
Dialogue: 0,0:37:17.69,0:37:19.17,BottomCenter,,0,0,0,,0 1 2 3
Dialogue: 0,0:37:19.59,0:37:22.30,BottomCenter,,0,0,0,,但结果并不完全是你想象的那样
Dialogue: 0,0:37:23.09,0:37:25.17,BottomCenter,,0,0,0,,所以你得到的是
Dialogue: 0,0:37:25.50,0:37:29.30,BottomCenter,,0,0,0,,字符串，即使您选择的是字符串
Dialogue: 0,0:37:29.76,0:37:31.19,BottomCenter,,0,0,0,,现在列表不能像这样工作
Dialogue: 0,0:37:31.19,0:37:32.67,BottomCenter,,0,0,0,,如果你有一个数字列表
Dialogue: 0,0:37:32.67,0:37:35.09,BottomCenter,,0,0,0,,并且您选择了接下来三个的元素
Dialogue: 0,0:37:35.13,0:37:36.30,BottomCenter,,0,0,0,,你会得到一个号码
Dialogue: 0,0:37:36.50,0:37:41.17,BottomCenter,,0,0,0,,不是列表，但对于字符串，您会得到一个字符串
Dialogue: 0,0:37:41.53,0:37:44.26,BottomCenter,,0,0,0,,但只有一个元素，其中只有一个字符
Dialogue: 0,0:37:46.67,0:37:47.57,BottomCenter,,0,0,0,,在和不在
Dialogue: 0,0:37:47.57,0:37:49.96,BottomCenter,,0,0,0,,对于字符串来说有点不同
Dialogue: 0,0:37:50.13,0:37:52.00,BottomCenter,,0,0,0,,与其他序列类型
Dialogue: 0,0:37:52.96,0:37:53.76,BottomCenter,,0,0,0,,所以
Dialogue: 0,0:37:54.50,0:37:57.96,BottomCenter,,0,0,0,,而不是只寻找单个字母
Dialogue: 0,0:37:57.96,0:38:00.00,BottomCenter,,0,0,0,,在这个字母序列中
Dialogue: 0,0:38:00.09,0:38:01.67,BottomCenter,,0,0,0,,你可以查找整个单词
Dialogue: 0,0:38:01.76,0:38:04.26,BottomCenter,,0,0,0,,所以如果我说这里穿着摇摇晃晃的
Dialogue: 0,0:38:04.26,0:38:05.36,BottomCenter,,0,0,0,,它会告诉我真相
Dialogue: 0,0:38:05.86,0:38:08.09,BottomCenter,,0,0,0,,但如果我说如果 2 3 4 无辜的话
Dialogue: 0,0:38:08.09,0:38:09.92,BottomCenter,,0,0,0,,即使两个、三个和四个彼此相邻
Dialogue: 0,0:38:09.92,0:38:10.96,BottomCenter,,0,0,0,,它会说假的
Dialogue: 0,0:38:11.09,0:38:12.76,BottomCenter,,0,0,0,,如果我在这里查找列表
Dialogue: 0,0:38:12.76,0:38:14.26,BottomCenter,,0,0,0,,那也是假的
Dialogue: 0,0:38:14.73,0:38:17.46,BottomCenter,,0,0,0,,所以你一次只能寻找一个元素
Dialogue: 0,0:38:17.73,0:38:21.00,BottomCenter,,0,0,0,,但在字符串中你可以查找连续的字母
Dialogue: 0,0:38:21.53,0:38:22.32,BottomCenter,,0,0,0,,那是因为
Dialogue: 0,0:38:22.32,0:38:24.09,BottomCenter,,0,0,0,,大多数时候当你使用字符串时
Dialogue: 0,0:38:24.09,0:38:25.90,BottomCenter,,0,0,0,,你实际上关心整个词
Dialogue: 0,0:38:26.07,0:38:27.76,BottomCenter,,0,0,0,,不仅仅是单个字母
Dialogue: 0,0:38:27.76,0:38:29.69,BottomCenter,,0,0,0,,所以字符串是一个特殊的抽象
Dialogue: 0,0:38:29.76,0:38:31.92,BottomCenter,,0,0,0,,在很多方面都类似于序列
Dialogue: 0,0:38:31.92,0:38:33.19,BottomCenter,,0,0,0,,但他们的行为方式
Dialogue: 0,0:38:33.19,0:38:35.57,BottomCenter,,0,0,0,,这与其他序列略有不同
Dialogue: 0,0:38:37.26,0:38:37.67,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:38:37.67,0:38:39.53,BottomCenter,,0,0,0,,让我们从上次停下的地方继续
Dialogue: 0,0:38:39.53,0:38:40.96,BottomCenter,,0,0,0,,我们要多谈一点
Dialogue: 0,0:38:40.96,0:38:42.69,BottomCenter,,0,0,0,,递归和
Dialogue: 0,0:38:42.80,0:38:44.59,BottomCenter,,0,0,0,,你可能还记得我们写过一个
Dialogue: 0,0:38:44.59,0:38:48.13,BottomCenter,,0,0,0,,反转字符串的迭代算法
Dialogue: 0,0:38:48.19,0:38:51.13,BottomCenter,,0,0,0,,反转病房以绘制或绘制
Dialogue: 0,0:38:51.40,0:38:52.73,BottomCenter,,0,0,0,,那么这是如何运作的
Dialogue: 0,0:38:52.80,0:38:55.26,BottomCenter,,0,0,0,,我们取了最后一封信中的第一个字母，然后我们
Dialogue: 0,0:38:55.26,0:38:56.07,BottomCenter,,0,0,0,,交换了它们
Dialogue: 0,0:38:56.17,0:38:58.69,BottomCenter,,0,0,0,,然后我们加一减一
Dialogue: 0,0:38:58.69,0:39:01.69,BottomCenter,,0,0,0,,交换并继续前进，直到我们到达中点
Dialogue: 0,0:39:01.69,0:39:03.40,BottomCenter,,0,0,0,,这是一个迭代算法
Dialogue: 0,0:39:03.73,0:39:05.53,BottomCenter,,0,0,0,,我们有一个 while 或一个 for 循环
Dialogue: 0,0:39:05.53,0:39:07.59,BottomCenter,,0,0,0,,这将从第一个字母开始
Dialogue: 0,0:39:07.59,0:39:09.26,BottomCenter,,0,0,0,,到弦的中间点
Dialogue: 0,0:39:09.36,0:39:10.96,BottomCenter,,0,0,0,,交换 交换 交换 交换
Dialogue: 0,0:39:10.96,0:39:12.36,BottomCenter,,0,0,0,,完美的交换方式
Dialogue: 0,0:39:12.50,0:39:13.73,BottomCenter,,0,0,0,,我只想想想这个
Dialogue: 0,0:39:13.73,0:39:15.50,BottomCenter,,0,0,0,,我们如何递归地做到这一点
Dialogue: 0,0:39:16.09,0:39:20.73,BottomCenter,,0,0,0,,那么递归反转字符串是什么意思
Dialogue: 0,0:39:20.80,0:39:22.59,BottomCenter,,0,0,0,,就像你在阶乘中看到的那样
Dialogue: 0,0:39:22.80,0:39:24.59,BottomCenter,,0,0,0,,通常这意味着你保留
Dialogue: 0,0:39:24.59,0:39:26.26,BottomCenter,,0,0,0,,简化问题
Dialogue: 0,0:39:26.67,0:39:28.26,BottomCenter,,0,0,0,,直到达到基本情况
Dialogue: 0,0:39:28.96,0:39:29.80,BottomCenter,,0,0,0,,那么基地是做什么的
Dialogue: 0,0:39:29.80,0:39:31.46,BottomCenter,,0,0,0,,案例看起来就像反转字符串
Dialogue: 0,0:39:31.46,0:39:33.32,BottomCenter,,0,0,0,,什么是最简单的事情
Dialogue: 0,0:39:33.59,0:39:35.57,BottomCenter,,0,0,0,,而只有一个字母的字符串
Dialogue: 0,0:39:35.73,0:39:37.96,BottomCenter,,0,0,0,,反转很简单，就是那个字母
Dialogue: 0,0:39:38.13,0:39:39.86,BottomCenter,,0,0,0,,或者可能是空字符串
Dialogue: 0,0:39:40.09,0:39:41.96,BottomCenter,,0,0,0,,是一个简单的基本情况
Dialogue: 0,0:39:41.96,0:39:43.67,BottomCenter,,0,0,0,,所以考虑一下总是好的
Dialogue: 0,0:39:43.67,0:39:44.90,BottomCenter,,0,0,0,,当你认为递归就像
Dialogue: 0,0:39:45.09,0:39:46.90,BottomCenter,,0,0,0,,这是什么简单的情况
Dialogue: 0,0:39:47.00,0:39:49.36,BottomCenter,,0,0,0,,然后你的工作递归
Dialogue: 0,0:39:49.53,0:39:51.59,BottomCenter,,0,0,0,,就是要解决一个大问题
Dialogue: 0,0:39:51.73,0:39:54.73,BottomCenter,,0,0,0,,反转包含 n 个字母的字符串
Dialogue: 0,0:39:54.92,0:39:57.00,BottomCenter,,0,0,0,,并找出如何分解它
Dialogue: 0,0:39:57.19,0:39:59.32,BottomCenter,,0,0,0,,变成一个简单的操作
Dialogue: 0,0:39:59.36,0:40:01.53,BottomCenter,,0,0,0,,有一个稍微简单的版本
Dialogue: 0,0:40:01.53,0:40:04.09,BottomCenter,,0,0,0,,说反转并减一个字符
Dialogue: 0,0:40:04.17,0:40:05.53,BottomCenter,,0,0,0,,所以让我们想一想
Dialogue: 0,0:40:05.80,0:40:08.46,BottomCenter,,0,0,0,,那么反转字符串是什么意思
Dialogue: 0,0:40:08.46,0:40:11.36,BottomCenter,,0,0,0,,所以当我交换w时我们一直在考虑这个
Dialogue: 0,0:40:11.46,0:40:13.09,BottomCenter,,0,0,0,,以及 d 和 a 和 r
Dialogue: 0,0:40:13.53,0:40:14.96,BottomCenter,,0,0,0,,但思考这个问题的另一种方式是
Dialogue: 0,0:40:14.96,0:40:16.17,BottomCenter,,0,0,0,,我可以接受那个w
Dialogue: 0,0:40:16.40,0:40:18.40,BottomCenter,,0,0,0,,并把它一直放在最后
Dialogue: 0,0:40:18.76,0:40:20.26,BottomCenter,,0,0,0,,然后反转
Dialogue: 0,0:40:20.67,0:40:21.73,BottomCenter,,0,0,0,,字符串的其余部分
Dialogue: 0,0:40:21.90,0:40:23.40,BottomCenter,,0,0,0,,是的，听起来不错
Dialogue: 0,0:40:23.40,0:40:25.69,BottomCenter,,0,0,0,,所以让我们看看这是否有意义
Dialogue: 0,0:40:26.13,0:40:29.90,BottomCenter,,0,0,0,,那么我们是否可以同意字符串病房的相反
Dialogue: 0,0:40:30.36,0:40:31.17,BottomCenter,,0,0,0,,是
Dialogue: 0,0:40:31.69,0:40:34.36,BottomCenter,,0,0,0,,除了第一个字母以外的所有内容都相反
Dialogue: 0,0:40:34.69,0:40:36.90,BottomCenter,,0,0,0,,与第一个字母连接的字符串
Dialogue: 0,0:40:37.13,0:40:38.80,BottomCenter,,0,0,0,,当然，让我们在脑海中做这件事
Dialogue: 0,0:40:38.80,0:40:41.00,BottomCenter,,0,0,0,,如果我扭转这个，那就是德拉
Dialogue: 0,0:40:41.19,0:40:43.13,BottomCenter,,0,0,0,,然后我把它附加到它上面
Dialogue: 0,0:40:43.13,0:40:44.69,BottomCenter,,0,0,0,,这当然是逆转
Dialogue: 0,0:40:45.17,0:40:46.57,BottomCenter,,0,0,0,,所以请注意我在这里做了什么
Dialogue: 0,0:40:46.73,0:40:48.90,BottomCenter,,0,0,0,,我用一个字母简化了问题
Dialogue: 0,0:40:48.90,0:40:50.00,BottomCenter,,0,0,0,,我已经做到了
Dialogue: 0,0:40:50.09,0:40:52.13,BottomCenter,,0,0,0,,思考逆转的本质
Dialogue: 0,0:40:52.13,0:40:52.50,BottomCenter,,0,0,0,,只是说
Dialogue: 0,0:40:52.50,0:40:54.53,BottomCenter,,0,0,0,,如果我只把第一个字母放在最后
Dialogue: 0,0:40:54.80,0:40:56.86,BottomCenter,,0,0,0,,然后我稍后会担心字符串的其余部分
Dialogue: 0,0:40:57.26,0:40:58.67,BottomCenter,,0,0,0,,这是一个递归定义
Dialogue: 0,0:40:58.67,0:41:00.17,BottomCenter,,0,0,0,,因为请注意我已经定义了
Dialogue: 0,0:41:00.46,0:41:01.26,BottomCenter,,0,0,0,,这
Dialogue: 0,0:41:01.96,0:41:04.80,BottomCenter,,0,0,0,,将整个字符串反转为
Dialogue: 0,0:41:05.07,0:41:07.09,BottomCenter,,0,0,0,,稍微较小的字符串的反转
Dialogue: 0,0:41:07.13,0:41:08.57,BottomCenter,,0,0,0,,再加上简单的操作
Dialogue: 0,0:41:08.57,0:41:10.86,BottomCenter,,0,0,0,,看起来很像阶乘右端阶乘
Dialogue: 0,0:41:10.86,0:41:13.57,BottomCenter,,0,0,0,,这是结束时间并减去一个阶乘
Dialogue: 0,0:41:13.67,0:41:15.59,BottomCenter,,0,0,0,,好吧，让我们再做一次，确保我们看到
Dialogue: 0,0:41:15.76,0:41:16.67,BottomCenter,,0,0,0,,我们如何逆转
Dialogue: 0,0:41:16.67,0:41:17.57,BottomCenter,,0,0,0,,现在阿德
Dialogue: 0,0:41:18.26,0:41:19.40,BottomCenter,,0,0,0,,这是同一个游戏
Dialogue: 0,0:41:19.46,0:41:20.73,BottomCenter,,0,0,0,,就拿我来说
Dialogue: 0,0:41:20.80,0:41:23.90,BottomCenter,,0,0,0,,现在把它推到最后当然不是这里的结束
Dialogue: 0,0:41:24.00,0:41:25.19,BottomCenter,,0,0,0,,这的结束
Dialogue: 0,0:41:25.26,0:41:28.00,BottomCenter,,0,0,0,,然后在前面反转 rd
Dialogue: 0,0:41:28.19,0:41:32.19,BottomCenter,,0,0,0,,所以 ard 的反转就是 rd 加 a 的反转
Dialogue: 0,0:41:32.76,0:41:33.86,BottomCenter,,0,0,0,,现在最终
Dialogue: 0,0:41:33.92,0:41:35.17,BottomCenter,,0,0,0,,所以注意发生了什么
Dialogue: 0,0:41:35.17,0:41:38.07,BottomCenter,,0,0,0,,这件事必须评估为这个
Dialogue: 0,0:41:38.09,0:41:39.53,BottomCenter,,0,0,0,,这最终会给我一个答案
Dialogue: 0,0:41:39.53,0:41:41.30,BottomCenter,,0,0,0,,当我沿着递归的方向工作时
Dialogue: 0,0:41:41.30,0:41:43.32,BottomCenter,,0,0,0,,我会把它塞进去，它应该是德拉
Dialogue: 0,0:41:43.50,0:41:46.07,BottomCenter,,0,0,0,,我把它附加到它上面然后我就完成了
Dialogue: 0,0:41:46.86,0:41:47.40,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:41:47.40,0:41:48.69,BottomCenter,,0,0,0,,我们的 d 的逆转是什么
Dialogue: 0,0:41:48.69,0:41:50.00,BottomCenter,,0,0,0,,现在我们知道游戏是什么了
Dialogue: 0,0:41:50.09,0:41:51.30,BottomCenter,,0,0,0,,拿第一个字母
Dialogue: 0,0:41:51.40,0:41:54.57,BottomCenter,,0,0,0,,把它推到最后，然后反转一个字母
Dialogue: 0,0:41:54.57,0:41:56.96,BottomCenter,,0,0,0,,啊，这看起来像我提到的基本情况
Dialogue: 0,0:41:56.96,0:41:58.30,BottomCenter,,0,0,0,,如果我有一封信
Dialogue: 0,0:41:58.36,0:41:59.46,BottomCenter,,0,0,0,,逆向主义琐碎
Dialogue: 0,0:41:59.46,0:42:01.46,BottomCenter,,0,0,0,,没有工作要做，没有计算
Dialogue: 0,0:42:01.46,0:42:02.50,BottomCenter,,0,0,0,,这只是一封信
Dialogue: 0,0:42:02.73,0:42:05.19,BottomCenter,,0,0,0,,所以我们同意 d 的反转就是 d
Dialogue: 0,0:42:05.36,0:42:07.46,BottomCenter,,0,0,0,,基本情况没有递归调用
Dialogue: 0,0:42:07.53,0:42:09.86,BottomCenter,,0,0,0,,这就像零阶乘是一
Dialogue: 0,0:42:10.09,0:42:11.26,BottomCenter,,0,0,0,,没有工作要做
Dialogue: 0,0:42:11.90,0:42:13.09,BottomCenter,,0,0,0,,好吧，现在你要做的就是
Dialogue: 0,0:42:13.09,0:42:14.00,BottomCenter,,0,0,0,,注意我们做了什么，如果我们
Dialogue: 0,0:42:14.09,0:42:15.90,BottomCenter,,0,0,0,,建立一个表达式
Dialogue: 0,0:42:15.90,0:42:18.13,BottomCenter,,0,0,0,,具有一系列字符串连接
Dialogue: 0,0:42:18.13,0:42:20.67,BottomCenter,,0,0,0,,现在我们只需要努力恢复
Dialogue: 0,0:42:20.69,0:42:24.80,BottomCenter,,0,0,0,,这个堆栈是为了创建最终答案
Dialogue: 0,0:42:25.13,0:42:26.80,BottomCenter,,0,0,0,,所以当然让我们从底部开始
Dialogue: 0,0:42:26.86,0:42:28.19,BottomCenter,,0,0,0,,什么是逆向d
Dialogue: 0,0:42:28.40,0:42:30.76,BottomCenter,,0,0,0,,它是 d，所以是 r 的倒数
Dialogue: 0,0:42:30.76,0:42:33.36,BottomCenter,,0,0,0,,d 只是 d 和 r 的字符串连接
Dialogue: 0,0:42:33.53,0:42:35.50,BottomCenter,,0,0,0,,好的，这很简单，我知道该怎么做
Dialogue: 0,0:42:35.67,0:42:37.36,BottomCenter,,0,0,0,,现在这里没有递归调用
Dialogue: 0,0:42:37.36,0:42:38.26,BottomCenter,,0,0,0,,没有工作要做
Dialogue: 0,0:42:38.26,0:42:39.92,BottomCenter,,0,0,0,,只需进行字符串连接
Dialogue: 0,0:42:40.07,0:42:43.17,BottomCenter,,0,0,0,,所以 rd 的逆转是 dr
Dialogue: 0,0:42:43.17,0:42:45.92,BottomCenter,,0,0,0,,我将把它与一个好的连接起来
Dialogue: 0,0:42:45.92,0:42:46.67,BottomCenter,,0,0,0,,让我们这样做吧
Dialogue: 0,0:42:46.67,0:42:48.07,BottomCenter,,0,0,0,,所以博士加上一个
Dialogue: 0,0:42:48.40,0:42:51.17,BottomCenter,,0,0,0,,ard 的逆转是 dra
Dialogue: 0,0:42:51.50,0:42:53.32,BottomCenter,,0,0,0,,所以我们把它弹出来
Dialogue: 0,0:42:53.40,0:42:57.30,BottomCenter,,0,0,0,,现在我们的病房逆转是平局
Dialogue: 0,0:42:57.30,0:42:58.59,BottomCenter,,0,0,0,,我们再次做到了
Dialogue: 0,0:42:58.67,0:42:59.46,BottomCenter,,0,0,0,,并注意
Dialogue: 0,0:42:59.67,0:43:02.26,BottomCenter,,0,0,0,,在这种情况下，这确实是一个不同的算法
Dialogue: 0,0:43:02.50,0:43:05.13,BottomCenter,,0,0,0,,是这样，而不是交换交换交换
Dialogue: 0,0:43:05.30,0:43:08.40,BottomCenter,,0,0,0,,我正在构建字符串连接的表达式
Dialogue: 0,0:43:08.40,0:43:09.76,BottomCenter,,0,0,0,,一次一个
Dialogue: 0,0:43:09.96,0:43:11.50,BottomCenter,,0,0,0,,剥落一个字母
Dialogue: 0,0:43:11.50,0:43:13.09,BottomCenter,,0,0,0,,这就是我说的意思
Dialogue: 0,0:43:13.30,0:43:14.73,BottomCenter,,0,0,0,,在上一讲的开头
Dialogue: 0,0:43:14.73,0:43:15.40,BottomCenter,,0,0,0,,那个递归
Dialogue: 0,0:43:15.40,0:43:16.92,BottomCenter,,0,0,0,,你必须认真思考
Dialogue: 0,0:43:16.92,0:43:19.26,BottomCenter,,0,0,0,,计算的本质有很大不同
Dialogue: 0,0:43:19.26,0:43:21.09,BottomCenter,,0,0,0,,我以一种非常优雅的方式思考
Dialogue: 0,0:43:21.46,0:43:22.90,BottomCenter,,0,0,0,,好吧，现在让我们用 python 来做
Dialogue: 0,0:43:24.57,0:43:29.30,BottomCenter,,0,0,0,,verse 是一个以字符串 s 作为输入的函数
Dialogue: 0,0:43:30.09,0:43:32.92,BottomCenter,,0,0,0,,如果列表的长度为一的基本情况
Dialogue: 0,0:43:33.00,0:43:34.19,BottomCenter,,0,0,0,,然后返回s
Dialogue: 0,0:43:34.19,0:43:36.76,BottomCenter,,0,0,0,,没有什么可做的，我在信中寄给你的
Dialogue: 0,0:43:37.00,0:43:38.36,BottomCenter,,0,0,0,,d 的反转是 d
Dialogue: 0,0:43:38.53,0:43:39.76,BottomCenter,,0,0,0,,回家吧，你完成了
Dialogue: 0,0:43:40.40,0:43:41.19,BottomCenter,,0,0,0,,否则
Dialogue: 0,0:43:41.53,0:43:44.53,BottomCenter,,0,0,0,,我要做什么 我想先把它剥掉
Dialogue: 0,0:43:44.73,0:43:46.59,BottomCenter,,0,0,0,,信并把它放在最后
Dialogue: 0,0:43:46.80,0:43:48.59,BottomCenter,,0,0,0,,和字符串连接
Dialogue: 0,0:43:48.69,0:43:51.07,BottomCenter,,0,0,0,,列表其余部分的反转
Dialogue: 0,0:43:51.26,0:43:52.90,BottomCenter,,0,0,0,,所以记住那个字符串
Dialogue: 0,0:43:52.90,0:43:56.53,BottomCenter,,0,0,0,,请记住，字符串可以像列表一样被索引
Dialogue: 0,0:43:56.73,0:43:58.30,BottomCenter,,0,0,0,,这是一个非常方便的地方
Dialogue: 0,0:43:58.46,0:44:02.36,BottomCenter,,0,0,0,,所以 s 小零是列表的第一个元素
Dialogue: 0,0:44:02.57,0:44:05.00,BottomCenter,,0,0,0,,你以前可能没有见过这个符号
Dialogue: 0,0:44:05.00,0:44:07.17,BottomCenter,,0,0,0,,但这一个冒号运算符
Dialogue: 0,0:44:07.40,0:44:11.46,BottomCenter,,0,0,0,,从一开始就是所有内容的缩写
Dialogue: 0,0:44:11.90,0:44:12.80,BottomCenter,,0,0,0,,中的人物
Dialogue: 0,0:44:13.80,0:44:15.26,BottomCenter,,0,0,0,,字符串的第一个位置
Dialogue: 0,0:44:15.26,0:44:19.73,BottomCenter,,0,0,0,,这是列表末尾的第二个字母
Dialogue: 0,0:44:19.86,0:44:23.86,BottomCenter,,0,0,0,,所以我也可以做 s 的一个冒号长度
Dialogue: 0,0:44:23.86,0:44:26.19,BottomCenter,,0,0,0,,但这是一个更简单的表示法
Dialogue: 0,0:44:26.32,0:44:29.07,BottomCenter,,0,0,0,,python 给你的只是一个冒号
Dialogue: 0,0:44:29.07,0:44:30.73,BottomCenter,,0,0,0,,然后你在这里留一个空白
Dialogue: 0,0:44:30.73,0:44:31.69,BottomCenter,,0,0,0,,那说给我
Dialogue: 0,0:44:31.69,0:44:34.32,BottomCenter,,0,0,0,,除了零以外的所有元素
Dialogue: 0,0:44:34.36,0:44:35.86,BottomCenter,,0,0,0,,是的，那就完美了
Dialogue: 0,0:44:35.92,0:44:36.90,BottomCenter,,0,0,0,,因为现在我要采取
Dialogue: 0,0:44:36.90,0:44:38.59,BottomCenter,,0,0,0,,假设进来的是病房
Dialogue: 0,0:44:38.69,0:44:42.07,BottomCenter,,0,0,0,,我选择零度以下的 w，我选择 ard
Dialogue: 0,0:44:42.19,0:44:43.13,BottomCenter,,0,0,0,,我采取阿德
Dialogue: 0,0:44:43.13,0:44:45.96,BottomCenter,,0,0,0,,我把它推回到递归调用中
Dialogue: 0,0:44:46.19,0:44:49.26,BottomCenter,,0,0,0,,反向 好的 那有什么作用
Dialogue: 0,0:44:49.26,0:44:52.26,BottomCenter,,0,0,0,,剥掉第一个字母并再次注意
Dialogue: 0,0:44:53.07,0:44:54.50,BottomCenter,,0,0,0,,这才是真正重要的地方
Dialogue: 0,0:44:54.50,0:44:56.19,BottomCenter,,0,0,0,,了解这些局部变量
Dialogue: 0,0:44:56.53,0:44:59.19,BottomCenter,,0,0,0,,第一个进来的是病房
Dialogue: 0,0:44:59.59,0:45:03.76,BottomCenter,,0,0,0,,但是当我进行递归调用时，消息很困难
Dialogue: 0,0:45:03.80,0:45:05.26,BottomCenter,,0,0,0,,然后下一次是rd
Dialogue: 0,0:45:05.26,0:45:06.53,BottomCenter,,0,0,0,,然后下次 d
Dialogue: 0,0:45:06.86,0:45:09.76,BottomCenter,,0,0,0,,然后这个表达臭猫国度
Dialogue: 0,0:45:09.86,0:45:10.50,BottomCenter,,0,0,0,,坚持住
Dialogue: 0,0:45:10.50,0:45:13.17,BottomCenter,,0,0,0,,记忆所有这些不同的实例
Dialogue: 0,0:45:13.17,0:45:14.96,BottomCenter,,0,0,0,,局部变量的
Dialogue: 0,0:45:15.07,0:45:16.90,BottomCenter,,0,0,0,,到函数的反转
Dialogue: 0,0:45:17.40,0:45:18.90,BottomCenter,,0,0,0,,好吧，最后一件事是
Dialogue: 0,0:45:19.32,0:45:20.36,BottomCenter,,0,0,0,,还有另一个基本情况
Dialogue: 0,0:45:20.36,0:45:21.57,BottomCenter,,0,0,0,,我只是想让你看看它是什么样子
Dialogue: 0,0:45:21.57,0:45:22.96,BottomCenter,,0,0,0,,因为它同样好
Dialogue: 0,0:45:22.96,0:45:23.30,BottomCenter,,0,0,0,,这是
Dialogue: 0,0:45:23.30,0:45:25.57,BottomCenter,,0,0,0,,你可以让基本情况是空列表
Dialogue: 0,0:45:25.67,0:45:26.86,BottomCenter,,0,0,0,,效果会很好
Dialogue: 0,0:45:26.86,0:45:28.26,BottomCenter,,0,0,0,,你最终会到达空列表
Dialogue: 0,0:45:28.32,0:45:30.73,BottomCenter,,0,0,0,,我认为这并不是真的必要，因为
Dialogue: 0,0:45:31.00,0:45:34.26,BottomCenter,,0,0,0,,一个字符 一个包含单个字符的列表实际上是
Dialogue: 0,0:45:34.67,0:45:36.86,BottomCenter,,0,0,0,,逆转本身就是
Dialogue: 0,0:45:36.92,0:45:38.19,BottomCenter,,0,0,0,,您可能想要这样做的唯一原因
Dialogue: 0,0:45:38.19,0:45:40.59,BottomCenter,,0,0,0,,如果有人给你一个空列表
Dialogue: 0,0:45:40.69,0:45:42.59,BottomCenter,,0,0,0,,最好不要被它噎住
Dialogue: 0,0:45:42.59,0:45:45.40,BottomCenter,,0,0,0,,这很好，因为它处理一个空列表
Dialogue: 0,0:45:45.59,0:45:46.40,BottomCenter,,0,0,0,,问题
Dialogue: 0,0:45:47.50,0:45:50.32,BottomCenter,,0,0,0,,这是我们完成的第二个递归示例
Dialogue: 0,0:45:50.32,0:45:52.19,BottomCenter,,0,0,0,,我希望你现在看到这一点
Dialogue: 0,0:45:52.26,0:45:54.73,BottomCenter,,0,0,0,,不仅代码看起来不同，而且
Dialogue: 0,0:45:54.76,0:45:56.90,BottomCenter,,0,0,0,,你必须以不同的方式思考这个问题
Dialogue: 0,0:45:56.90,0:45:59.76,BottomCenter,,0,0,0,,我真的很喜欢这样，因为它迫使你
Dialogue: 0,0:45:59.76,0:46:01.59,BottomCenter,,0,0,0,,思考计算的本质
Dialogue: 0,0:46:01.59,0:46:02.80,BottomCenter,,0,0,0,,以一种非常根本的方式
Dialogue: 0,0:46:02.80,0:46:04.50,BottomCenter,,0,0,0,,所以我们要再举几个例子
Dialogue: 0,0:46:04.80,0:46:05.50,BottomCenter,,0,0,0,,当我们回来时
Dialogue: 0,0:46:05.50,0:46:06.57,BottomCenter,,0,0,0,,几分钟后见
