[Script Info]
Title: Lecture 17. Iterations_哔哩哔哩_bilibili
ScriptType: v4.00+
Collisions: Reverse
PlayResX: 1280
PlayResY: 720
WrapStyle: 3
ScaledBorderAndShadow: yes
; ----------------------
; 本字幕由CC字幕助手自动转换
; 字幕来源https://www.bilibili.com/video/BV1s3411G7yM?p=41&vd_source=6ffca0aa1006734a4fba52f389036611
; 脚本地址https://greasyfork.org/scripts/378513
; 设置了字幕过长自动换行，但若字幕中没有空格换行将无效
; 字体大小依据720p 48号字体等比缩放
; 如显示不正常请尝试使用SRT格式

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Segoe UI,48,&H00FFFFFF,&HF0000000,&H00000000,&HF0000000,1,0,0,0,100,100,0,0.00,1,1,3,2,30,30,20,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.70,0:00:02.97,*Default,NTP,0000,0000,0000,,61 a lecture No.17
Dialogue: 0,0:00:03.40,0:00:04.37,*Default,NTP,0000,0000,0000,,announcements
Dialogue: 0,0:00:05.20,0:00:07.47,*Default,NTP,0000,0000,0000,,homework three is due on Thursday
Dialogue: 0,0:00:07.80,0:00:08.97,*Default,NTP,0000,0000,0000,,you can revise your
Dialogue: 0,0:00:08.97,0:00:10.57,*Default,NTP,0000,0000,0000,,hog project to earn
Dialogue: 0,0:00:10.57,0:00:13.37,*Default,NTP,0000,0000,0000,,back any lost composition points by Friday
Dialogue: 0,0:00:13.53,0:00:15.10,*Default,NTP,0000,0000,0000,,here's a link to a piazza post
Dialogue: 0,0:00:15.10,0:00:16.60,*Default,NTP,0000,0000,0000,,about exactly how to do that
Dialogue: 0,0:00:17.60,0:00:19.70,*Default,NTP,0000,0000,0000,,and the key part is that you submit
Dialogue: 0,0:00:19.73,0:00:20.97,*Default,NTP,0000,0000,0000,,by typing python three
Dialogue: 0,0:00:20.97,0:00:24.77,*Default,NTP,0000,0000,0000,,okay dash dash revise from your hog directory
Dialogue: 0,0:00:24.80,0:00:27.00,*Default,NTP,0000,0000,0000,,after you've made whatever changes you want
Dialogue: 0,0:00:28.10,0:00:30.30,*Default,NTP,0000,0000,0000,,please attend a discussion orientation
Dialogue: 0,0:00:30.33,0:00:32.47,*Default,NTP,0000,0000,0000,,before your tutorial
Dialogue: 0,0:00:32.70,0:00:34.57,*Default,NTP,0000,0000,0000,,I understand that many people have been
Dialogue: 0,0:00:34.57,0:00:35.97,*Default,NTP,0000,0000,0000,,coming to tutorial
Dialogue: 0,0:00:36.30,0:00:39.40,*Default,NTP,0000,0000,0000,,without going to a discussion orientation first
Dialogue: 0,0:00:39.77,0:00:42.87,*Default,NTP,0000,0000,0000,,tutorials are designed to follow up
Dialogue: 0,0:00:42.93,0:00:45.90,*Default,NTP,0000,0000,0000,,on what happens in discussion orientation
Dialogue: 0,0:00:46.53,0:00:48.50,*Default,NTP,0000,0000,0000,,so if you don't go to the orientation
Dialogue: 0,0:00:48.53,0:00:51.27,*Default,NTP,0000,0000,0000,,you won't really be able to participate in the tutorial
Dialogue: 0,0:00:51.30,0:00:53.73,*Default,NTP,0000,0000,0000,,and you'll lose out on that learning experience
Dialogue: 0,0:00:54.57,0:00:56.27,*Default,NTP,0000,0000,0000,,if you look at the core schedule
Dialogue: 0,0:00:56.73,0:00:59.47,*Default,NTP,0000,0000,0000,,we have a midterm coming up in a few weeks
Dialogue: 0,0:00:59.57,0:01:02.57,*Default,NTP,0000,0000,0000,,midterm two is scheduled for Wednesday the 28
Dialogue: 0,0:01:03.00,0:01:05.17,*Default,NTP,0000,0000,0000,,which is three weeks from tomorrow
Dialogue: 0,0:01:05.40,0:01:08.80,*Default,NTP,0000,0000,0000,,and the core staff has put together a study guide
Dialogue: 0,0:01:09.40,0:01:11.77,*Default,NTP,0000,0000,0000,,that gives you some advice about how to prepare
Dialogue: 0,0:01:12.00,0:01:14.47,*Default,NTP,0000,0000,0000,,not just the day before or the day of
Dialogue: 0,0:01:14.73,0:01:17.77,*Default,NTP,0000,0000,0000,,but in the weeks before an exam
Dialogue: 0,0:01:18.13,0:01:19.57,*Default,NTP,0000,0000,0000,,this study guide is mostly
Dialogue: 0,0:01:19.57,0:01:21.40,*Default,NTP,0000,0000,0000,,about how to master the material
Dialogue: 0,0:01:24.27,0:01:25.60,*Default,NTP,0000,0000,0000,,and notice that an
Dialogue: 0,0:01:25.60,0:01:28.10,*Default,NTP,0000,0000,0000,,important component is to actually watch lecture
Dialogue: 0,0:01:28.10,0:01:29.37,*Default,NTP,0000,0000,0000,,so you're doing the right thing
Dialogue: 0,0:01:29.37,0:01:31.10,*Default,NTP,0000,0000,0000,,now finish this lecture
Dialogue: 0,0:01:31.10,0:01:32.87,*Default,NTP,0000,0000,0000,,and then take a look at the study guide
Dialogue: 0,0:01:32.97,0:01:34.47,*Default,NTP,0000,0000,0000,,and I hope that it helps you
Dialogue: 0,0:01:35.33,0:01:37.87,*Default,NTP,0000,0000,0000,,finally we will be holding advising office
Dialogue: 0,0:01:37.87,0:01:39.37,*Default,NTP,0000,0000,0000,,hours on Friday
Dialogue: 0,0:01:39.67,0:01:41.50,*Default,NTP,0000,0000,0000,,in addition to the regular office hours
Dialogue: 0,0:01:41.50,0:01:43.50,*Default,NTP,0000,0000,0000,,to help you with lab and homework
Dialogue: 0,0:01:43.90,0:01:45.70,*Default,NTP,0000,0000,0000,,since there's nothing do on Friday
Dialogue: 0,0:01:45.87,0:01:48.60,*Default,NTP,0000,0000,0000,,we'll just hold these on the regular office hour
Dialogue: 0,0:01:48.60,0:01:49.40,*Default,NTP,0000,0000,0000,,q
Dialogue: 0,0:01:50.10,0:01:53.10,*Default,NTP,0000,0000,0000,,so if you'd like to talk to an experienced staff member
Dialogue: 0,0:01:53.27,0:01:53.93,*Default,NTP,0000,0000,0000,,about anything
Dialogue: 0,0:01:53.93,0:01:56.53,*Default,NTP,0000,0000,0000,,related to the course or berkeley in general
Dialogue: 0,0:01:56.90,0:01:58.53,*Default,NTP,0000,0000,0000,,come drop by on Friday
Dialogue: 0,0:01:58.73,0:02:00.57,*Default,NTP,0000,0000,0000,,and they'd be happy to talk to you then
Dialogue: 0,0:02:02.10,0:02:03.33,*Default,NTP,0000,0000,0000,,sequential data
Dialogue: 0,0:02:03.60,0:02:08.27,*Default,NTP,0000,0000,0000,,can be represented implicitly using an iterator
Dialogue: 0,0:02:09.37,0:02:11.73,*Default,NTP,0000,0000,0000,,iterators are common interface
Dialogue: 0,0:02:11.73,0:02:13.67,*Default,NTP,0000,0000,0000,,in many programming languages
Dialogue: 0,0:02:13.90,0:02:15.77,*Default,NTP,0000,0000,0000,,and they're used in python
Dialogue: 0,0:02:16.10,0:02:16.93,*Default,NTP,0000,0000,0000,,as a way
Dialogue: 0,0:02:16.93,0:02:20.70,*Default,NTP,0000,0000,0000,,to access the elements of lots of different containers
Dialogue: 0,0:02:21.93,0:02:24.13,*Default,NTP,0000,0000,0000,,a container can provide an iterator
Dialogue: 0,0:02:24.57,0:02:25.33,*Default,NTP,0000,0000,0000,,which in turn
Dialogue: 0,0:02:25.33,0:02:28.20,*Default,NTP,0000,0000,0000,,provides access to its elements in some order
Dialogue: 0,0:02:29.77,0:02:33.30,*Default,NTP,0000,0000,0000,,the built in functions iter and next create
Dialogue: 0,0:02:33.30,0:02:36.07,*Default,NTP,0000,0000,0000,,an advanced iterators respectively
Dialogue: 0,0:02:36.77,0:02:38.57,*Default,NTP,0000,0000,0000,,so itter takes anything itterable
Dialogue: 0,0:02:38.57,0:02:39.97,*Default,NTP,0000,0000,0000,,which could be a container
Dialogue: 0,0:02:40.00,0:02:41.80,*Default,NTP,0000,0000,0000,,or something you create yourself
Dialogue: 0,0:02:42.33,0:02:44.90,*Default,NTP,0000,0000,0000,,and it returns in iterator over the elements
Dialogue: 0,0:02:45.00,0:02:46.50,*Default,NTP,0000,0000,0000,,of an iterable value
Dialogue: 0,0:02:46.87,0:02:48.93,*Default,NTP,0000,0000,0000,,next is a built in function
Dialogue: 0,0:02:49.07,0:02:51.77,*Default,NTP,0000,0000,0000,,that returns the next element in an iterator
Dialogue: 0,0:02:52.67,0:02:54.20,*Default,NTP,0000,0000,0000,,let's say I have a container
Dialogue: 0,0:02:54.20,0:02:56.87,*Default,NTP,0000,0000,0000,,a list containing three four and five
Dialogue: 0,0:02:57.30,0:03:01.40,*Default,NTP,0000,0000,0000,,if I call iter on that list s I get an iterator t
Dialogue: 0,0:03:02.27,0:03:03.47,*Default,NTP,0000,0000,0000,,that iterator
Dialogue: 0,0:03:03.77,0:03:06.17,*Default,NTP,0000,0000,0000,,knows the contents of the list
Dialogue: 0,0:03:06.30,0:03:09.60,*Default,NTP,0000,0000,0000,,and it also has a marker for what's next
Dialogue: 0,0:03:09.90,0:03:12.80,*Default,NTP,0000,0000,0000,,so you can think of an iterator as a position
Dialogue: 0,0:03:12.80,0:03:14.10,*Default,NTP,0000,0000,0000,,in some sequence
Dialogue: 0,0:03:14.60,0:03:17.70,*Default,NTP,0000,0000,0000,,it gives you access to the element of that position
Dialogue: 0,0:03:17.87,0:03:19.73,*Default,NTP,0000,0000,0000,,and everything after it
Dialogue: 0,0:03:20.90,0:03:23.73,*Default,NTP,0000,0000,0000,,if I call next on t I'd get the No.3
Dialogue: 0,0:03:24.37,0:03:26.87,*Default,NTP,0000,0000,0000,,as a consequence of calling next
Dialogue: 0,0:03:27.00,0:03:29.60,*Default,NTP,0000,0000,0000,,the marker here is going to advance
Dialogue: 0,0:03:30.10,0:03:32.53,*Default,NTP,0000,0000,0000,,which means the next time I call next
Dialogue: 0,0:03:32.57,0:03:34.87,*Default,NTP,0000,0000,0000,,I'll get four instead of three
Dialogue: 0,0:03:35.17,0:03:38.30,*Default,NTP,0000,0000,0000,,and since I've called next twice I've advanced twice
Dialogue: 0,0:03:38.30,0:03:40.20,*Default,NTP,0000,0000,0000,,and now the markers set to five
Dialogue: 0,0:03:41.87,0:03:45.17,*Default,NTP,0000,0000,0000,,if I create a second iterator for the same container
Dialogue: 0,0:03:45.67,0:03:49.07,*Default,NTP,0000,0000,0000,,that means I have a second marker into the same list
Dialogue: 0,0:03:49.77,0:03:54.10,*Default,NTP,0000,0000,0000,,so you is an iterator that hasn't been advanced at all
Dialogue: 0,0:03:54.47,0:03:57.37,*Default,NTP,0000,0000,0000,,if I call next on you I'll get the No.3
Dialogue: 0,0:03:58.33,0:04:00.80,*Default,NTP,0000,0000,0000,,now t doesn't forget where it was
Dialogue: 0,0:04:00.80,0:04:02.57,*Default,NTP,0000,0000,0000,,just because I created you
Dialogue: 0,0:04:03.13,0:04:07.20,*Default,NTP,0000,0000,0000,,so if I ask what's next in t I'll get the No.5
Dialogue: 0,0:04:07.50,0:04:10.80,*Default,NTP,0000,0000,0000,,and the iterator will advance past the last element
Dialogue: 0,0:04:10.93,0:04:13.70,*Default,NTP,0000,0000,0000,,saying that it's at the end of this list
Dialogue: 0,0:04:14.10,0:04:16.90,*Default,NTP,0000,0000,0000,,it's still the case that I can ask for elements in you
Dialogue: 0,0:04:16.90,0:04:19.67,*Default,NTP,0000,0000,0000,,so if I ask what's the next thing in you it'll say for
Dialogue: 0,0:04:20.60,0:04:23.70,*Default,NTP,0000,0000,0000,,so t and you are iterating over the same values
Dialogue: 0,0:04:23.70,0:04:26.27,*Default,NTP,0000,0000,0000,,but they're otherwise independent in the position
Dialogue: 0,0:04:26.37,0:04:28.90,*Default,NTP,0000,0000,0000,,that they're going to give you next
Dialogue: 0,0:04:30.20,0:04:32.27,*Default,NTP,0000,0000,0000,,okay let's build ourselves a list
Dialogue: 0,0:04:32.27,0:04:34.13,*Default,NTP,0000,0000,0000,,that's slightly more complicated than when
Dialogue: 0,0:04:34.13,0:04:35.60,*Default,NTP,0000,0000,0000,,the one you saw before
Dialogue: 0,0:04:35.90,0:04:37.57,*Default,NTP,0000,0000,0000,,this one's a nested list
Dialogue: 0,0:04:37.60,0:04:41.97,*Default,NTP,0000,0000,0000,,if I ask for the next value in a list I get an error
Dialogue: 0,0:04:41.97,0:04:43.67,*Default,NTP,0000,0000,0000,,that's not what next does
Dialogue: 0,0:04:43.80,0:04:46.87,*Default,NTP,0000,0000,0000,,next first expects you to have created an iterator
Dialogue: 0,0:04:46.87,0:04:49.37,*Default,NTP,0000,0000,0000,,over the contents of some container
Dialogue: 0,0:04:49.97,0:04:53.47,*Default,NTP,0000,0000,0000,,at which point then I can ask for the next value of t
Dialogue: 0,0:04:53.60,0:04:55.90,*Default,NTP,0000,0000,0000,,which will give me the sub list one two
Dialogue: 0,0:04:56.40,0:04:57.80,*Default,NTP,0000,0000,0000,,so all it does is give me
Dialogue: 0,0:04:57.87,0:04:59.73,*Default,NTP,0000,0000,0000,,the element and index zero
Dialogue: 0,0:04:59.73,0:05:01.90,*Default,NTP,0000,0000,0000,,of the list that I'm iterating over
Dialogue: 0,0:05:02.20,0:05:03.97,*Default,NTP,0000,0000,0000,,and if I ask for the next t again
Dialogue: 0,0:05:03.97,0:05:05.47,*Default,NTP,0000,0000,0000,,I'll get a different value
Dialogue: 0,0:05:06.30,0:05:09.67,*Default,NTP,0000,0000,0000,,if you ever want all the values in an iterator
Dialogue: 0,0:05:10.33,0:05:12.07,*Default,NTP,0000,0000,0000,,you can just list them out
Dialogue: 0,0:05:12.93,0:05:14.13,*Default,NTP,0000,0000,0000,,now here you see that
Dialogue: 0,0:05:14.13,0:05:16.57,*Default,NTP,0000,0000,0000,,we only get the values that are left
Dialogue: 0,0:05:16.57,0:05:20.90,*Default,NTP,0000,0000,0000,,we already used up the list one two and the No.3
Dialogue: 0,0:05:21.13,0:05:22.37,*Default,NTP,0000,0000,0000,,so when I build a list
Dialogue: 0,0:05:22.37,0:05:24.60,*Default,NTP,0000,0000,0000,,of the remaining contents in an iterator
Dialogue: 0,0:05:24.60,0:05:26.70,*Default,NTP,0000,0000,0000,,I just get the numbers four and five
Dialogue: 0,0:05:27.80,0:05:30.93,*Default,NTP,0000,0000,0000,,now if I ask for the next element in t at this point
Dialogue: 0,0:05:30.93,0:05:32.00,*Default,NTP,0000,0000,0000,,I get an error
Dialogue: 0,0:05:32.33,0:05:35.07,*Default,NTP,0000,0000,0000,,a special kind of error called stop iteration
Dialogue: 0,0:05:35.37,0:05:37.13,*Default,NTP,0000,0000,0000,,and that's how you tell you at the end
Dialogue: 0,0:05:37.20,0:05:40.57,*Default,NTP,0000,0000,0000,,is that python will raise a stop iteration exception
Dialogue: 0,0:05:41.97,0:05:44.53,*Default,NTP,0000,0000,0000,,let's talk about dictionary iteration
Dialogue: 0,0:05:45.07,0:05:45.70,*Default,NTP,0000,0000,0000,,you can get
Dialogue: 0,0:05:45.70,0:05:48.93,*Default,NTP,0000,0000,0000,,multiple views of the contents of a dictionary
Dialogue: 0,0:05:49.20,0:05:52.33,*Default,NTP,0000,0000,0000,,which are different objects that are all itterable
Dialogue: 0,0:05:53.30,0:05:56.27,*Default,NTP,0000,0000,0000,,an iterable value is any value that could be
Dialogue: 0,0:05:56.27,0:05:57.37,*Default,NTP,0000,0000,0000,,passed to itter
Dialogue: 0,0:05:57.57,0:06:00.73,*Default,NTP,0000,0000,0000,,the built in function to produce an iterator
Dialogue: 0,0:06:01.50,0:06:04.00,*Default,NTP,0000,0000,0000,,and an interator is returned from iter
Dialogue: 0,0:06:04.10,0:06:07.33,*Default,NTP,0000,0000,0000,,and can be passed to the built in next function
Dialogue: 0,0:06:07.87,0:06:10.60,*Default,NTP,0000,0000,0000,,all iterators are mutable objects
Dialogue: 0,0:06:10.90,0:06:12.80,*Default,NTP,0000,0000,0000,,and when you call next on them
Dialogue: 0,0:06:12.90,0:06:15.67,*Default,NTP,0000,0000,0000,,they mutate to point to the next element
Dialogue: 0,0:06:16.87,0:06:21.57,*Default,NTP,0000,0000,0000,,a dictionary and its keys and its values and its items
Dialogue: 0,0:06:21.57,0:06:23.70,*Default,NTP,0000,0000,0000,,are all itterable values
Dialogue: 0,0:06:23.73,0:06:25.40,*Default,NTP,0000,0000,0000,,all can be passed into itter
Dialogue: 0,0:06:25.60,0:06:29.20,*Default,NTP,0000,0000,0000,,and the resulting iterators can be passed into next
Dialogue: 0,0:06:30.20,0:06:32.93,*Default,NTP,0000,0000,0000,,the order of items in a dictionary is the order
Dialogue: 0,0:06:32.93,0:06:34.33,*Default,NTP,0000,0000,0000,,in which they were added
Dialogue: 0,0:06:34.87,0:06:37.97,*Default,NTP,0000,0000,0000,,this is true of the most recent versions of python
Dialogue: 0,0:06:38.10,0:06:40.27,*Default,NTP,0000,0000,0000,,starting at python 3.6
Dialogue: 0,0:06:40.87,0:06:44.07,*Default,NTP,0000,0000,0000,,however an older versions of python
Dialogue: 0,0:06:44.33,0:06:47.90,*Default,NTP,0000,0000,0000,,items in a dictionary appeared in an arbitrary order
Dialogue: 0,0:06:47.97,0:06:49.33,*Default,NTP,0000,0000,0000,,dictionaries were called
Dialogue: 0,0:06:49.33,0:06:51.47,*Default,NTP,0000,0000,0000,,unordered collections of key value
Dialogue: 0,0:06:51.47,0:06:52.80,*Default,NTP,0000,0000,0000,,pairs as a result
Dialogue: 0,0:06:53.40,0:06:54.80,*Default,NTP,0000,0000,0000,,but now they are ordered
Dialogue: 0,0:06:55.10,0:06:56.80,*Default,NTP,0000,0000,0000,,although when you write python code
Dialogue: 0,0:06:56.80,0:06:58.70,*Default,NTP,0000,0000,0000,,is a good idea to keep in mind
Dialogue: 0,0:06:58.80,0:06:59.77,*Default,NTP,0000,0000,0000,,that depending on the
Dialogue: 0,0:06:59.77,0:07:03.10,*Default,NTP,0000,0000,0000,,version of python that people use to run your program
Dialogue: 0,0:07:03.27,0:07:06.20,*Default,NTP,0000,0000,0000,,ordering of dictionaries may not be reliable
Dialogue: 0,0:07:06.87,0:07:08.93,*Default,NTP,0000,0000,0000,,but I'll assume in my examples
Dialogue: 0,0:07:08.93,0:07:11.40,*Default,NTP,0000,0000,0000,,that we're using a recent version of python
Dialogue: 0,0:07:11.53,0:07:12.40,*Default,NTP,0000,0000,0000,,and therefore
Dialogue: 0,0:07:12.57,0:07:14.47,*Default,NTP,0000,0000,0000,,dictionaries will end up ordered
Dialogue: 0,0:07:14.60,0:07:16.70,*Default,NTP,0000,0000,0000,,according to how they were constructed
Dialogue: 0,0:07:17.80,0:07:20.37,*Default,NTP,0000,0000,0000,,so if I have a dictionary with three keys and three
Dialogue: 0,0:07:20.37,0:07:23.80,*Default,NTP,0000,0000,0000,,values one is bound to one two to two three to three
Dialogue: 0,0:07:24.13,0:07:28.00,*Default,NTP,0000,0000,0000,,and then I add a 4th value zero is bound to zero
Dialogue: 0,0:07:28.93,0:07:30.40,*Default,NTP,0000,0000,0000,,then I would expect
Dialogue: 0,0:07:30.40,0:07:32.33,*Default,NTP,0000,0000,0000,,that iterating over the keys would give me
Dialogue: 0,0:07:32.33,0:07:34.07,*Default,NTP,0000,0000,0000,,1 2 3 and then zero
Dialogue: 0,0:07:34.07,0:07:36.13,*Default,NTP,0000,0000,0000,,because zero was added last
Dialogue: 0,0:07:37.30,0:07:40.20,*Default,NTP,0000,0000,0000,,and here's how I iterate over the keys
Dialogue: 0,0:07:40.60,0:07:44.60,*Default,NTP,0000,0000,0000,,I say I want an iterator by calling the iter function
Dialogue: 0,0:07:45.33,0:07:46.73,*Default,NTP,0000,0000,0000,,over the keys
Dialogue: 0,0:07:47.13,0:07:49.93,*Default,NTP,0000,0000,0000,,if you don't say d dot keys but instead just say d
Dialogue: 0,0:07:49.93,0:07:51.20,*Default,NTP,0000,0000,0000,,you get the same effect
Dialogue: 0,0:07:51.20,0:07:52.87,*Default,NTP,0000,0000,0000,,you iterate over the keys
Dialogue: 0,0:07:53.80,0:07:56.20,*Default,NTP,0000,0000,0000,,and this k is an iterator over keys
Dialogue: 0,0:07:56.20,0:07:58.67,*Default,NTP,0000,0000,0000,,which means if I ask for the next one I'll get one
Dialogue: 0,0:07:58.67,0:08:00.07,*Default,NTP,0000,0000,0000,,then two then three
Dialogue: 0,0:08:00.30,0:08:03.97,*Default,NTP,0000,0000,0000,,then zero if instead I wanted to iterate over
Dialogue: 0,0:08:03.97,0:08:06.00,*Default,NTP,0000,0000,0000,,the values in a dictionary
Dialogue: 0,0:08:06.30,0:08:08.30,*Default,NTP,0000,0000,0000,,I would ask for the values
Dialogue: 0,0:08:08.97,0:08:11.47,*Default,NTP,0000,0000,0000,,this object is an iterable object
Dialogue: 0,0:08:11.67,0:08:15.17,*Default,NTP,0000,0000,0000,,that provides access to all of the values in the order
Dialogue: 0,0:08:15.33,0:08:17.37,*Default,NTP,0000,0000,0000,,that the dictionary was constructed
Dialogue: 0,0:08:17.67,0:08:20.93,*Default,NTP,0000,0000,0000,,so the next value is one then two then three then zero
Dialogue: 0,0:08:21.60,0:08:24.87,*Default,NTP,0000,0000,0000,,and finally I can ask for items in the dictionary
Dialogue: 0,0:08:25.07,0:08:28.47,*Default,NTP,0000,0000,0000,,those are key value pairs represented as tuples
Dialogue: 0,0:08:28.93,0:08:30.57,*Default,NTP,0000,0000,0000,,so the first one is one
Dialogue: 0,0:08:30.67,0:08:32.93,*Default,NTP,0000,0000,0000,,where we get both the key and the value
Dialogue: 0,0:08:32.93,0:08:34.47,*Default,NTP,0000,0000,0000,,in a two element tuple
Dialogue: 0,0:08:34.67,0:08:36.50,*Default,NTP,0000,0000,0000,,and then two then three then zero
Dialogue: 0,0:08:37.33,0:08:38.10,*Default,NTP,0000,0000,0000,,so there are many
Dialogue: 0,0:08:38.10,0:08:40.80,*Default,NTP,0000,0000,0000,,ways to iterate over the contents of a dictionary
Dialogue: 0,0:08:40.80,0:08:42.80,*Default,NTP,0000,0000,0000,,and the way that python is designed
Dialogue: 0,0:08:42.90,0:08:44.73,*Default,NTP,0000,0000,0000,,there's only one dictionary d
Dialogue: 0,0:08:45.13,0:08:47.53,*Default,NTP,0000,0000,0000,,I can access different views of it
Dialogue: 0,0:08:47.53,0:08:48.67,*Default,NTP,0000,0000,0000,,by asking for the keys
Dialogue: 0,0:08:48.67,0:08:50.07,*Default,NTP,0000,0000,0000,,values or items
Dialogue: 0,0:08:50.20,0:08:53.10,*Default,NTP,0000,0000,0000,,and I can get an iterator for any of those
Dialogue: 0,0:08:54.10,0:08:56.50,*Default,NTP,0000,0000,0000,,now one interesting thing to note is that if I
Dialogue: 0,0:08:56.50,0:08:57.80,*Default,NTP,0000,0000,0000,,have a dictionary
Dialogue: 0,0:08:58.67,0:09:02.70,*Default,NTP,0000,0000,0000,,and I've already constructed an iterator over the keys
Dialogue: 0,0:09:03.10,0:09:06.33,*Default,NTP,0000,0000,0000,,and I'm in the middle of iterating over those keys
Dialogue: 0,0:09:06.50,0:09:09.90,*Default,NTP,0000,0000,0000,,and I change the dictionary
Dialogue: 0,0:09:10.53,0:09:14.33,*Default,NTP,0000,0000,0000,,now it's the case that the iterator is invalid
Dialogue: 0,0:09:14.67,0:09:16.20,*Default,NTP,0000,0000,0000,,and so I see this error
Dialogue: 0,0:09:16.47,0:09:19.80,*Default,NTP,0000,0000,0000,,dictionary changed size during iteration
Dialogue: 0,0:09:20.27,0:09:23.57,*Default,NTP,0000,0000,0000,,which says that I cannot use k anymore
Dialogue: 0,0:09:23.73,0:09:26.20,*Default,NTP,0000,0000,0000,,because the dictionary has been mutated
Dialogue: 0,0:09:26.40,0:09:28.20,*Default,NTP,0000,0000,0000,,while I was using k
Dialogue: 0,0:09:28.73,0:09:31.33,*Default,NTP,0000,0000,0000,,so our dictionary now looks like this
Dialogue: 0,0:09:32.27,0:09:35.87,*Default,NTP,0000,0000,0000,,if I just change the value for one of the keys
Dialogue: 0,0:09:35.90,0:09:38.67,*Default,NTP,0000,0000,0000,,while I'm iterating through the keys
Dialogue: 0,0:09:38.67,0:09:44.57,*Default,NTP,0000,0000,0000,,so here's one two and then I change 0 2 5
Dialogue: 0,0:09:45.13,0:09:46.93,*Default,NTP,0000,0000,0000,,I can continue to iterate
Dialogue: 0,0:09:47.10,0:09:48.67,*Default,NTP,0000,0000,0000,,because I haven't changed
Dialogue: 0,0:09:48.67,0:09:50.93,*Default,NTP,0000,0000,0000,,the shape or the structure of the dictionary
Dialogue: 0,0:09:50.93,0:09:53.40,*Default,NTP,0000,0000,0000,,I've just changed one of the values for the keys
Dialogue: 0,0:09:53.60,0:09:55.67,*Default,NTP,0000,0000,0000,,but if the dictionary changes size
Dialogue: 0,0:09:55.70,0:09:58.47,*Default,NTP,0000,0000,0000,,then I can't use any of the iterators I've constructed
Dialogue: 0,0:09:58.50,0:10:00.57,*Default,NTP,0000,0000,0000,,instead I need to make new ones
Dialogue: 0,0:10:00.57,0:10:03.53,*Default,NTP,0000,0000,0000,,and that's true for keys values or items
Dialogue: 0,0:10:06.20,0:10:09.50,*Default,NTP,0000,0000,0000,,four statements iterate over iterable values
Dialogue: 0,0:10:09.73,0:10:14.17,*Default,NTP,0000,0000,0000,,that can also iterate over iterators themselves
Dialogue: 0,0:10:15.27,0:10:18.57,*Default,NTP,0000,0000,0000,,let's say I have a range from three to six
Dialogue: 0,0:10:18.90,0:10:21.30,*Default,NTP,0000,0000,0000,,the contents of that range are the numbers three
Dialogue: 0,0:10:21.30,0:10:22.57,*Default,NTP,0000,0000,0000,,four and five
Dialogue: 0,0:10:23.40,0:10:26.10,*Default,NTP,0000,0000,0000,,if I iterate over that range
Dialogue: 0,0:10:26.40,0:10:28.20,*Default,NTP,0000,0000,0000,,I see all of the elements
Dialogue: 0,0:10:28.27,0:10:29.57,*Default,NTP,0000,0000,0000,,and if I do it again
Dialogue: 0,0:10:29.57,0:10:31.20,*Default,NTP,0000,0000,0000,,I see all the elements again
Dialogue: 0,0:10:31.20,0:10:33.60,*Default,NTP,0000,0000,0000,,because I haven't changed the range
Dialogue: 0,0:10:34.60,0:10:36.80,*Default,NTP,0000,0000,0000,,iterators are a little different
Dialogue: 0,0:10:36.93,0:10:40.87,*Default,NTP,0000,0000,0000,,so if I get a range iterator from my range
Dialogue: 0,0:10:41.90,0:10:44.10,*Default,NTP,0000,0000,0000,,this has a particular position in the
Dialogue: 0,0:10:44.10,0:10:45.80,*Default,NTP,0000,0000,0000,,range associated with it
Dialogue: 0,0:10:45.90,0:10:49.37,*Default,NTP,0000,0000,0000,,which changes every time I call next
Dialogue: 0,0:10:50.47,0:10:51.67,*Default,NTP,0000,0000,0000,,so I can ask
Dialogue: 0,0:10:51.67,0:10:54.80,*Default,NTP,0000,0000,0000,,for each element in the rest of the iterator
Dialogue: 0,0:10:56.37,0:10:59.77,*Default,NTP,0000,0000,0000,,but it will not print out three because three is past
Dialogue: 0,0:11:00.00,0:11:02.70,*Default,NTP,0000,0000,0000,,instead it will just print out four and five
Dialogue: 0,0:11:05.07,0:11:06.57,*Default,NTP,0000,0000,0000,,now four statements also
Dialogue: 0,0:11:06.57,0:11:09.07,*Default,NTP,0000,0000,0000,,move the marker within the iterator
Dialogue: 0,0:11:09.27,0:11:13.30,*Default,NTP,0000,0000,0000,,advancing it all the way to the end of the sequence
Dialogue: 0,0:11:14.00,0:11:15.77,*Default,NTP,0000,0000,0000,,so I still have my range
Dialogue: 0,0:11:15.87,0:11:18.33,*Default,NTP,0000,0000,0000,,I'm going to build a new range iterator
Dialogue: 0,0:11:18.67,0:11:20.67,*Default,NTP,0000,0000,0000,,that starts at the very beginning
Dialogue: 0,0:11:20.90,0:11:23.77,*Default,NTP,0000,0000,0000,,and for every element in our eye
Dialogue: 0,0:11:23.77,0:11:25.50,*Default,NTP,0000,0000,0000,,I'm going to print out eye
Dialogue: 0,0:11:25.93,0:11:28.00,*Default,NTP,0000,0000,0000,,so I've passed a range iterator
Dialogue: 0,0:11:28.17,0:11:30.87,*Default,NTP,0000,0000,0000,,to the four statement to be processed
Dialogue: 0,0:11:31.33,0:11:34.37,*Default,NTP,0000,0000,0000,,now there's nothing left in the range iterator
Dialogue: 0,0:11:34.67,0:11:36.67,*Default,NTP,0000,0000,0000,,if I iterate over it again
Dialogue: 0,0:11:36.70,0:11:41.30,*Default,NTP,0000,0000,0000,,I see nothing because I'm already at the end of roi
Dialogue: 0,0:11:41.53,0:11:44.17,*Default,NTP,0000,0000,0000,,that's another consequence of using an iterator
Dialogue: 0,0:11:44.30,0:11:45.67,*Default,NTP,0000,0000,0000,,in a four statement
Dialogue: 0,0:11:46.57,0:11:47.90,*Default,NTP,0000,0000,0000,,so to summarize
Dialogue: 0,0:11:48.17,0:11:51.10,*Default,NTP,0000,0000,0000,,if I use an iterator in a four statement
Dialogue: 0,0:11:51.20,0:11:51.93,*Default,NTP,0000,0000,0000,,I can still
Dialogue: 0,0:11:51.93,0:11:54.80,*Default,NTP,0000,0000,0000,,go through all of the elements until I reach the end
Dialogue: 0,0:11:55.33,0:11:57.67,*Default,NTP,0000,0000,0000,,but that will advance the iterator
Dialogue: 0,0:11:57.67,0:11:59.53,*Default,NTP,0000,0000,0000,,so that I can't use it again
Dialogue: 0,0:12:00.13,0:12:01.33,*Default,NTP,0000,0000,0000,,on the other hand
Dialogue: 0,0:12:01.50,0:12:04.17,*Default,NTP,0000,0000,0000,,if I'm working with an iterable object
Dialogue: 0,0:12:04.17,0:12:06.10,*Default,NTP,0000,0000,0000,,like the range itself
Dialogue: 0,0:12:07.00,0:12:09.93,*Default,NTP,0000,0000,0000,,every time I use that in a forest statement
Dialogue: 0,0:12:10.00,0:12:12.70,*Default,NTP,0000,0000,0000,,I'm able to go through the entire contents
Dialogue: 0,0:12:12.70,0:12:14.37,*Default,NTP,0000,0000,0000,,from beginning to end
Dialogue: 0,0:12:14.50,0:12:18.10,*Default,NTP,0000,0000,0000,,without worrying about anything changing as I do so
Dialogue: 0,0:12:21.40,0:12:22.50,*Default,NTP,0000,0000,0000,,a great deal of
Dialogue: 0,0:12:22.50,0:12:25.97,*Default,NTP,0000,0000,0000,,processing of sequences and other iterable values
Dialogue: 0,0:12:26.27,0:12:28.47,*Default,NTP,0000,0000,0000,,uses built in functions
Dialogue: 0,0:12:28.87,0:12:30.90,*Default,NTP,0000,0000,0000,,but take in one iterable value
Dialogue: 0,0:12:30.97,0:12:32.67,*Default,NTP,0000,0000,0000,,and give you back an iterator
Dialogue: 0,0:12:33.77,0:12:36.37,*Default,NTP,0000,0000,0000,,so many built in python sequence operations return
Dialogue: 0,0:12:36.37,0:12:40.00,*Default,NTP,0000,0000,0000,,iterators that compute results lazily
Dialogue: 0,0:12:40.70,0:12:43.07,*Default,NTP,0000,0000,0000,,what lazy computation means
Dialogue: 0,0:12:43.07,0:12:45.53,*Default,NTP,0000,0000,0000,,is that a result is only computed
Dialogue: 0,0:12:45.67,0:12:47.70,*Default,NTP,0000,0000,0000,,when it has been requested
Dialogue: 0,0:12:48.37,0:12:49.40,*Default,NTP,0000,0000,0000,,so the interpreter
Dialogue: 0,0:12:49.40,0:12:52.50,*Default,NTP,0000,0000,0000,,gets ready to compute whatever is desired
Dialogue: 0,0:12:52.77,0:12:54.53,*Default,NTP,0000,0000,0000,,but doesn't actually compute it
Dialogue: 0,0:12:54.53,0:12:57.17,*Default,NTP,0000,0000,0000,,unless that value is going to be used
Dialogue: 0,0:12:58.13,0:12:59.97,*Default,NTP,0000,0000,0000,,let me show you some examples
Dialogue: 0,0:13:00.53,0:13:02.17,*Default,NTP,0000,0000,0000,,there's a function called map
Dialogue: 0,0:13:02.50,0:13:05.40,*Default,NTP,0000,0000,0000,,that takes in another function and in iterable
Dialogue: 0,0:13:05.57,0:13:06.53,*Default,NTP,0000,0000,0000,,and it applies
Dialogue: 0,0:13:06.53,0:13:09.00,*Default,NTP,0000,0000,0000,,that function to each element in the iterable
Dialogue: 0,0:13:09.57,0:13:11.73,*Default,NTP,0000,0000,0000,,but instead of applying it immediately
Dialogue: 0,0:13:11.73,0:13:13.47,*Default,NTP,0000,0000,0000,,it returns in iterator
Dialogue: 0,0:13:13.77,0:13:17.53,*Default,NTP,0000,0000,0000,,in iterator that iterates over the values funk x
Dialogue: 0,0:13:17.73,0:13:19.93,*Default,NTP,0000,0000,0000,,for every x in the iterable
Dialogue: 0,0:13:20.80,0:13:22.67,*Default,NTP,0000,0000,0000,,there's another built in function filter
Dialogue: 0,0:13:22.67,0:13:25.00,*Default,NTP,0000,0000,0000,,which takes a predicate function in an iterable
Dialogue: 0,0:13:25.00,0:13:27.07,*Default,NTP,0000,0000,0000,,and it iterates over x and iterable
Dialogue: 0,0:13:27.07,0:13:30.47,*Default,NTP,0000,0000,0000,,if it's the case that funk x returns a true value
Dialogue: 0,0:13:31.50,0:13:33.37,*Default,NTP,0000,0000,0000,,zip takes two iterables
Dialogue: 0,0:13:33.37,0:13:36.80,*Default,NTP,0000,0000,0000,,it iterates over co indexed xy pairs
Dialogue: 0,0:13:38.07,0:13:42.17,*Default,NTP,0000,0000,0000,,reversed iterates over x in a sequence in reverse order
Dialogue: 0,0:13:42.97,0:13:45.13,*Default,NTP,0000,0000,0000,,all of these return iterators
Dialogue: 0,0:13:45.57,0:13:48.27,*Default,NTP,0000,0000,0000,,and those iterators produce these values
Dialogue: 0,0:13:48.37,0:13:50.40,*Default,NTP,0000,0000,0000,,each time you call next on them
Dialogue: 0,0:13:52.00,0:13:52.77,*Default,NTP,0000,0000,0000,,if you ever want to
Dialogue: 0,0:13:52.77,0:13:55.67,*Default,NTP,0000,0000,0000,,view the contents of an iterator in its entirety
Dialogue: 0,0:13:55.70,0:13:57.53,*Default,NTP,0000,0000,0000,,you can place the resulting elements
Dialogue: 0,0:13:57.53,0:13:58.70,*Default,NTP,0000,0000,0000,,into a new container
Dialogue: 0,0:13:58.93,0:14:01.10,*Default,NTP,0000,0000,0000,,by calling list or tuple
Dialogue: 0,0:14:01.53,0:14:03.20,*Default,NTP,0000,0000,0000,,or sorted sorted
Dialogue: 0,0:14:03.20,0:14:04.80,*Default,NTP,0000,0000,0000,,creates a sorted list containing
Dialogue: 0,0:14:04.80,0:14:06.70,*Default,NTP,0000,0000,0000,,all of the elements in the iterable
Dialogue: 0,0:14:07.77,0:14:09.20,*Default,NTP,0000,0000,0000,,let's do some demos
Dialogue: 0,0:14:10.47,0:14:13.47,*Default,NTP,0000,0000,0000,,so if I create a list bcd
Dialogue: 0,0:14:14.93,0:14:17.80,*Default,NTP,0000,0000,0000,,I could upper case all of those elements
Dialogue: 0,0:14:17.93,0:14:21.70,*Default,NTP,0000,0000,0000,,by invoking the upper method for x in bcd
Dialogue: 0,0:14:23.33,0:14:26.50,*Default,NTP,0000,0000,0000,,I could get a similar effect by calling a map
Dialogue: 0,0:14:26.70,0:14:28.20,*Default,NTP,0000,0000,0000,,on a lambda function
Dialogue: 0,0:14:28.47,0:14:31.53,*Default,NTP,0000,0000,0000,,that computes the upper case version
Dialogue: 0,0:14:31.67,0:14:33.80,*Default,NTP,0000,0000,0000,,of every element in bcd
Dialogue: 0,0:14:34.77,0:14:37.20,*Default,NTP,0000,0000,0000,,but what I get is not the list
Dialogue: 0,0:14:37.37,0:14:39.67,*Default,NTP,0000,0000,0000,,capital b capital c capital d
Dialogue: 0,0:14:39.87,0:14:43.33,*Default,NTP,0000,0000,0000,,but instead a map object which is an iterator
Dialogue: 0,0:14:43.90,0:14:45.87,*Default,NTP,0000,0000,0000,,so if I give it the name m
Dialogue: 0,0:14:46.37,0:14:49.07,*Default,NTP,0000,0000,0000,,then I can ask for the next upper case letter
Dialogue: 0,0:14:49.07,0:14:50.73,*Default,NTP,0000,0000,0000,,which is b and then c
Dialogue: 0,0:14:50.73,0:14:52.67,*Default,NTP,0000,0000,0000,,and then d and then we're done
Dialogue: 0,0:14:53.73,0:14:56.73,*Default,NTP,0000,0000,0000,,now how those results computed is quite interesting
Dialogue: 0,0:14:57.40,0:14:59.17,*Default,NTP,0000,0000,0000,,less to find a function double
Dialogue: 0,0:14:59.37,0:15:01.67,*Default,NTP,0000,0000,0000,,which takes an x and prints out
Dialogue: 0,0:15:01.77,0:15:04.07,*Default,NTP,0000,0000,0000,,exactly when x got doubled
Dialogue: 0,0:15:04.70,0:15:08.30,*Default,NTP,0000,0000,0000,,x is doubled into
Dialogue: 0,0:15:09.17,0:15:10.70,*Default,NTP,0000,0000,0000,,two times x
Dialogue: 0,0:15:11.47,0:15:13.60,*Default,NTP,0000,0000,0000,,right now two times x
Dialogue: 0,0:15:15.33,0:15:20.60,*Default,NTP,0000,0000,0000,,if I map double over the list 3 5 7
Dialogue: 0,0:15:21.73,0:15:25.17,*Default,NTP,0000,0000,0000,,I get a map object and you notice nothing was printed
Dialogue: 0,0:15:26.37,0:15:28.20,*Default,NTP,0000,0000,0000,,so I'll give this thing the name m
Dialogue: 0,0:15:28.20,0:15:30.73,*Default,NTP,0000,0000,0000,,and then I'll ask for the next element in m
Dialogue: 0,0:15:30.97,0:15:33.73,*Default,NTP,0000,0000,0000,,and at that very moment it doubles three
Dialogue: 0,0:15:33.77,0:15:35.17,*Default,NTP,0000,0000,0000,,to get the No.6
Dialogue: 0,0:15:35.50,0:15:38.07,*Default,NTP,0000,0000,0000,,not until I ask for the next element will it double
Dialogue: 0,0:15:38.07,0:15:39.50,*Default,NTP,0000,0000,0000,,five to get the No.10
Dialogue: 0,0:15:39.60,0:15:40.50,*Default,NTP,0000,0000,0000,,and then finally
Dialogue: 0,0:15:40.50,0:15:42.60,*Default,NTP,0000,0000,0000,,if I ask for the next element after that
Dialogue: 0,0:15:42.60,0:15:44.50,*Default,NTP,0000,0000,0000,,it computes the No.14
Dialogue: 0,0:15:46.13,0:15:47.40,*Default,NTP,0000,0000,0000,,so the point here
Dialogue: 0,0:15:47.53,0:15:50.07,*Default,NTP,0000,0000,0000,,is that double is not applied to three and then
Dialogue: 0,0:15:50.07,0:15:51.77,*Default,NTP,0000,0000,0000,,five and then seven immediately
Dialogue: 0,0:15:51.87,0:15:53.90,*Default,NTP,0000,0000,0000,,but instead applied leisurely
Dialogue: 0,0:15:54.17,0:15:56.80,*Default,NTP,0000,0000,0000,,only when we ask for the next element
Dialogue: 0,0:15:56.80,0:15:59.53,*Default,NTP,0000,0000,0000,,is the function applied and the result computed
Dialogue: 0,0:16:00.50,0:16:03.07,*Default,NTP,0000,0000,0000,,the map object that's returned when I call map
Dialogue: 0,0:16:03.07,0:16:04.70,*Default,NTP,0000,0000,0000,,can be passed into another
Dialogue: 0,0:16:04.70,0:16:06.53,*Default,NTP,0000,0000,0000,,sequence processing function
Dialogue: 0,0:16:07.87,0:16:08.90,*Default,NTP,0000,0000,0000,,so for instance
Dialogue: 0,0:16:08.90,0:16:11.87,*Default,NTP,0000,0000,0000,,let's say I take the range from three to seven
Dialogue: 0,0:16:12.57,0:16:14.87,*Default,NTP,0000,0000,0000,,I map double over that range
Dialogue: 0,0:16:15.17,0:16:16.57,*Default,NTP,0000,0000,0000,,and I call that m
Dialogue: 0,0:16:17.60,0:16:19.50,*Default,NTP,0000,0000,0000,,then I create a filter function
Dialogue: 0,0:16:19.93,0:16:21.50,*Default,NTP,0000,0000,0000,,that takes in a value y
Dialogue: 0,0:16:21.93,0:16:23.93,*Default,NTP,0000,0000,0000,,and returns true as long as y
Dialogue: 0,0:16:24.07,0:16:25.93,*Default,NTP,0000,0000,0000,,is greater than or equal to tin
Dialogue: 0,0:16:27.00,0:16:28.17,*Default,NTP,0000,0000,0000,,I could filter
Dialogue: 0,0:16:28.70,0:16:31.40,*Default,NTP,0000,0000,0000,,using f the map object
Dialogue: 0,0:16:32.17,0:16:35.13,*Default,NTP,0000,0000,0000,,and build a new iterator from the result
Dialogue: 0,0:16:35.90,0:16:38.57,*Default,NTP,0000,0000,0000,,notice I still haven't doubled anything at all
Dialogue: 0,0:16:40.13,0:16:42.67,*Default,NTP,0000,0000,0000,,if I ask for what's the next doubled
Dialogue: 0,0:16:42.67,0:16:45.10,*Default,NTP,0000,0000,0000,,element in the range from three to seven
Dialogue: 0,0:16:45.10,0:16:46.53,*Default,NTP,0000,0000,0000,,that's at least 10
Dialogue: 0,0:16:47.07,0:16:49.47,*Default,NTP,0000,0000,0000,,then it will double three to find that the result is
Dialogue: 0,0:16:49.47,0:16:52.80,*Default,NTP,0000,0000,0000,,six which is false according to our filter function
Dialogue: 0,0:16:52.97,0:16:56.20,*Default,NTP,0000,0000,0000,,so it doubles four to get eight which is also false
Dialogue: 0,0:16:56.27,0:16:58.33,*Default,NTP,0000,0000,0000,,then it doubles five to get ten
Dialogue: 0,0:16:58.33,0:17:00.50,*Default,NTP,0000,0000,0000,,and ten is greater than an equal to 10
Dialogue: 0,0:17:00.50,0:17:01.90,*Default,NTP,0000,0000,0000,,so that gets returned
Dialogue: 0,0:17:02.47,0:17:04.90,*Default,NTP,0000,0000,0000,,so you can see that it did exactly as much work
Dialogue: 0,0:17:04.90,0:17:05.90,*Default,NTP,0000,0000,0000,,as it needed to do
Dialogue: 0,0:17:05.90,0:17:07.87,*Default,NTP,0000,0000,0000,,in order to return the next element
Dialogue: 0,0:17:08.00,0:17:09.27,*Default,NTP,0000,0000,0000,,of the sequence
Dialogue: 0,0:17:09.33,0:17:10.57,*Default,NTP,0000,0000,0000,,of doubled values
Dialogue: 0,0:17:10.57,0:17:12.37,*Default,NTP,0000,0000,0000,,that are greater than are equal to 10
Dialogue: 0,0:17:12.60,0:17:14.80,*Default,NTP,0000,0000,0000,,but it didn't do any more work than that
Dialogue: 0,0:17:15.00,0:17:16.67,*Default,NTP,0000,0000,0000,,if I ask for the next element
Dialogue: 0,0:17:16.67,0:17:18.30,*Default,NTP,0000,0000,0000,,then it will just double one of them
Dialogue: 0,0:17:18.33,0:17:21.13,*Default,NTP,0000,0000,0000,,find out as greater than are equal to 10 and return it
Dialogue: 0,0:17:22.20,0:17:24.13,*Default,NTP,0000,0000,0000,,and if I list the contents of tea
Dialogue: 0,0:17:24.20,0:17:25.93,*Default,NTP,0000,0000,0000,,while it finds that there's nothing left
Dialogue: 0,0:17:25.93,0:17:28.37,*Default,NTP,0000,0000,0000,,because this range only goes 3 4 5 6 6
Dialogue: 0,0:17:28.37,0:17:29.20,*Default,NTP,0000,0000,0000,,doubled as 12
Dialogue: 0,0:17:29.20,0:17:30.10,*Default,NTP,0000,0000,0000,,and then we're done
Dialogue: 0,0:17:30.90,0:17:32.30,*Default,NTP,0000,0000,0000,,so starting from scratch
Dialogue: 0,0:17:32.30,0:17:33.70,*Default,NTP,0000,0000,0000,,if I want to filter
Dialogue: 0,0:17:33.80,0:17:36.37,*Default,NTP,0000,0000,0000,,all of the elements of the result
Dialogue: 0,0:17:36.37,0:17:39.57,*Default,NTP,0000,0000,0000,,of mapping double over the range three to seven
Dialogue: 0,0:17:40.60,0:17:43.73,*Default,NTP,0000,0000,0000,,I'll get an iterator over the values ten and twelve
Dialogue: 0,0:17:44.30,0:17:46.70,*Default,NTP,0000,0000,0000,,which I could place in a list
Dialogue: 0,0:17:47.00,0:17:49.70,*Default,NTP,0000,0000,0000,,and placing them in a list means that it's going to run
Dialogue: 0,0:17:49.70,0:17:52.27,*Default,NTP,0000,0000,0000,,this process to exhaustion
Dialogue: 0,0:17:52.27,0:17:54.50,*Default,NTP,0000,0000,0000,,until I reach an empty iterator at the end
Dialogue: 0,0:17:54.77,0:17:56.67,*Default,NTP,0000,0000,0000,,and that returns the values 10 and 12
Dialogue: 0,0:17:57.00,0:17:59.40,*Default,NTP,0000,0000,0000,,and it had to do all of the work in order to get there
Dialogue: 0,0:17:59.40,0:18:01.80,*Default,NTP,0000,0000,0000,,it had to double every number 3456
Dialogue: 0,0:18:03.10,0:18:04.07,*Default,NTP,0000,0000,0000,,so it's possible
Dialogue: 0,0:18:04.07,0:18:06.93,*Default,NTP,0000,0000,0000,,to use these iterators to compute the exhaust of answer
Dialogue: 0,0:18:07.17,0:18:09.80,*Default,NTP,0000,0000,0000,,but if you don't ask for the list of values
Dialogue: 0,0:18:10.00,0:18:12.67,*Default,NTP,0000,0000,0000,,and you'll only ask for elements one at a time
Dialogue: 0,0:18:12.67,0:18:14.73,*Default,NTP,0000,0000,0000,,then they will be computed legally
Dialogue: 0,0:18:16.07,0:18:18.77,*Default,NTP,0000,0000,0000,,lazy computation is mostly convenient
Dialogue: 0,0:18:18.97,0:18:20.00,*Default,NTP,0000,0000,0000,,because
Dialogue: 0,0:18:20.17,0:18:24.37,*Default,NTP,0000,0000,0000,,it allows you to specify how to compute lots of values
Dialogue: 0,0:18:24.37,0:18:26.20,*Default,NTP,0000,0000,0000,,but if you don't actually need all those values
Dialogue: 0,0:18:26.20,0:18:27.80,*Default,NTP,0000,0000,0000,,then you don't bother computing them
Dialogue: 0,0:18:28.40,0:18:31.17,*Default,NTP,0000,0000,0000,,however there are some things to be careful of
Dialogue: 0,0:18:32.27,0:18:32.97,*Default,NTP,0000,0000,0000,,for example
Dialogue: 0,0:18:32.97,0:18:36.47,*Default,NTP,0000,0000,0000,,if I create a list that's the same forward or backward
Dialogue: 0,0:18:37.13,0:18:41.00,*Default,NTP,0000,0000,0000,,and I ask what's the reversed version of that list
Dialogue: 0,0:18:41.90,0:18:45.53,*Default,NTP,0000,0000,0000,,what I get is a lust reversed iterator object
Dialogue: 0,0:18:46.07,0:18:49.10,*Default,NTP,0000,0000,0000,,so just saying is the reverse of t equal to t
Dialogue: 0,0:18:49.13,0:18:51.33,*Default,NTP,0000,0000,0000,,will give me the result false
Dialogue: 0,0:18:51.87,0:18:53.53,*Default,NTP,0000,0000,0000,,now if I list out
Dialogue: 0,0:18:53.73,0:18:57.17,*Default,NTP,0000,0000,0000,,all of the contents of the reversed iterator
Dialogue: 0,0:18:57.33,0:18:58.70,*Default,NTP,0000,0000,0000,,that's equal to t
Dialogue: 0,0:18:59.70,0:19:02.53,*Default,NTP,0000,0000,0000,,but you want to avoid applying equality
Dialogue: 0,0:19:02.90,0:19:06.47,*Default,NTP,0000,0000,0000,,to a list and an iterator because you'll get false
Dialogue: 0,0:19:07.07,0:19:09.70,*Default,NTP,0000,0000,0000,,you'd have to compare a list and a list
Dialogue: 0,0:19:11.17,0:19:12.53,*Default,NTP,0000,0000,0000,,here's one last demo
Dialogue: 0,0:19:12.70,0:19:14.33,*Default,NTP,0000,0000,0000,,if I have a dictionary
Dialogue: 0,0:19:15.10,0:19:16.67,*Default,NTP,0000,0000,0000,,the elements come in any order
Dialogue: 0,0:19:16.67,0:19:18.07,*Default,NTP,0000,0000,0000,,but when I iterate over them
Dialogue: 0,0:19:18.07,0:19:20.40,*Default,NTP,0000,0000,0000,,I get a consistent order each time
Dialogue: 0,0:19:21.30,0:19:23.70,*Default,NTP,0000,0000,0000,,one way to iterate over the items
Dialogue: 0,0:19:24.40,0:19:26.10,*Default,NTP,0000,0000,0000,,is to get an iterator
Dialogue: 0,0:19:26.97,0:19:28.57,*Default,NTP,0000,0000,0000,,over dw items
Dialogue: 0,0:19:30.13,0:19:32.60,*Default,NTP,0000,0000,0000,,and then I'd get b two followed by a one
Dialogue: 0,0:19:33.50,0:19:35.70,*Default,NTP,0000,0000,0000,,but another way to get the same result
Dialogue: 0,0:19:36.50,0:19:40.33,*Default,NTP,0000,0000,0000,,is to zip together the keys and the values
Dialogue: 0,0:19:41.30,0:19:43.07,*Default,NTP,0000,0000,0000,,zip returns in iterator
Dialogue: 0,0:19:43.47,0:19:45.60,*Default,NTP,0000,0000,0000,,that gives you each of the items
Dialogue: 0,0:19:45.60,0:19:47.50,*Default,NTP,0000,0000,0000,,in the same order as before
Dialogue: 0,0:19:49.53,0:19:52.20,*Default,NTP,0000,0000,0000,,a generator is a special kind of iterator
Dialogue: 0,0:19:52.37,0:19:55.47,*Default,NTP,0000,0000,0000,,just like a map object is a special kind of iterator
Dialogue: 0,0:19:56.13,0:19:58.33,*Default,NTP,0000,0000,0000,,the thing that's special about a generator
Dialogue: 0,0:19:58.60,0:20:01.47,*Default,NTP,0000,0000,0000,,is that it's returned from a generator function
Dialogue: 0,0:20:02.57,0:20:05.30,*Default,NTP,0000,0000,0000,,a generator function looks like a regular function
Dialogue: 0,0:20:05.30,0:20:06.50,*Default,NTP,0000,0000,0000,,here's an example
Dialogue: 0,0:20:07.10,0:20:11.07,*Default,NTP,0000,0000,0000,,the difference is that it uses the yield keyword
Dialogue: 0,0:20:11.17,0:20:12.80,*Default,NTP,0000,0000,0000,,instead of return
Dialogue: 0,0:20:13.40,0:20:15.40,*Default,NTP,0000,0000,0000,,in order to return values
Dialogue: 0,0:20:15.73,0:20:18.57,*Default,NTP,0000,0000,0000,,so I know this is a generator function because it has
Dialogue: 0,0:20:18.57,0:20:19.93,*Default,NTP,0000,0000,0000,,yields in it somewhere
Dialogue: 0,0:20:20.70,0:20:23.97,*Default,NTP,0000,0000,0000,,when I call plus minus on the value three
Dialogue: 0,0:20:24.67,0:20:26.80,*Default,NTP,0000,0000,0000,,I get back a generator t
Dialogue: 0,0:20:28.30,0:20:30.30,*Default,NTP,0000,0000,0000,,this generator is an iterator
Dialogue: 0,0:20:30.50,0:20:32.90,*Default,NTP,0000,0000,0000,,meaning I can iterate through the values
Dialogue: 0,0:20:32.90,0:20:35.00,*Default,NTP,0000,0000,0000,,yielded by plus minus
Dialogue: 0,0:20:35.20,0:20:37.60,*Default,NTP,0000,0000,0000,,so if I call next on t I get three
Dialogue: 0,0:20:37.90,0:20:41.80,*Default,NTP,0000,0000,0000,,but I can call next t again to get -3
Dialogue: 0,0:20:42.13,0:20:43.80,*Default,NTP,0000,0000,0000,,so you can see that both of these
Dialogue: 0,0:20:43.80,0:20:46.27,*Default,NTP,0000,0000,0000,,yield statements are being executed
Dialogue: 0,0:20:47.00,0:20:49.53,*Default,NTP,0000,0000,0000,,t itself is a generator object
Dialogue: 0,0:20:49.80,0:20:52.33,*Default,NTP,0000,0000,0000,,and its job is to help iterate through
Dialogue: 0,0:20:52.33,0:20:54.07,*Default,NTP,0000,0000,0000,,all of the yielded values
Dialogue: 0,0:20:54.07,0:20:55.70,*Default,NTP,0000,0000,0000,,of the function that was called
Dialogue: 0,0:20:56.53,0:20:57.97,*Default,NTP,0000,0000,0000,,so a generator function
Dialogue: 0,0:20:57.97,0:20:58.60,*Default,NTP,0000,0000,0000,,is a function
Dialogue: 0,0:20:58.60,0:21:00.90,*Default,NTP,0000,0000,0000,,that yields values instead of returning them
Dialogue: 0,0:21:01.27,0:21:03.40,*Default,NTP,0000,0000,0000,,a normal function returns just once
Dialogue: 0,0:21:03.40,0:21:06.33,*Default,NTP,0000,0000,0000,,but a generator function can yield multiple times
Dialogue: 0,0:21:06.80,0:21:08.57,*Default,NTP,0000,0000,0000,,a generator is an iterator
Dialogue: 0,0:21:08.57,0:21:09.93,*Default,NTP,0000,0000,0000,,created automatically
Dialogue: 0,0:21:09.93,0:21:12.50,*Default,NTP,0000,0000,0000,,whenever you call a generator function
Dialogue: 0,0:21:12.73,0:21:15.20,*Default,NTP,0000,0000,0000,,so here's the call expression where we called
Dialogue: 0,0:21:15.33,0:21:17.87,*Default,NTP,0000,0000,0000,,plus minus and got back a generator
Dialogue: 0,0:21:18.73,0:21:20.37,*Default,NTP,0000,0000,0000,,when a generator function is called
Dialogue: 0,0:21:20.37,0:21:21.67,*Default,NTP,0000,0000,0000,,it returns a generator
Dialogue: 0,0:21:21.80,0:21:23.60,*Default,NTP,0000,0000,0000,,and that generator iterates over
Dialogue: 0,0:21:23.60,0:21:25.33,*Default,NTP,0000,0000,0000,,the yields of the function
Dialogue: 0,0:21:26.57,0:21:28.00,*Default,NTP,0000,0000,0000,,here's another example
Dialogue: 0,0:21:28.33,0:21:30.10,*Default,NTP,0000,0000,0000,,let's say I want to
Dialogue: 0,0:21:30.33,0:21:34.20,*Default,NTP,0000,0000,0000,,return iterators that go over even numbers only
Dialogue: 0,0:21:35.10,0:21:37.77,*Default,NTP,0000,0000,0000,,I give integer start and end points
Dialogue: 0,0:21:37.93,0:21:39.17,*Default,NTP,0000,0000,0000,,but I want to make sure
Dialogue: 0,0:21:39.20,0:21:40.13,*Default,NTP,0000,0000,0000,,that I actually
Dialogue: 0,0:21:40.13,0:21:41.50,*Default,NTP,0000,0000,0000,,start at the even number
Dialogue: 0,0:21:41.50,0:21:43.50,*Default,NTP,0000,0000,0000,,that's greater than are equal to start
Dialogue: 0,0:21:44.10,0:21:46.97,*Default,NTP,0000,0000,0000,,so the next even number is start plus
Dialogue: 0,0:21:46.97,0:21:48.37,*Default,NTP,0000,0000,0000,,either zero or one
Dialogue: 0,0:21:48.37,0:21:50.73,*Default,NTP,0000,0000,0000,,depending on whether start is even or on
Dialogue: 0,0:21:51.50,0:21:53.87,*Default,NTP,0000,0000,0000,,while it's the case that this even number
Dialogue: 0,0:21:53.87,0:21:55.17,*Default,NTP,0000,0000,0000,,is less an end
Dialogue: 0,0:21:55.37,0:21:57.37,*Default,NTP,0000,0000,0000,,I'm going to yield it
Dialogue: 0,0:21:59.37,0:22:00.97,*Default,NTP,0000,0000,0000,,and then I'll increase even
Dialogue: 0,0:22:00.97,0:22:03.33,*Default,NTP,0000,0000,0000,,by two to get the next even number
Dialogue: 0,0:22:04.60,0:22:06.33,*Default,NTP,0000,0000,0000,,so when I call evens
Dialogue: 0,0:22:06.77,0:22:09.13,*Default,NTP,0000,0000,0000,,and I go from two up to 10
Dialogue: 0,0:22:09.90,0:22:11.77,*Default,NTP,0000,0000,0000,,I get a generator object
Dialogue: 0,0:22:11.93,0:22:13.70,*Default,NTP,0000,0000,0000,,that's going to give me two and then four
Dialogue: 0,0:22:13.70,0:22:14.93,*Default,NTP,0000,0000,0000,,then six and then eight
Dialogue: 0,0:22:15.00,0:22:16.47,*Default,NTP,0000,0000,0000,,and then stop iteration
Dialogue: 0,0:22:16.47,0:22:17.40,*Default,NTP,0000,0000,0000,,meaning we're done
Dialogue: 0,0:22:19.50,0:22:22.17,*Default,NTP,0000,0000,0000,,and if I list all the evens between one and ten
Dialogue: 0,0:22:22.27,0:22:23.67,*Default,NTP,0000,0000,0000,,it still starts at two
Dialogue: 0,0:22:23.70,0:22:26.00,*Default,NTP,0000,0000,0000,,goes up through but not including 10
Dialogue: 0,0:22:26.67,0:22:28.67,*Default,NTP,0000,0000,0000,,so what's actually happening here
Dialogue: 0,0:22:29.73,0:22:32.00,*Default,NTP,0000,0000,0000,,when I create a generator
Dialogue: 0,0:22:32.27,0:22:34.40,*Default,NTP,0000,0000,0000,,by calling a generator function
Dialogue: 0,0:22:35.30,0:22:37.33,*Default,NTP,0000,0000,0000,,I haven't even begun
Dialogue: 0,0:22:37.33,0:22:39.80,*Default,NTP,0000,0000,0000,,executing the body of this function yet
Dialogue: 0,0:22:40.33,0:22:42.57,*Default,NTP,0000,0000,0000,,it's not until next is called
Dialogue: 0,0:22:43.73,0:22:46.20,*Default,NTP,0000,0000,0000,,that the body begins to be executed
Dialogue: 0,0:22:46.53,0:22:47.97,*Default,NTP,0000,0000,0000,,and it keeps executing
Dialogue: 0,0:22:47.97,0:22:51.00,*Default,NTP,0000,0000,0000,,until a yield statement is reached
Dialogue: 0,0:22:51.10,0:22:52.13,*Default,NTP,0000,0000,0000,,at which point
Dialogue: 0,0:22:52.30,0:22:53.97,*Default,NTP,0000,0000,0000,,that number is yielded
Dialogue: 0,0:22:53.97,0:22:56.73,*Default,NTP,0000,0000,0000,,as the next element in this iterator t
Dialogue: 0,0:22:57.80,0:22:59.00,*Default,NTP,0000,0000,0000,,and in that case
Dialogue: 0,0:22:59.00,0:23:02.47,*Default,NTP,0000,0000,0000,,execution pauses at that yield but remembers
Dialogue: 0,0:23:02.50,0:23:04.00,*Default,NTP,0000,0000,0000,,all of the environment
Dialogue: 0,0:23:04.10,0:23:06.13,*Default,NTP,0000,0000,0000,,of the function execution
Dialogue: 0,0:23:06.77,0:23:09.57,*Default,NTP,0000,0000,0000,,so that the next time next is called
Dialogue: 0,0:23:09.67,0:23:11.70,*Default,NTP,0000,0000,0000,,it can continue where it left off
Dialogue: 0,0:23:11.90,0:23:15.07,*Default,NTP,0000,0000,0000,,so the next thing I would do is add two to even
Dialogue: 0,0:23:15.57,0:23:18.13,*Default,NTP,0000,0000,0000,,continue back up into the wild statement
Dialogue: 0,0:23:18.17,0:23:20.00,*Default,NTP,0000,0000,0000,,see that even is less than end
Dialogue: 0,0:23:20.00,0:23:22.10,*Default,NTP,0000,0000,0000,,and yield the next even number
Dialogue: 0,0:23:22.80,0:23:23.70,*Default,NTP,0000,0000,0000,,and what's powerful
Dialogue: 0,0:23:23.70,0:23:25.60,*Default,NTP,0000,0000,0000,,about generators is that you can set up
Dialogue: 0,0:23:25.60,0:23:27.30,*Default,NTP,0000,0000,0000,,any computation you want
Dialogue: 0,0:23:27.70,0:23:30.60,*Default,NTP,0000,0000,0000,,and that computation will be executed lazily
Dialogue: 0,0:23:31.27,0:23:33.93,*Default,NTP,0000,0000,0000,,so when somebody asks for the next element
Dialogue: 0,0:23:34.07,0:23:36.67,*Default,NTP,0000,0000,0000,,then you continue until you reach the next yield
Dialogue: 0,0:23:36.80,0:23:38.40,*Default,NTP,0000,0000,0000,,but if nobody asks
Dialogue: 0,0:23:38.53,0:23:39.60,*Default,NTP,0000,0000,0000,,for all of the elements
Dialogue: 0,0:23:39.60,0:23:41.97,*Default,NTP,0000,0000,0000,,then you don't have to continue computing everything
Dialogue: 0,0:23:42.27,0:23:45.87,*Default,NTP,0000,0000,0000,,you just pause there until the next value is needed
Dialogue: 0,0:23:46.53,0:23:49.47,*Default,NTP,0000,0000,0000,,generator functions return generators
Dialogue: 0,0:23:49.70,0:23:52.57,*Default,NTP,0000,0000,0000,,but they often process iterators in
Dialogue: 0,0:23:53.20,0:23:55.13,*Default,NTP,0000,0000,0000,,the course of their execution
Dialogue: 0,0:23:56.00,0:24:00.17,*Default,NTP,0000,0000,0000,,and this happened so often that in python 3.3
Dialogue: 0,0:24:00.47,0:24:02.40,*Default,NTP,0000,0000,0000,,released back in 2002
Dialogue: 0,0:24:03.33,0:24:06.13,*Default,NTP,0000,0000,0000,,they added a new statement yield from
Dialogue: 0,0:24:06.50,0:24:08.07,*Default,NTP,0000,0000,0000,,that just has a generator
Dialogue: 0,0:24:08.17,0:24:11.20,*Default,NTP,0000,0000,0000,,yield all the elements in some other iterator
Dialogue: 0,0:24:12.27,0:24:14.00,*Default,NTP,0000,0000,0000,,so a yield from statement yields all
Dialogue: 0,0:24:14.00,0:24:15.20,*Default,NTP,0000,0000,0000,,values from an iterator
Dialogue: 0,0:24:15.20,0:24:16.30,*Default,NTP,0000,0000,0000,,or iterable
Dialogue: 0,0:24:16.40,0:24:20.40,*Default,NTP,0000,0000,0000,,for instance let's say I want to define a then b
Dialogue: 0,0:24:20.80,0:24:22.73,*Default,NTP,0000,0000,0000,,which is a function that takes in
Dialogue: 0,0:24:22.97,0:24:25.73,*Default,NTP,0000,0000,0000,,two iterables or iterators
Dialogue: 0,0:24:26.00,0:24:28.27,*Default,NTP,0000,0000,0000,,and returns all the elements in the first
Dialogue: 0,0:24:28.27,0:24:30.57,*Default,NTP,0000,0000,0000,,followed by all the elements in the second
Dialogue: 0,0:24:31.20,0:24:34.10,*Default,NTP,0000,0000,0000,,one way I could write this is to say for x and a
Dialogue: 0,0:24:34.10,0:24:37.30,*Default,NTP,0000,0000,0000,,yield x and then for x and b yield x
Dialogue: 0,0:24:38.77,0:24:40.13,*Default,NTP,0000,0000,0000,,but there's a simpler way
Dialogue: 0,0:24:40.20,0:24:42.93,*Default,NTP,0000,0000,0000,,I could just write yield from a then yield from b
Dialogue: 0,0:24:43.60,0:24:45.27,*Default,NTP,0000,0000,0000,,these are completely equivalent
Dialogue: 0,0:24:45.30,0:24:46.53,*Default,NTP,0000,0000,0000,,so you can think of yield from
Dialogue: 0,0:24:46.53,0:24:47.67,*Default,NTP,0000,0000,0000,,it's just shorthand
Dialogue: 0,0:24:47.73,0:24:49.30,*Default,NTP,0000,0000,0000,,for writing down a four statement
Dialogue: 0,0:24:49.30,0:24:51.07,*Default,NTP,0000,0000,0000,,where you go through all the elements in a
Dialogue: 0,0:24:51.13,0:24:52.13,*Default,NTP,0000,0000,0000,,and yield them
Dialogue: 0,0:24:53.27,0:24:55.70,*Default,NTP,0000,0000,0000,,but it does allow you to avoid giving a name
Dialogue: 0,0:24:55.90,0:24:58.10,*Default,NTP,0000,0000,0000,,to each item in this sequence
Dialogue: 0,0:24:58.17,0:24:59.73,*Default,NTP,0000,0000,0000,,which just cleans up your coat
Dialogue: 0,0:25:01.10,0:25:02.27,*Default,NTP,0000,0000,0000,,here's another example
Dialogue: 0,0:25:02.27,0:25:04.70,*Default,NTP,0000,0000,0000,,let's say we want to define a generator function
Dialogue: 0,0:25:04.70,0:25:06.47,*Default,NTP,0000,0000,0000,,that counts down from five
Dialogue: 0,0:25:07.27,0:25:09.60,*Default,NTP,0000,0000,0000,,well one way I could do it is recursively
Dialogue: 0,0:25:09.97,0:25:12.67,*Default,NTP,0000,0000,0000,,if k is greater than zero than I yield k
Dialogue: 0,0:25:12.77,0:25:16.13,*Default,NTP,0000,0000,0000,,then I yield all of the values in countdown k minus one
Dialogue: 0,0:25:16.53,0:25:19.90,*Default,NTP,0000,0000,0000,,by calling yield from countdown k minus one
Dialogue: 0,0:25:21.20,0:25:23.20,*Default,NTP,0000,0000,0000,,so if I'm counting down from k
Dialogue: 0,0:25:24.10,0:25:25.73,*Default,NTP,0000,0000,0000,,if kray is greater than zero
Dialogue: 0,0:25:25.73,0:25:27.80,*Default,NTP,0000,0000,0000,,I definitely want to yield k first
Dialogue: 0,0:25:28.77,0:25:32.37,*Default,NTP,0000,0000,0000,,if I wrote this wrong I just wrote yield countdown
Dialogue: 0,0:25:32.97,0:25:34.20,*Default,NTP,0000,0000,0000,,k minus one
Dialogue: 0,0:25:35.13,0:25:39.30,*Default,NTP,0000,0000,0000,,the second element in the iterator that I got back
Dialogue: 0,0:25:39.47,0:25:41.53,*Default,NTP,0000,0000,0000,,would actually just be another iterator
Dialogue: 0,0:25:43.53,0:25:46.50,*Default,NTP,0000,0000,0000,,so counting down from three would start out well
Dialogue: 0,0:25:46.67,0:25:49.27,*Default,NTP,0000,0000,0000,,but the next thing I'd get back is a generator object
Dialogue: 0,0:25:49.27,0:25:50.47,*Default,NTP,0000,0000,0000,,which is not what I expected
Dialogue: 0,0:25:50.47,0:25:52.07,*Default,NTP,0000,0000,0000,,I expected the No.2
Dialogue: 0,0:25:52.67,0:25:54.40,*Default,NTP,0000,0000,0000,,so to get the numbers two and one
Dialogue: 0,0:25:54.40,0:25:56.33,*Default,NTP,0000,0000,0000,,I'd have to write a four statement
Dialogue: 0,0:25:58.07,0:26:00.90,*Default,NTP,0000,0000,0000,,and yield each element in the four statement
Dialogue: 0,0:26:01.47,0:26:04.27,*Default,NTP,0000,0000,0000,,then if I count down I get three
Dialogue: 0,0:26:04.50,0:26:06.17,*Default,NTP,0000,0000,0000,,and then two and then one
Dialogue: 0,0:26:07.37,0:26:09.07,*Default,NTP,0000,0000,0000,,and the shorthand way to do that
Dialogue: 0,0:26:09.10,0:26:11.00,*Default,NTP,0000,0000,0000,,is instead of writing a four statement
Dialogue: 0,0:26:11.00,0:26:12.80,*Default,NTP,0000,0000,0000,,I just read yield from
Dialogue: 0,0:26:13.37,0:26:15.10,*Default,NTP,0000,0000,0000,,everything in countdown
Dialogue: 0,0:26:16.33,0:26:19.27,*Default,NTP,0000,0000,0000,,and I got 3 2 1 last off
Dialogue: 0,0:26:20.57,0:26:22.97,*Default,NTP,0000,0000,0000,,wouldn't it be cool if it said blast off at the end
Dialogue: 0,0:26:23.00,0:26:24.20,*Default,NTP,0000,0000,0000,,well we could change that
Dialogue: 0,0:26:24.27,0:26:25.57,*Default,NTP,0000,0000,0000,,we could just say else
Dialogue: 0,0:26:25.80,0:26:26.60,*Default,NTP,0000,0000,0000,,yield
Dialogue: 0,0:26:27.17,0:26:28.50,*Default,NTP,0000,0000,0000,,blast off
Dialogue: 0,0:26:29.20,0:26:31.77,*Default,NTP,0000,0000,0000,,okay so now we can go for every
Dialogue: 0,0:26:32.27,0:26:34.13,*Default,NTP,0000,0000,0000,,k in countdown
Dialogue: 0,0:26:35.30,0:26:36.17,*Default,NTP,0000,0000,0000,,three
Dialogue: 0,0:26:37.30,0:26:38.37,*Default,NTP,0000,0000,0000,,print k
Dialogue: 0,0:26:39.40,0:26:41.73,*Default,NTP,0000,0000,0000,,and it gives me the whole countdown sequence
Dialogue: 0,0:26:41.73,0:26:43.70,*Default,NTP,0000,0000,0000,,and something exciting at the end
Dialogue: 0,0:26:45.10,0:26:48.30,*Default,NTP,0000,0000,0000,,let's finish with a slightly more involved example
Dialogue: 0,0:26:49.00,0:26:53.27,*Default,NTP,0000,0000,0000,,I can yield all the prefixes of s
Dialogue: 0,0:26:53.90,0:26:55.47,*Default,NTP,0000,0000,0000,,or I'm gonna assume s as a string
Dialogue: 0,0:26:55.47,0:26:57.27,*Default,NTP,0000,0000,0000,,but it really could be any iterable
Dialogue: 0,0:26:57.67,0:26:59.07,*Default,NTP,0000,0000,0000,,if it's not empty
Dialogue: 0,0:26:59.17,0:27:01.73,*Default,NTP,0000,0000,0000,,then I'm gonna yield from the prefixes
Dialogue: 0,0:27:02.07,0:27:04.17,*Default,NTP,0000,0000,0000,,of all of s up and two
Dialogue: 0,0:27:04.17,0:27:06.57,*Default,NTP,0000,0000,0000,,but not including the last element
Dialogue: 0,0:27:07.47,0:27:09.73,*Default,NTP,0000,0000,0000,,and then I'll yield s itself
Dialogue: 0,0:27:10.47,0:27:12.33,*Default,NTP,0000,0000,0000,,so the prefixes of both
Dialogue: 0,0:27:12.77,0:27:14.53,*Default,NTP,0000,0000,0000,,is a generator object
Dialogue: 0,0:27:14.57,0:27:16.10,*Default,NTP,0000,0000,0000,,if I list them out
Dialogue: 0,0:27:16.60,0:27:19.37,*Default,NTP,0000,0000,0000,,then I get b bo bot and both
Dialogue: 0,0:27:19.57,0:27:20.87,*Default,NTP,0000,0000,0000,,and I get them in this order
Dialogue: 0,0:27:20.87,0:27:25.00,*Default,NTP,0000,0000,0000,,because I yield from prefixes before I yield s itself
Dialogue: 0,0:27:26.37,0:27:28.33,*Default,NTP,0000,0000,0000,,once I can generate prefixes
Dialogue: 0,0:27:28.33,0:27:30.50,*Default,NTP,0000,0000,0000,,I can also generate substrings
Dialogue: 0,0:27:31.90,0:27:33.47,*Default,NTP,0000,0000,0000,,if s is not empty
Dialogue: 0,0:27:33.67,0:27:36.67,*Default,NTP,0000,0000,0000,,then some of the substrings are just the prefixes
Dialogue: 0,0:27:36.67,0:27:38.33,*Default,NTP,0000,0000,0000,,so I'll yield all of those
Dialogue: 0,0:27:40.17,0:27:43.53,*Default,NTP,0000,0000,0000,,and then I'll yield from the substrings
Dialogue: 0,0:27:43.80,0:27:45.53,*Default,NTP,0000,0000,0000,,of the rest of the string
Dialogue: 0,0:27:47.77,0:27:49.10,*Default,NTP,0000,0000,0000,,so substrings
Dialogue: 0,0:27:50.37,0:27:52.47,*Default,NTP,0000,0000,0000,,of tops for instance
Dialogue: 0,0:27:52.70,0:27:53.87,*Default,NTP,0000,0000,0000,,is a generator
Dialogue: 0,0:27:53.97,0:27:59.20,*Default,NTP,0000,0000,0000,,if I list its contents then I see t two top and tops
Dialogue: 0,0:27:59.20,0:28:01.57,*Default,NTP,0000,0000,0000,,those are all the prefixes of tops
Dialogue: 0,0:28:01.77,0:28:06.20,*Default,NTP,0000,0000,0000,,but then I get all the prefixes of ops oop ops
Dialogue: 0,0:28:06.37,0:28:08.80,*Default,NTP,0000,0000,0000,,and then PPS and s
Dialogue: 0,0:28:09.40,0:28:12.73,*Default,NTP,0000,0000,0000,,and together those are all of the substrings of tops