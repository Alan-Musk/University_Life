[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: Lecture 12. Trees - Lecture 12. Trees
ScriptType: v4.00+
PlayResX: 1280
PlayResY: 720
Timer: 10.0000
WrapStyle: 0
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: TopLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,7,32,32,32,0
Style: TopCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,8,32,32,32,0
Style: TopRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,9,32,32,32,0
Style: BottomLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,1,32,32,32,0
Style: BottomCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,2,32,32,32,0
Style: BottomRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,3,32,32,32,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.27,0:00:02.20,BottomCenter,,0,0,0,,61第12讲
Dialogue: 0,0:00:02.60,0:00:03.53,BottomCenter,,0,0,0,,公告
Dialogue: 0,0:00:04.13,0:00:06.40,BottomCenter,,0,0,0,,猫项目将于下周五截止
Dialogue: 0,0:00:06.67,0:00:09.73,BottomCenter,,0,0,0,,但你需要在下周二之前完成第一阶段
Dialogue: 0,0:00:09.80,0:00:11.77,BottomCenter,,0,0,0,,为了到达检查​​点
Dialogue: 0,0:00:12.10,0:00:13.50,BottomCenter,,0,0,0,,这是为了确保你正在做
Dialogue: 0,0:00:13.50,0:00:14.67,BottomCenter,,0,0,0,,进步，以便你完成
Dialogue: 0,0:00:14.67,0:00:15.53,BottomCenter,,0,0,0,,准时
Dialogue: 0,0:00:15.87,0:00:18.33,BottomCenter,,0,0,0,,最好早点完成第一阶段
Dialogue: 0,0:00:18.33,0:00:20.50,BottomCenter,,0,0,0,,星期二，您只需提交即可
Dialogue: 0,0:00:20.50,0:00:22.13,BottomCenter,,0,0,0,,无论你拥有什么，包括
Dialogue: 0,0:00:22.13,0:00:24.33,BottomCenter,,0,0,0,,完成第一阶段以获得学分
Dialogue: 0,0:00:25.13,0:00:26.90,BottomCenter,,0,0,0,,提交完整内容您将获得奖励积分
Dialogue: 0,0:00:26.90,0:00:28.73,BottomCenter,,0,0,0,,下周四之前的项目
Dialogue: 0,0:00:29.90,0:00:31.80,BottomCenter,,0,0,0,,到底有哪些阶段
Dialogue: 0,0:00:32.50,0:00:33.97,BottomCenter,,0,0,0,,处于第一阶段
Dialogue: 0,0:00:34.10,0:00:37.40,BottomCenter,,0,0,0,,您测量打字速度并选择要输入的内容
Dialogue: 0,0:00:37.70,0:00:38.47,BottomCenter,,0,0,0,,第二阶段
Dialogue: 0,0:00:38.47,0:00:40.90,BottomCenter,,0,0,0,,你构建了我谈到的自动更正系统
Dialogue: 0,0:00:40.90,0:00:42.90,BottomCenter,,0,0,0,,在最后的公告视频中
Dialogue: 0,0:00:43.37,0:00:45.97,BottomCenter,,0,0,0,,在第三阶段你建立多人游戏
Dialogue: 0,0:00:46.77,0:00:49.57,BottomCenter,,0,0,0,,如果您想在构建之前尝试多人游戏
Dialogue: 0,0:00:49.57,0:00:53.67,BottomCenter,,0,0,0,,您可以在 cats csixtona org 访问我们的实施
Dialogue: 0,0:00:54.20,0:00:56.17,BottomCenter,,0,0,0,,它找到了其他对手
Dialogue: 0,0:00:56.27,0:00:58.47,BottomCenter,,0,0,0,,通过寻找其他同样的人
Dialogue: 0,0:00:58.47,0:01:00.07,BottomCenter,,0,0,0,,尝试玩多人游戏
Dialogue: 0,0:01:00.17,0:01:02.46,BottomCenter,,0,0,0,,然后开始多人游戏
Dialogue: 0,0:01:03.70,0:01:04.67,BottomCenter,,0,0,0,,开始了
Dialogue: 0,0:01:13.00,0:01:14.70,BottomCenter,,0,0,0,,哦这个人很快
Dialogue: 0,0:01:22.50,0:01:23.29,BottomCenter,,0,0,0,,哦
Dialogue: 0,0:01:24.73,0:01:27.56,BottomCenter,,0,0,0,,落后了近5秒
Dialogue: 0,0:01:28.17,0:01:30.12,BottomCenter,,0,0,0,,所以如果你愿意的话你可以尝试一下
Dialogue: 0,0:01:30.37,0:01:32.47,BottomCenter,,0,0,0,,但更重要的是你必须构建它
Dialogue: 0,0:01:33.97,0:01:34.53,BottomCenter,,0,0,0,,顺便一提
Dialogue: 0,0:01:34.53,0:01:37.06,BottomCenter,,0,0,0,,如果您还没有将鼠标悬停在这份礼物上
Dialogue: 0,0:01:37.06,0:01:38.53,BottomCenter,,0,0,0,,我建议这样做
Dialogue: 0,0:01:39.76,0:01:43.26,BottomCenter,,0,0,0,,周五下午 200 点我们有考试准备课程
Dialogue: 0,0:01:43.80,0:01:45.20,BottomCenter,,0,0,0,,额外的 q amp a 即将推出
Dialogue: 0,0:01:45.30,0:01:47.73,BottomCenter,,0,0,0,,到目前为止的录音都存储在这里
Dialogue: 0,0:01:48.06,0:01:49.50,BottomCenter,,0,0,0,,以及最后的公告
Dialogue: 0,0:01:49.59,0:01:53.09,BottomCenter,,0,0,0,,生猪策略大赛结束了吗
Dialogue: 0,0:01:53.93,0:01:55.93,BottomCenter,,0,0,0,,我想说恭喜你
Dialogue: 0,0:01:55.93,0:01:57.17,BottomCenter,,0,0,0,,实际上对每个人
Dialogue: 0,0:01:57.17,0:01:59.93,BottomCenter,,0,0,0,,谁参加了生猪策略大赛
Dialogue: 0,0:02:00.09,0:02:04.37,BottomCenter,,0,0,0,,我们有超过 150 个条目
Dialogue: 0,0:02:04.53,0:02:06.00,BottomCenter,,0,0,0,,我觉得这太棒了
Dialogue: 0,0:02:06.06,0:02:06.70,BottomCenter,,0,0,0,,那件事
Dialogue: 0,0:02:06.70,0:02:07.73,BottomCenter,,0,0,0,,让我最开心
Dialogue: 0,0:02:07.73,0:02:09.53,BottomCenter,,0,0,0,,只是看到很多人参与
Dialogue: 0,0:02:10.00,0:02:12.12,BottomCenter,,0,0,0,,但既然有规则
Dialogue: 0,0:02:12.37,0:02:14.19,BottomCenter,,0,0,0,,我们确实需要宣布获胜者
Dialogue: 0,0:02:14.37,0:02:19.09,BottomCenter,,0,0,0,,并获得第一名146次
Dialogue: 0,0:02:19.27,0:02:21.69,BottomCenter,,0,0,0,,有五路平局
Dialogue: 0,0:02:22.12,0:02:24.00,BottomCenter,,0,0,0,,我认为这种情况以前从未发生过
Dialogue: 0,0:02:25.12,0:02:27.77,BottomCenter,,0,0,0,,首先怎么可能有五向轮胎
Dialogue: 0,0:02:27.97,0:02:30.69,BottomCenter,,0,0,0,,实际上提交的内容是不同的
Dialogue: 0,0:02:30.69,0:02:32.12,BottomCenter,,0,0,0,,但规则
Dialogue: 0,0:02:32.12,0:02:34.87,BottomCenter,,0,0,0,,说明每次提交都会获得一个赛点
Dialogue: 0,0:02:34.87,0:02:36.69,BottomCenter,,0,0,0,,它有预期的胜率
Dialogue: 0,0:02:36.80,0:02:40.69,BottomCenter,,0,0,0,,严格高于 50 点 0001 %
Dialogue: 0,0:02:41.47,0:02:44.69,BottomCenter,,0,0,0,,这五个条目也
Dialogue: 0,0:02:44.90,0:02:47.09,BottomCenter,,0,0,0,,风速接近
Dialogue: 0,0:02:47.30,0:02:50.30,BottomCenter,,0,0,0,,他们中没有一个人能以此打败另一个人
Dialogue: 0,0:02:50.40,0:02:51.90,BottomCenter,,0,0,0,,利润非常小
Dialogue: 0,0:02:52.33,0:02:54.12,BottomCenter,,0,0,0,,但它们并不完全相同
Dialogue: 0,0:02:54.59,0:02:57.77,BottomCenter,,0,0,0,,鲍比表的五个条目匿名诗人
Dialogue: 0,0:02:57.80,0:03:01.16,BottomCenter,,0,0,0,,黄金比例湿应用程序和区块链
Dialogue: 0,0:03:01.77,0:03:03.96,BottomCenter,,0,0,0,,一场或一场败仗
Dialogue: 0,0:03:03.96,0:03:05.69,BottomCenter,,0,0,0,,以一种非常有趣的方式
Dialogue: 0,0:03:06.09,0:03:09.30,BottomCenter,,0,0,0,,鲍比桌的胜率超过 50%
Dialogue: 0,0:03:09.40,0:03:11.56,BottomCenter,,0,0,0,,当对抗黄金比例时
Dialogue: 0,0:03:11.80,0:03:15.06,BottomCenter,,0,0,0,,黄金比例玩时胜率超过50%
Dialogue: 0,0:03:15.06,0:03:16.59,BottomCenter,,0,0,0,,反对匿名诗人
Dialogue: 0,0:03:16.59,0:03:19.40,BottomCenter,,0,0,0,,但匿名诗人的胜率超过 50%
Dialogue: 0,0:03:19.40,0:03:20.30,BottomCenter,,0,0,0,,对抗
Dialogue: 0,0:03:20.30,0:03:21.40,BottomCenter,,0,0,0,,鲍比桌
Dialogue: 0,0:03:22.30,0:03:24.47,BottomCenter,,0,0,0,,区块链和匿名诗人
Dialogue: 0,0:03:24.50,0:03:27.97,BottomCenter,,0,0,0,,双方的胜率正好是 50%
Dialogue: 0,0:03:28.06,0:03:30.77,BottomCenter,,0,0,0,,我认为它们实际上是相同的策略
Dialogue: 0,0:03:31.37,0:03:33.56,BottomCenter,,0,0,0,,而其他的都不同
Dialogue: 0,0:03:34.12,0:03:36.37,BottomCenter,,0,0,0,,鲍比桌跻身前五名
Dialogue: 0,0:03:36.87,0:03:39.56,BottomCenter,,0,0,0,,战胜两个对手超过一半的时间
Dialogue: 0,0:03:39.56,0:03:42.59,BottomCenter,,0,0,0,,面对两个对手超过一半的时间都输了
Dialogue: 0,0:03:43.09,0:03:45.40,BottomCenter,,0,0,0,,它实际上只是湿应用程序
Dialogue: 0,0:03:45.53,0:03:47.33,BottomCenter,,0,0,0,,超过一半的时间
Dialogue: 0,0:03:47.33,0:03:48.69,BottomCenter,,0,0,0,,面对更多的对手
Dialogue: 0,0:03:48.72,0:03:50.66,BottomCenter,,0,0,0,,比它失去了但它仍然
Dialogue: 0,0:03:50.66,0:03:52.93,BottomCenter,,0,0,0,,反对率低于百分之五十
Dialogue: 0,0:03:52.93,0:03:54.00,BottomCenter,,0,0,0,,鲍比桌
Dialogue: 0,0:03:55.37,0:03:57.59,BottomCenter,,0,0,0,,无论如何，这些都是规则
Dialogue: 0,0:03:57.59,0:03:59.50,BottomCenter,,0,0,0,,所以这些条目都没有
Dialogue: 0,0:03:59.50,0:04:02.37,BottomCenter,,0,0,0,,与任何其他参赛者取得赛点
Dialogue: 0,0:04:02.56,0:04:05.59,BottomCenter,,0,0,0,,取得五项第一名的成绩
Dialogue: 0,0:04:06.30,0:04:08.53,BottomCenter,,0,0,0,,祝贺所有参与的人
Dialogue: 0,0:04:08.53,0:04:09.46,BottomCenter,,0,0,0,,其中之一
Dialogue: 0,0:04:09.53,0:04:10.59,BottomCenter,,0,0,0,,获奖作品
Dialogue: 0,0:04:10.87,0:04:14.53,BottomCenter,,0,0,0,,这是按字母顺序倒序排列的人员名单
Dialogue: 0,0:04:15.00,0:04:18.37,BottomCenter,,0,0,0,,干得好，你们都获得额外的学分
Dialogue: 0,0:04:18.52,0:04:19.73,BottomCenter,,0,0,0,,如果你想看到更多
Dialogue: 0,0:04:19.73,0:04:21.73,BottomCenter,,0,0,0,,关于拥抱比赛中发生的事情
Dialogue: 0,0:04:21.80,0:04:23.76,BottomCenter,,0,0,0,,你可以在这里查看排行榜
Dialogue: 0,0:04:24.67,0:04:26.17,BottomCenter,,0,0,0,,这就是所有的公告
Dialogue: 0,0:04:26.17,0:04:29.52,BottomCenter,,0,0,0,,现在我们来谈谈今天的内容是树
Dialogue: 0,0:04:29.89,0:04:32.56,BottomCenter,,0,0,0,,树是本课程中我最喜欢的主题之一
Dialogue: 0,0:04:33.06,0:04:34.12,BottomCenter,,0,0,0,,当我们聚集在一起时
Dialogue: 0,0:04:34.12,0:04:37.10,BottomCenter,,0,0,0,,我们对容器和数据的了解
Dialogue: 0,0:04:37.37,0:04:39.76,BottomCenter,,0,0,0,,结合我们所学到的递归知识
Dialogue: 0,0:04:40.00,0:04:42.56,BottomCenter,,0,0,0,,为了构建递归数据
Dialogue: 0,0:04:42.93,0:04:44.97,BottomCenter,,0,0,0,,这是我们了解到的主要原因之一
Dialogue: 0,0:04:44.97,0:04:46.93,BottomCenter,,0,0,0,,关于本课程中的递归函数
Dialogue: 0,0:04:47.06,0:04:49.26,BottomCenter,,0,0,0,,就是处理树形结构的数据
Dialogue: 0,0:04:50.06,0:04:51.73,BottomCenter,,0,0,0,,今天你会看到
Dialogue: 0,0:04:51.87,0:04:54.47,BottomCenter,,0,0,0,,充满数字或字符串的树
Dialogue: 0,0:04:54.89,0:04:56.76,BottomCenter,,0,0,0,,但树结构数据出现在
Dialogue: 0,0:04:56.76,0:04:58.50,BottomCenter,,0,0,0,,还有很多其他程序
Dialogue: 0,0:04:58.76,0:05:02.17,BottomCenter,,0,0,0,,当您代表网站或组织结构图时
Dialogue: 0,0:05:02.52,0:05:04.32,BottomCenter,,0,0,0,,或政府系统
Dialogue: 0,0:05:04.56,0:05:07.47,BottomCenter,,0,0,0,,或任何其他具有层次结构的东西
Dialogue: 0,0:05:07.69,0:05:10.19,BottomCenter,,0,0,0,,那么你将需要树结构数据
Dialogue: 0,0:05:12.37,0:05:16.00,BottomCenter,,0,0,0,,雄鹿和指针表示法是一种表示方式
Dialogue: 0,0:05:16.50,0:05:19.80,BottomCenter,,0,0,0,,我们的环境图中的列表
Dialogue: 0,0:05:21.06,0:05:23.93,BottomCenter,,0,0,0,,所以我们需要符号的原因是
Dialogue: 0,0:05:23.93,0:05:27.06,BottomCenter,,0,0,0,,顺序数据实际上可能变得相当复杂
Dialogue: 0,0:05:27.39,0:05:29.60,BottomCenter,,0,0,0,,这是因为闭包属性
Dialogue: 0,0:05:29.93,0:05:33.32,BottomCenter,,0,0,0,,组合数据值的方法满足
Dialogue: 0,0:05:33.37,0:05:35.30,BottomCenter,,0,0,0,,这个闭包属性
Dialogue: 0,0:05:35.60,0:05:38.30,BottomCenter,,0,0,0,,如果组合的结果是这样的话
Dialogue: 0,0:05:38.37,0:05:41.50,BottomCenter,,0,0,0,,本身可以使用相同的方法组合
Dialogue: 0,0:05:42.19,0:05:44.32,BottomCenter,,0,0,0,,如果我可以将项目放入列表中
Dialogue: 0,0:05:44.32,0:05:46.32,BottomCenter,,0,0,0,,我应该能够拿到那个清单
Dialogue: 0,0:05:46.32,0:05:47.97,BottomCenter,,0,0,0,,并将其放入列表中
Dialogue: 0,0:05:49.10,0:05:51.87,BottomCenter,,0,0,0,,封闭是强大的，因为它允许我们创造
Dialogue: 0,0:05:52.17,0:05:54.12,BottomCenter,,0,0,0,,层次结构
Dialogue: 0,0:05:54.97,0:05:57.00,BottomCenter,,0,0,0,,层次结构由部分组成
Dialogue: 0,0:05:57.00,0:05:59.10,BottomCenter,,0,0,0,,它们本身是由零件组成的
Dialogue: 0,0:05:59.12,0:06:02.89,BottomCenter,,0,0,0,,等等，这是一个非常有用的方法
Dialogue: 0,0:06:02.89,0:06:05.76,BottomCenter,,0,0,0,,代表世界上各种各样的事物
Dialogue: 0,0:06:07.32,0:06:08.67,BottomCenter,,0,0,0,,所以重要的一点
Dialogue: 0,0:06:08.67,0:06:11.52,BottomCenter,,0,0,0,,这是列表可以包含其他列表作为元素
Dialogue: 0,0:06:11.56,0:06:13.52,BottomCenter,,0,0,0,,除此之外
Dialogue: 0,0:06:13.97,0:06:14.97,BottomCenter,,0,0,0,,这意味着
Dialogue: 0,0:06:14.97,0:06:16.37,BottomCenter,,0,0,0,,我们需要一种方法来跟踪
Dialogue: 0,0:06:16.37,0:06:17.60,BottomCenter,,0,0,0,,什么里面有什么
Dialogue: 0,0:06:18.30,0:06:21.12,BottomCenter,,0,0,0,,这就是我们使用框和指针表示法的地方
Dialogue: 0,0:06:24.26,0:06:27.30,BottomCenter,,0,0,0,,列表在环境图中表示
Dialogue: 0,0:06:27.30,0:06:30.87,BottomCenter,,0,0,0,,作为标记为相邻框的一行索引
Dialogue: 0,0:06:30.87,0:06:32.30,BottomCenter,,0,0,0,,每个元素一个
Dialogue: 0,0:06:33.12,0:06:35.93,BottomCenter,,0,0,0,,每个盒子都包含一个永久值
Dialogue: 0,0:06:36.10,0:06:38.89,BottomCenter,,0,0,0,,或指向复合值
Dialogue: 0,0:06:40.52,0:06:43.69,BottomCenter,,0,0,0,,所以如果我只是说pair等于列表一二
Dialogue: 0,0:06:44.06,0:06:46.30,BottomCenter,,0,0,0,,我会把它写在我的环境图中
Dialogue: 0,0:06:46.32,0:06:48.00,BottomCenter,,0,0,0,,通过绑定名称对
Dialogue: 0,0:06:48.06,0:06:50.67,BottomCenter,,0,0,0,,包含 1 和 2 的列表
Dialogue: 0,0:06:51.12,0:06:53.06,BottomCenter,,0,0,0,,这些角落里的小数字
Dialogue: 0,0:06:53.30,0:06:55.76,BottomCenter,,0,0,0,,只是列表的索引
Dialogue: 0,0:06:56.12,0:06:58.89,BottomCenter,,0,0,0,,因为列表有两个元素
Dialogue: 0,0:06:58.89,0:07:01.87,BottomCenter,,0,0,0,,我们看到两个相邻的盒子
Dialogue: 0,0:07:02.97,0:07:04.97,BottomCenter,,0,0,0,,现在来看一个更复杂的例子
Dialogue: 0,0:07:05.60,0:07:09.19,BottomCenter,,0,0,0,,嵌套列表绑定到包含列表的列表
Dialogue: 0,0:07:09.19,0:07:10.76,BottomCenter,,0,0,0,,一个列表和另一个列表
Dialogue: 0,0:07:11.17,0:07:13.67,BottomCenter,,0,0,0,,这个第三个列表包含列表本身
Dialogue: 0,0:07:13.97,0:07:16.97,BottomCenter,,0,0,0,,里面有各种各样的东西，甚至是一个函数
Dialogue: 0,0:07:17.97,0:07:20.37,BottomCenter,,0,0,0,,让我们浏览一下屏幕上的所有内容
Dialogue: 0,0:07:21.30,0:07:23.89,BottomCenter,,0,0,0,,嵌套列表是一个三元素列表
Dialogue: 0,0:07:24.10,0:07:28.32,BottomCenter,,0,0,0,,所以我们看到它绑定到三个相邻的矩形
Dialogue: 0,0:07:29.17,0:07:32.73,BottomCenter,,0,0,0,,现在嵌套列表的每个元素实际上是
Dialogue: 0,0:07:32.93,0:07:33.89,BottomCenter,,0,0,0,,另一个清单
Dialogue: 0,0:07:34.06,0:07:37.56,BottomCenter,,0,0,0,,这就是为什么我们看到复合值的指针
Dialogue: 0,0:07:37.56,0:07:39.39,BottomCenter,,0,0,0,,列表是复合值
Dialogue: 0,0:07:39.50,0:07:41.39,BottomCenter,,0,0,0,,函数或复合值
Dialogue: 0,0:07:41.39,0:07:43.56,BottomCenter,,0,0,0,,任何有多个部分的东西
Dialogue: 0,0:07:43.73,0:07:46.26,BottomCenter,,0,0,0,,将使用箭头表示
Dialogue: 0,0:07:46.39,0:07:49.30,BottomCenter,,0,0,0,,对那件事的一些描述
Dialogue: 0,0:07:51.26,0:07:54.47,BottomCenter,,0,0,0,,好的，在这里我们看到元素索引为零
Dialogue: 0,0:07:54.52,0:07:56.89,BottomCenter,,0,0,0,,只是一个包含一和二的列表
Dialogue: 0,0:07:57.80,0:08:00.39,BottomCenter,,0,0,0,,索引一的元素是空列表
Dialogue: 0,0:08:00.73,0:08:02.26,BottomCenter,,0,0,0,,这里我们看到空列表
Dialogue: 0,0:08:02.60,0:08:04.19,BottomCenter,,0,0,0,,以及索引为 3 的元素
Dialogue: 0,0:08:04.56,0:08:08.10,BottomCenter,,0,0,0,,它本身是一个包含另外两个列表的列表
Dialogue: 0,0:08:08.32,0:08:11.80,BottomCenter,,0,0,0,,这就是为什么我们看到这种层次结构
Dialogue: 0,0:08:12.52,0:08:13.32,BottomCenter,,0,0,0,,在哪里
Dialogue: 0,0:08:13.32,0:08:16.19,BottomCenter,,0,0,0,,这是由零件组成的，而零件又是由零件组成的
Dialogue: 0,0:08:18.12,0:08:19.67,BottomCenter,,0,0,0,,原始值三
Dialogue: 0,0:08:19.67,0:08:22.69,BottomCenter,,0,0,0,,false 且 none 可以直接写入框中
Dialogue: 0,0:08:23.56,0:08:25.87,BottomCenter,,0,0,0,,对于该函数也可以
Dialogue: 0,0:08:25.97,0:08:28.60,BottomCenter,,0,0,0,,我们像以前编写函数一样编写
Dialogue: 0,0:08:29.06,0:08:31.87,BottomCenter,,0,0,0,,我们用一个小箭头表示它已被包含
Dialogue: 0,0:08:32.07,0:08:34.29,BottomCenter,,0,0,0,,作为索引一处的该元素
Dialogue: 0,0:08:34.33,0:08:36.50,BottomCenter,,0,0,0,,此列表中的列表的
Dialogue: 0,0:08:36.50,0:08:37.73,BottomCenter,,0,0,0,,就在这个列表中
Dialogue: 0,0:08:41.07,0:08:43.60,BottomCenter,,0,0,0,,切片是您可以执行的操作
Dialogue: 0,0:08:43.60,0:08:47.26,BottomCenter,,0,0,0,,在列表和范围等序列上
Dialogue: 0,0:08:49.39,0:08:53.73,BottomCenter,,0,0,0,,假设我已经有一个序列 3 5 7 9 11
Dialogue: 0,0:08:54.60,0:08:56.37,BottomCenter,,0,0,0,,以及我想要出去的东西
Dialogue: 0,0:08:56.39,0:08:58.66,BottomCenter,,0,0,0,,只是五个和七个
Dialogue: 0,0:08:58.87,0:09:01.33,BottomCenter,,0,0,0,,所以这些是索引一和二处的元素
Dialogue: 0,0:09:02.00,0:09:03.73,BottomCenter,,0,0,0,,好吧我可以
Dialogue: 0,0:09:04.92,0:09:08.37,BottomCenter,,0,0,0,,得到索引一和二
Dialogue: 0,0:09:09.37,0:09:12.57,BottomCenter,,0,0,0,,然后我可以在列表理解中使用它
Dialogue: 0,0:09:12.76,0:09:14.39,BottomCenter,,0,0,0,,我想要赔率我
Dialogue: 0,0:09:14.97,0:09:18.66,BottomCenter,,0,0,0,,对于 I 在 1 2 3 范围内
Dialogue: 0,0:09:20.70,0:09:21.37,BottomCenter,,0,0,0,,并记住
Dialogue: 0,0:09:21.37,0:09:24.33,BottomCenter,,0,0,0,,从一到三的范围给我一和二，但不是三
Dialogue: 0,0:09:25.16,0:09:25.57,BottomCenter,,0,0,0,,好的
Dialogue: 0,0:09:25.57,0:09:28.26,BottomCenter,,0,0,0,,这是选择五个和七个的一种方法
Dialogue: 0,0:09:28.29,0:09:30.10,BottomCenter,,0,0,0,,该列表的子列表
Dialogue: 0,0:09:31.33,0:09:35.07,BottomCenter,,0,0,0,,切片是一种更紧凑地执行此操作的符号
Dialogue: 0,0:09:35.16,0:09:38.26,BottomCenter,,0,0,0,,它做同样的事情，但不需要你输入那么多
Dialogue: 0,0:09:38.37,0:09:39.87,BottomCenter,,0,0,0,,你只写赔率
Dialogue: 0,0:09:39.87,0:09:41.66,BottomCenter,,0,0,0,,然后在方括号中你说
Dialogue: 0,0:09:41.66,0:09:43.60,BottomCenter,,0,0,0,,我想从一到三
Dialogue: 0,0:09:45.76,0:09:48.87,BottomCenter,,0,0,0,,所以它与范围有相同的规则
Dialogue: 0,0:09:49.33,0:09:52.29,BottomCenter,,0,0,0,,指数包括下限
Dialogue: 0,0:09:52.29,0:09:54.07,BottomCenter,,0,0,0,,但排除上限
Dialogue: 0,0:09:55.57,0:09:57.76,BottomCenter,,0,0,0,,现在有一些额外的灵活性
Dialogue: 0,0:09:58.50,0:10:00.12,BottomCenter,,0,0,0,,就像你遗漏一样
Dialogue: 0,0:10:00.50,0:10:03.00,BottomCenter,,0,0,0,,范围的边界之一
Dialogue: 0,0:10:03.10,0:10:05.50,BottomCenter,,0,0,0,,如果你省略了起始数字
Dialogue: 0,0:10:05.50,0:10:06.20,BottomCenter,,0,0,0,,即将开始
Dialogue: 0,0:10:06.20,0:10:08.33,BottomCenter,,0,0,0,,从列表的最开始
Dialogue: 0,0:10:08.39,0:10:13.12,BottomCenter,,0,0,0,,所以赔率高达三给我指数零一和二
Dialogue: 0,0:10:13.97,0:10:15.37,BottomCenter,,0,0,0,,我也可以省略结尾
Dialogue: 0,0:10:15.37,0:10:16.76,BottomCenter,,0,0,0,,它将一直走到最后
Dialogue: 0,0:10:16.76,0:10:18.87,BottomCenter,,0,0,0,,所以如果我想从索引一开始
Dialogue: 0,0:10:18.92,0:10:20.92,BottomCenter,,0,0,0,,然后我将跳过索引零处的三个
Dialogue: 0,0:10:20.92,0:10:22.10,BottomCenter,,0,0,0,,并获得全部五个
Dialogue: 0,0:10:22.10,0:10:23.52,BottomCenter,,0,0,0,,七点九点十一点
Dialogue: 0,0:10:23.87,0:10:26.66,BottomCenter,,0,0,0,,你甚至可以跳过开头和结尾
Dialogue: 0,0:10:26.70,0:10:27.76,BottomCenter,,0,0,0,,然后你回来
Dialogue: 0,0:10:27.79,0:10:30.20,BottomCenter,,0,0,0,,原始列表中的所有元素
Dialogue: 0,0:10:32.47,0:10:34.57,BottomCenter,,0,0,0,,所以这些方括号代表里面的冒号
Dialogue: 0,0:10:34.57,0:10:36.16,BottomCenter,,0,0,0,,被称为切片运算符
Dialogue: 0,0:10:38.66,0:10:41.12,BottomCenter,,0,0,0,,切片总是创造新的价值
Dialogue: 0,0:10:41.26,0:10:44.16,BottomCenter,,0,0,0,,所以这里有一些例子我有数字，这是一个列表
Dialogue: 0,0:10:44.20,0:10:46.70,BottomCenter,,0,0,0,,然后我把它切三次
Dialogue: 0,0:10:47.00,0:10:49.16,BottomCenter,,0,0,0,,我得到的环境图
Dialogue: 0,0:10:49.26,0:10:51.33,BottomCenter,,0,0,0,,包括四个不同的列表
Dialogue: 0,0:10:51.33,0:10:54.26,BottomCenter,,0,0,0,,请注意，切片后数字没有改变
Dialogue: 0,0:10:54.52,0:10:58.07,BottomCenter,,0,0,0,,但当我把那个切掉时
Dialogue: 0,0:10:58.29,0:10:59.47,BottomCenter,,0,0,0,,说我想去
Dialogue: 0,0:10:59.47,0:11:01.07,BottomCenter,,0,0,0,,从头一直向上
Dialogue: 0,0:11:01.07,0:11:03.00,BottomCenter,,0,0,0,,但不包括索引一
Dialogue: 0,0:11:03.12,0:11:05.66,BottomCenter,,0,0,0,,我得到了一份新的价值清单
Dialogue: 0,0:11:06.79,0:11:08.70,BottomCenter,,0,0,0,,要求中间给了我一个
Dialogue: 0,0:11:08.70,0:11:10.70,BottomCenter,,0,0,0,,第三个列表有八个和两个
Dialogue: 0,0:11:10.87,0:11:13.66,BottomCenter,,0,0,0,,并要求从索引二到末尾的所有内容
Dialogue: 0,0:11:13.79,0:11:16.10,BottomCenter,,0,0,0,,给了我第四个清单，其中有两个和八个
Dialogue: 0,0:11:18.47,0:11:20.50,BottomCenter,,0,0,0,,处理容器值
Dialogue: 0,0:11:20.50,0:11:21.52,BottomCenter,,0,0,0,,经常涉及到
Dialogue: 0,0:11:21.52,0:11:24.39,BottomCenter,,0,0,0,,迭代包含的所有值
Dialogue: 0,0:11:24.39,0:11:27.50,BottomCenter,,0,0,0,,在您感兴趣的列表或词典中
Dialogue: 0,0:11:28.16,0:11:31.00,BottomCenter,,0,0,0,,但有一些内置的功能
Dialogue: 0,0:11:31.07,0:11:33.10,BottomCenter,,0,0,0,,帮助我们更有效地做到这一点
Dialogue: 0,0:11:34.33,0:11:35.39,BottomCenter,,0,0,0,,尤其
Dialogue: 0,0:11:35.60,0:11:37.52,BottomCenter,,0,0,0,,有几个函数可以执行
Dialogue: 0,0:11:37.52,0:11:39.07,BottomCenter,,0,0,0,,序列聚合
Dialogue: 0,0:11:39.79,0:11:40.97,BottomCenter,,0,0,0,,所以这些函数
Dialogue: 0,0:11:40.97,0:11:43.16,BottomCenter,,0,0,0,,获取可迭代的参数并聚合它们
Dialogue: 0,0:11:43.16,0:11:44.37,BottomCenter,,0,0,0,,转化为单一值
Dialogue: 0,0:11:45.52,0:11:47.33,BottomCenter,,0,0,0,,我只是要向你展示实际情况
Dialogue: 0,0:11:47.33,0:11:49.37,BottomCenter,,0,0,0,,python 文档三
Dialogue: 0,0:11:49.57,0:11:51.73,BottomCenter,,0,0,0,,并帮助您了解它是如何工作的
Dialogue: 0,0:11:52.47,0:11:54.60,BottomCenter,,0,0,0,,所以有一个内置函数叫做 some
Dialogue: 0,0:11:55.16,0:11:59.00,BottomCenter,,0,0,0,,它需要一个可爱的参数，例如列表
Dialogue: 0,0:11:59.76,0:12:00.87,BottomCenter,,0,0,0,,现在这个符号
Dialogue: 0,0:12:00.87,0:12:01.73,BottomCenter,,0,0,0,,实际上并不
Dialogue: 0,0:12:01.73,0:12:04.07,BottomCenter,,0,0,0,,意思是你调用的时候写方括号
Dialogue: 0,0:12:04.29,0:12:07.12,BottomCenter,,0,0,0,,相反，这是 python 码头中使用的东西
Dialogue: 0,0:12:07.12,0:12:09.70,BottomCenter,,0,0,0,,表示第二个参数是可选的
Dialogue: 0,0:12:10.20,0:12:12.37,BottomCenter,,0,0,0,,这样你就可以只用一个参数来调用一些
Dialogue: 0,0:12:12.37,0:12:14.37,BottomCenter,,0,0,0,,一个列表，它将对值进行求和
Dialogue: 0,0:12:14.39,0:12:16.73,BottomCenter,,0,0,0,,或者你可以用两个参数来调用它
Dialogue: 0,0:12:16.79,0:12:19.87,BottomCenter,,0,0,0,,值列表和一些起始值
Dialogue: 0,0:12:20.39,0:12:21.50,BottomCenter,,0,0,0,,它将经历
Dialogue: 0,0:12:21.50,0:12:23.73,BottomCenter,,0,0,0,,可迭代中的所有值
Dialogue: 0,0:12:23.97,0:12:25.87,BottomCenter,,0,0,0,,并将它们添加到开头
Dialogue: 0,0:12:25.97,0:12:27.10,BottomCenter,,0,0,0,,好吧，这里说
Dialogue: 0,0:12:27.10,0:12:29.12,BottomCenter,,0,0,0,,返回可迭代数字的总和
Dialogue: 0,0:12:29.12,0:12:32.33,BottomCenter,,0,0,0,,不是字符串加上参数start的值
Dialogue: 0,0:12:32.37,0:12:33.97,BottomCenter,,0,0,0,,默认为零
Dialogue: 0,0:12:34.29,0:12:36.89,BottomCenter,,0,0,0,,当 iterable 为空时返回 start
Dialogue: 0,0:12:38.57,0:12:40.87,BottomCenter,,0,0,0,,一些 2 3 4
Dialogue: 0,0:12:41.92,0:12:42.89,BottomCenter,,0,0,0,,是九
Dialogue: 0,0:12:43.79,0:12:47.47,BottomCenter,,0,0,0,,一些 2 3 4
Dialogue: 0,0:12:48.76,0:12:50.57,BottomCenter,,0,0,0,,它不适用于字符串
Dialogue: 0,0:12:50.92,0:12:53.20,BottomCenter,,0,0,0,,现在这个起始值是多少
Dialogue: 0,0:12:53.20,0:12:54.66,BottomCenter,,0,0,0,,好吧，如果我从五个开始
Dialogue: 0,0:12:54.66,0:12:57.70,BottomCenter,,0,0,0,,然后它会添加五个和两个和三个和四个
Dialogue: 0,0:12:58.70,0:13:00.26,BottomCenter,,0,0,0,,现在为什么这有用
Dialogue: 0,0:13:00.60,0:13:03.07,BottomCenter,,0,0,0,,好吧，假设你要加在一起
Dialogue: 0,0:13:03.07,0:13:05.39,BottomCenter,,0,0,0,,值不仅仅是数字
Dialogue: 0,0:13:05.89,0:13:07.97,BottomCenter,,0,0,0,,你必须提供它的值
Dialogue: 0,0:13:07.97,0:13:09.79,BottomCenter,,0,0,0,,输入以便开始
Dialogue: 0,0:13:10.70,0:13:13.37,BottomCenter,,0,0,0,,所以请记住我可以添加两个和三个列表
Dialogue: 0,0:13:13.39,0:13:16.39,BottomCenter,,0,0,0,,到四个列表，我得到一个更长的列表
Dialogue: 0,0:13:17.20,0:13:19.73,BottomCenter,,0,0,0,,好吧，以同样的方式我可以一些
Dialogue: 0,0:13:19.92,0:13:22.39,BottomCenter,,0,0,0,,包含 2 和 3 的列表
Dialogue: 0,0:13:22.70,0:13:23.97,BottomCenter,,0,0,0,,以及四个
Dialogue: 0,0:13:24.87,0:13:26.52,BottomCenter,,0,0,0,,只要是这样
Dialogue: 0,0:13:26.57,0:13:29.37,BottomCenter,,0,0,0,,我首先从一个列表开始
Dialogue: 0,0:13:30.60,0:13:32.50,BottomCenter,,0,0,0,,如果我没有从清单开始
Dialogue: 0,0:13:32.52,0:13:35.47,BottomCenter,,0,0,0,,我会尝试将此列表添加到 No.0
Dialogue: 0,0:13:35.66,0:13:37.07,BottomCenter,,0,0,0,,那是不可能的
Dialogue: 0,0:13:39.76,0:13:41.33,BottomCenter,,0,0,0,,所以这就是如果我有的话就会发生的事情
Dialogue: 0,0:13:41.33,0:13:42.29,BottomCenter,,0,0,0,,总结无
Dialogue: 0,0:13:42.29,0:13:43.57,BottomCenter,,0,0,0,,该起始值
Dialogue: 0,0:13:44.29,0:13:47.10,BottomCenter,,0,0,0,,但由于我首先提供了一个空列表
Dialogue: 0,0:13:47.50,0:13:49.52,BottomCenter,,0,0,0,,然后我添加了两个和三个
Dialogue: 0,0:13:49.70,0:13:53.47,BottomCenter,,0,0,0,,然后我添加了四个，最后得到了一个列表 2 3 4
Dialogue: 0,0:13:55.70,0:13:57.76,BottomCenter,,0,0,0,,max 有两种形式
Dialogue: 0,0:13:57.89,0:14:00.87,BottomCenter,,0,0,0,,你可以传递它和可迭代的，例如列表
Dialogue: 0,0:14:01.47,0:14:04.00,BottomCenter,,0,0,0,,以及可选的按键功能
Dialogue: 0,0:14:04.57,0:14:06.70,BottomCenter,,0,0,0,,它返回最大值
Dialogue: 0,0:14:07.47,0:14:10.37,BottomCenter,,0,0,0,,或者你可以传递多个不同的参数
Dialogue: 0,0:14:10.37,0:14:12.10,BottomCenter,,0,0,0,,比如一堆数字
Dialogue: 0,0:14:12.10,0:14:13.89,BottomCenter,,0,0,0,,以及一个关键功能
Dialogue: 0,0:14:14.50,0:14:16.79,BottomCenter,,0,0,0,,然后它将取参数的最大值
Dialogue: 0,0:14:17.12,0:14:18.87,BottomCenter,,0,0,0,,所以它用一个参数说
Dialogue: 0,0:14:18.87,0:14:20.52,BottomCenter,,0,0,0,,返回其最大的项目
Dialogue: 0,0:14:20.60,0:14:23.70,BottomCenter,,0,0,0,,这是两个传入的列表中的一个元素
Dialogue: 0,0:14:23.87,0:14:26.76,BottomCenter,,0,0,0,,有两个或多个参数时返回最大的参数
Dialogue: 0,0:14:28.07,0:14:31.92,BottomCenter,,0,0,0,,所以 5 以内的范围的最大值是 4
Dialogue: 0,0:14:32.73,0:14:35.60,BottomCenter,,0,0,0,,或者我可以说 max 1 2 3 4
Dialogue: 0,0:14:37.47,0:14:39.00,BottomCenter,,0,0,0,,以零开头
Dialogue: 0,0:14:39.26,0:14:40.92,BottomCenter,,0,0,0,,那会做同样的事情
Dialogue: 0,0:14:41.70,0:14:44.89,BottomCenter,,0,0,0,,现在这个关键函数发生了什么
Dialogue: 0,0:14:45.39,0:14:47.52,BottomCenter,,0,0,0,,好吧，文档没有告诉我
Dialogue: 0,0:14:47.66,0:14:49.37,BottomCenter,,0,0,0,,但发生的情况是它适用
Dialogue: 0,0:14:49.37,0:14:52.07,BottomCenter,,0,0,0,,您正在考虑的每个元素的函数
Dialogue: 0,0:14:52.33,0:14:52.97,BottomCenter,,0,0,0,,实际上
Dialogue: 0,0:14:52.97,0:14:55.92,BottomCenter,,0,0,0,,根据返回值计算最大值
Dialogue: 0,0:14:55.92,0:14:57.60,BottomCenter,,0,0,0,,调用这些函数
Dialogue: 0,0:14:58.60,0:15:00.39,BottomCenter,,0,0,0,,所以你可以问类似的问题
Dialogue: 0,0:15:00.60,0:15:03.57,BottomCenter,,0,0,0,,该范围内的最大值是多少
Dialogue: 0,0:15:03.57,0:15:05.37,BottomCenter,,0,0,0,,从零到九
Dialogue: 0,0:15:06.00,0:15:07.60,BottomCenter,,0,0,0,,如果我关心什么
Dialogue: 0,0:15:09.66,0:15:15.07,BottomCenter,,0,0,0,,是一些代数表达式，例如 7 x 减四
Dialogue: 0,0:15:15.33,0:15:17.33,BottomCenter,,0,0,0,,乘以 x 减二
Dialogue: 0,0:15:18.97,0:15:20.52,BottomCenter,,0,0,0,,现在这是一些抛物线
Dialogue: 0,0:15:20.52,0:15:22.47,BottomCenter,,0,0,0,,最大值就在三处
Dialogue: 0,0:15:22.66,0:15:25.39,BottomCenter,,0,0,0,,如果我将其指定为我的关键功能
Dialogue: 0,0:15:26.20,0:15:28.33,BottomCenter,,0,0,0,,然后它会告诉我这个的最大值
Dialogue: 0,0:15:28.33,0:15:32.73,BottomCenter,,0,0,0,,调用该函数的输出范围为三
Dialogue: 0,0:15:34.26,0:15:37.12,BottomCenter,,0,0,0,,所以如果我把这个函数应用到 No.3
Dialogue: 0,0:15:37.50,0:15:38.70,BottomCenter,,0,0,0,,然后我得到八个
Dialogue: 0,0:15:38.87,0:15:41.10,BottomCenter,,0,0,0,,如果我把它应用到两个我会得到更少的东西怎么办
Dialogue: 0,0:15:41.10,0:15:42.39,BottomCenter,,0,0,0,,如果我把它应用到四个
Dialogue: 0,0:15:42.66,0:15:46.76,BottomCenter,,0,0,0,,或者五六七我也会得到更少的东西
Dialogue: 0,0:15:46.76,0:15:49.97,BottomCenter,,0,0,0,,这就是为什么它给我的返回值是 3
Dialogue: 0,0:15:51.73,0:15:53.52,BottomCenter,,0,0,0,,这是第三个，叫做 all
Dialogue: 0,0:15:54.57,0:15:57.20,BottomCenter,,0,0,0,,all 接受一个可迭代对象并返回 true
Dialogue: 0,0:15:57.89,0:16:00.12,BottomCenter,,0,0,0,,如果你得到一个真实的值
Dialogue: 0,0:16:00.73,0:16:04.47,BottomCenter,,0,0,0,,当对迭代中的每个元素调用 bull 时
Dialogue: 0,0:16:04.89,0:16:07.39,BottomCenter,,0,0,0,,如果 iterable 为空则返回 true
Dialogue: 0,0:16:07.87,0:16:09.39,BottomCenter,,0,0,0,,这是什么牛函数
Dialogue: 0,0:16:10.73,0:16:14.73,BottomCenter,,0,0,0,,好吧，公牛告诉我一个值是真还是假
Dialogue: 0,0:16:14.87,0:16:16.70,BottomCenter,,0,0,0,,所以 5 是一个真正的值
Dialogue: 0,0:16:16.79,0:16:19.07,BottomCenter,,0,0,0,,true 当然也是一个真值
Dialogue: 0,0:16:19.12,0:16:21.26,BottomCenter,,0,0,0,,即使-1也是一个真值
Dialogue: 0,0:16:21.29,0:16:24.20,BottomCenter,,0,0,0,,但零并不是真值，而是假值
Dialogue: 0,0:16:26.29,0:16:28.76,BottomCenter,,0,0,0,,同样 hello 是一个真值
Dialogue: 0,0:16:28.76,0:16:31.16,BottomCenter,,0,0,0,,空字符串是假值
Dialogue: 0,0:16:31.76,0:16:32.73,BottomCenter,,0,0,0,,我们了解了这些
Dialogue: 0,0:16:32.73,0:16:35.10,BottomCenter,,0,0,0,,当我们谈论布尔上下文时
Dialogue: 0,0:16:35.20,0:16:37.66,BottomCenter,,0,0,0,,当我们引入条件语句时
Dialogue: 0,0:16:39.60,0:16:40.97,BottomCenter,,0,0,0,,那么所有的呢
Dialogue: 0,0:16:41.47,0:16:45.66,BottomCenter,,0,0,0,,好吧，假设我的范围是五
Dialogue: 0,0:16:45.73,0:16:48.16,BottomCenter,,0,0,0,,我想问是这样吗
Dialogue: 0,0:16:48.37,0:16:50.50,BottomCenter,,0,0,0,,x 小于 5
Dialogue: 0,0:16:51.33,0:16:53.20,BottomCenter,,0,0,0,,对于范围五中的 x
Dialogue: 0,0:16:53.47,0:16:55.60,BottomCenter,,0,0,0,,我会得到真实的真实真实的真实
Dialogue: 0,0:16:55.79,0:16:58.57,BottomCenter,,0,0,0,,所有人的目标是将它们聚合在一起
Dialogue: 0,0:16:58.79,0:17:00.97,BottomCenter,,0,0,0,,并告诉我它们是否属实
Dialogue: 0,0:17:02.29,0:17:05.52,BottomCenter,,0,0,0,,我不必向它传递池值列表
Dialogue: 0,0:17:05.56,0:17:08.59,BottomCenter,,0,0,0,,我可以将数字零一的列表传递给它
Dialogue: 0,0:17:08.59,0:17:09.97,BottomCenter,,0,0,0,,二三四
Dialogue: 0,0:17:10.09,0:17:12.32,BottomCenter,,0,0,0,,它会告诉我，因为零是假的
Dialogue: 0,0:17:12.32,0:17:14.09,BottomCenter,,0,0,0,,这些并不都是真实的价值观
Dialogue: 0,0:17:15.93,0:17:16.90,BottomCenter,,0,0,0,,所以那些是
Dialogue: 0,0:17:16.93,0:17:20.97,BottomCenter,,0,0,0,,三个对序列进行操作的内置函数
Dialogue: 0,0:17:20.97,0:17:23.56,BottomCenter,,0,0,0,,还有 min 和 any
Dialogue: 0,0:17:23.76,0:17:26.40,BottomCenter,,0,0,0,,这是 max 和 all 的补充
Dialogue: 0,0:17:29.73,0:17:33.32,BottomCenter,,0,0,0,,树是重要的数据抽象
Dialogue: 0,0:17:33.47,0:17:37.00,BottomCenter,,0,0,0,,用于表示层次关系
Dialogue: 0,0:17:38.29,0:17:41.36,BottomCenter,,0,0,0,,我们以前画过树的图片
Dialogue: 0,0:17:42.06,0:17:44.26,BottomCenter,,0,0,0,,并讨论了计算机科学中如何
Dialogue: 0,0:17:44.26,0:17:46.06,BottomCenter,,0,0,0,,他们倒立生长
Dialogue: 0,0:17:47.76,0:17:51.00,BottomCenter,,0,0,0,,现在我们来谈谈常用词汇
Dialogue: 0,0:17:51.00,0:17:53.17,BottomCenter,,0,0,0,,用于描述树木
Dialogue: 0,0:17:53.93,0:17:55.09,BottomCenter,,0,0,0,,事实上有
Dialogue: 0,0:17:55.09,0:17:58.17,BottomCenter,,0,0,0,,经常使用的两种不同的隐喻
Dialogue: 0,0:17:58.50,0:18:02.17,BottomCenter,,0,0,0,,首先是树的递归描述
Dialogue: 0,0:18:02.29,0:18:05.79,BottomCenter,,0,0,0,,那里的一棵树就像一棵木树就像一棵苹果树
Dialogue: 0,0:18:06.93,0:18:07.93,BottomCenter,,0,0,0,,在这个描述中
Dialogue: 0,0:18:07.93,0:18:11.59,BottomCenter,,0,0,0,,一棵树有一个根标签和一个分支列表
Dialogue: 0,0:18:11.59,0:18:12.97,BottomCenter,,0,0,0,,这是根标签
Dialogue: 0,0:18:13.09,0:18:14.32,BottomCenter,,0,0,0,,有一个分支
Dialogue: 0,0:18:14.32,0:18:16.73,BottomCenter,,0,0,0,,这棵树只有两个分支
Dialogue: 0,0:18:16.76,0:18:18.93,BottomCenter,,0,0,0,,和右边的其他分支
Dialogue: 0,0:18:20.17,0:18:23.17,BottomCenter,,0,0,0,,顺便说一句，每个分支都是一棵树
Dialogue: 0,0:18:24.26,0:18:27.52,BottomCenter,,0,0,0,,这意味着该分支也有一个根标签
Dialogue: 0,0:18:28.50,0:18:31.70,BottomCenter,,0,0,0,,零个分支的树称为叶子
Dialogue: 0,0:18:32.06,0:18:34.00,BottomCenter,,0,0,0,,所以有一片叶子没有树枝
Dialogue: 0,0:18:34.00,0:18:36.26,BottomCenter,,0,0,0,,它确实有自己的根标签
Dialogue: 0,0:18:38.47,0:18:41.73,BottomCenter,,0,0,0,,现在，一旦你递归地构建了一棵树
Dialogue: 0,0:18:41.73,0:18:43.47,BottomCenter,,0,0,0,,你可能想要描述某些
Dialogue: 0,0:18:43.47,0:18:45.67,BottomCenter,,0,0,0,,树内的位置
Dialogue: 0,0:18:46.29,0:18:49.20,BottomCenter,,0,0,0,,所以我们在相关描述中说
Dialogue: 0,0:18:49.32,0:18:50.93,BottomCenter,,0,0,0,,关于家谱
Dialogue: 0,0:18:50.93,0:18:54.06,BottomCenter,,0,0,0,,树中的每个位置称为节点
Dialogue: 0,0:18:54.40,0:18:56.97,BottomCenter,,0,0,0,,这是我圈出的所有节点
Dialogue: 0,0:18:57.97,0:19:02.17,BottomCenter,,0,0,0,,这是根或顶部的根节点
Dialogue: 0,0:19:03.56,0:19:06.76,BottomCenter,,0,0,0,,每个节点都有一个标签，可以是任何值
Dialogue: 0,0:19:07.20,0:19:09.36,BottomCenter,,0,0,0,,所以数据存储在树中
Dialogue: 0,0:19:09.40,0:19:11.36,BottomCenter,,0,0,0,,存储在标签上
Dialogue: 0,0:19:13.36,0:19:16.50,BottomCenter,,0,0,0,,现在我称之为家谱亲属的原因
Dialogue: 0,0:19:16.50,0:19:17.36,BottomCenter,,0,0,0,,描述
Dialogue: 0,0:19:17.36,0:19:20.52,BottomCenter,,0,0,0,,一个节点可以是另一个节点的父节点或子节点
Dialogue: 0,0:19:21.06,0:19:23.36,BottomCenter,,0,0,0,,所以我们可以说这个节点包含两个
Dialogue: 0,0:19:23.36,0:19:26.36,BottomCenter,,0,0,0,,是包含三个的根节点的子节点
Dialogue: 0,0:19:27.52,0:19:31.70,BottomCenter,,0,0,0,,你还可以描述其他家庭关系
Dialogue: 0,0:19:31.79,0:19:35.70,BottomCenter,,0,0,0,,例如祖先、后代和兄弟姐妹
Dialogue: 0,0:19:37.93,0:19:40.59,BottomCenter,,0,0,0,,顺便说一句，人们经常提到这个标签
Dialogue: 0,0:19:40.59,0:19:43.29,BottomCenter,,0,0,0,,通过位置来评价自己
Dialogue: 0,0:19:43.29,0:19:44.20,BottomCenter,,0,0,0,,所以像
Dialogue: 0,0:19:44.20,0:19:46.76,BottomCenter,,0,0,0,,每个父母都是其孩子的总和
Dialogue: 0,0:19:46.90,0:19:49.59,BottomCenter,,0,0,0,,这对于斐波那契树来说是正确的
Dialogue: 0,0:19:52.86,0:19:54.67,BottomCenter,,0,0,0,,现在我们可以谈论树木了
Dialogue: 0,0:19:54.67,0:19:57.73,BottomCenter,,0,0,0,,我们可以讨论实现树抽象
Dialogue: 0,0:19:58.59,0:20:01.52,BottomCenter,,0,0,0,,一棵树在分支列表中有一个根标签
Dialogue: 0,0:20:01.52,0:20:05.26,BottomCenter,,0,0,0,,并且构造函数将采用接近的值
Dialogue: 0,0:20:05.67,0:20:07.73,BottomCenter,,0,0,0,,每个分支必须是一棵树
Dialogue: 0,0:20:08.56,0:20:08.73,BottomCenter,,0,0,0,,所以
Dialogue: 0,0:20:08.73,0:20:11.93,BottomCenter,,0,0,0,,如果我想为这个小构建一个表示
Dialogue: 0,0:20:11.93,0:20:14.90,BottomCenter,,0,0,0,,树我会写下面的代码
Dialogue: 0,0:20:14.90,0:20:17.40,BottomCenter,,0,0,0,,这是一棵根标签为 3 的树
Dialogue: 0,0:20:17.52,0:20:20.26,BottomCenter,,0,0,0,,树枝是一棵树，有一个
Dialogue: 0,0:20:20.26,0:20:22.40,BottomCenter,,0,0,0,,和一棵带有 2 1 1 的树
Dialogue: 0,0:20:23.70,0:20:24.40,BottomCenter,,0,0,0,,在这种情况下
Dialogue: 0,0:20:24.40,0:20:27.29,BottomCenter,,0,0,0,,我正在使用我所描述的构造函数
Dialogue: 0,0:20:27.40,0:20:30.76,BottomCenter,,0,0,0,,这样我就可以随心所欲地改变表述
Dialogue: 0,0:20:31.97,0:20:33.20,BottomCenter,,0,0,0,,现在你可能会说
Dialogue: 0,0:20:33.70,0:20:36.00,BottomCenter,,0,0,0,,我是不是违反了抽象障碍
Dialogue: 0,0:20:36.00,0:20:37.59,BottomCenter,,0,0,0,,因为我正在使用一个列表
Dialogue: 0,0:20:38.00,0:20:40.06,BottomCenter,,0,0,0,,不，这是抽象的一部分
Dialogue: 0,0:20:40.06,0:20:42.90,BottomCenter,,0,0,0,,一棵树有一个分支列表
Dialogue: 0,0:20:42.90,0:20:45.76,BottomCenter,,0,0,0,,所以我在这里使用列表完全没问题
Dialogue: 0,0:20:46.06,0:20:48.36,BottomCenter,,0,0,0,,因为那是抽象的一部分
Dialogue: 0,0:20:48.40,0:20:50.59,BottomCenter,,0,0,0,,它不是代表的一部分
Dialogue: 0,0:20:51.73,0:20:53.52,BottomCenter,,0,0,0,,现在让我们提出一个表示
Dialogue: 0,0:20:53.52,0:20:55.29,BottomCenter,,0,0,0,,我可以想出任何我想要的
Dialogue: 0,0:20:55.29,0:20:56.20,BottomCenter,,0,0,0,,这将决定
Dialogue: 0,0:20:56.20,0:20:58.59,BottomCenter,,0,0,0,,python实际打印出什么
Dialogue: 0,0:20:58.76,0:21:03.17,BottomCenter,,0,0,0,,当我评估这个构造函数表达式时
Dialogue: 0,0:21:03.70,0:21:04.86,BottomCenter,,0,0,0,,这就是我们将得到的
Dialogue: 0,0:21:05.00,0:21:07.56,BottomCenter,,0,0,0,,这只是列表中的一些列表
Dialogue: 0,0:21:07.79,0:21:10.00,BottomCenter,,0,0,0,,其中发出的标签值
Dialogue: 0,0:21:11.17,0:21:13.26,BottomCenter,,0,0,0,,我们构建它的方式是定义
Dialogue: 0,0:21:13.26,0:21:14.56,BottomCenter,,0,0,0,,构造函数树
Dialogue: 0,0:21:14.56,0:21:17.00,BottomCenter,,0,0,0,,它采用分支列表中的标签
Dialogue: 0,0:21:17.00,0:21:19.09,BottomCenter,,0,0,0,,默认情况下分支列表
Dialogue: 0,0:21:19.47,0:21:22.09,BottomCenter,,0,0,0,,默认情况下分支列表为空
Dialogue: 0,0:21:22.09,0:21:23.97,BottomCenter,,0,0,0,,所以默认情况下我会得到一片叶子
Dialogue: 0,0:21:24.09,0:21:26.86,BottomCenter,,0,0,0,,这就是为什么我只能在其中调用树
Dialogue: 0,0:21:26.93,0:21:30.47,BottomCenter,,0,0,0,,为了在这里构造这个叶节点
Dialogue: 0,0:21:30.90,0:21:32.56,BottomCenter,,0,0,0,,我将标签放入列表中
Dialogue: 0,0:21:32.56,0:21:35.73,BottomCenter,,0,0,0,,分支已经是一个列表，所以我将它们加在一起
Dialogue: 0,0:21:36.29,0:21:38.76,BottomCenter,,0,0,0,,树的标签是选择器
Dialogue: 0,0:21:38.86,0:21:41.97,BottomCenter,,0,0,0,,返回元素索引零
Dialogue: 0,0:21:42.06,0:21:44.50,BottomCenter,,0,0,0,,在树的列表表示中
Dialogue: 0,0:21:44.97,0:21:47.40,BottomCenter,,0,0,0,,分支是列表的其余部分
Dialogue: 0,0:21:47.40,0:21:49.09,BottomCenter,,0,0,0,,元素作为列表
Dialogue: 0,0:21:49.76,0:21:51.40,BottomCenter,,0,0,0,,现在为了确保
Dialogue: 0,0:21:51.40,0:21:53.40,BottomCenter,,0,0,0,,当我使用树构造函数时
Dialogue: 0,0:21:53.40,0:21:56.06,BottomCenter,,0,0,0,,我不会建造不是树的东西
Dialogue: 0,0:21:56.13,0:21:58.00,BottomCenter,,0,0,0,,我要添加一些检查
Dialogue: 0,0:21:58.26,0:22:00.93,BottomCenter,,0,0,0,,这里的第一个检查表示分支分支
Dialogue: 0,0:22:00.93,0:22:03.73,BottomCenter,,0,0,0,,断言分支是一棵树
Dialogue: 0,0:22:04.52,0:22:06.26,BottomCenter,,0,0,0,,作为抽象的一部分
Dialogue: 0,0:22:06.47,0:22:09.26,BottomCenter,,0,0,0,,我的代码将确保我遵守这一点
Dialogue: 0,0:22:09.26,0:22:12.06,BottomCenter,,0,0,0,,当我构建树时进行抽象
Dialogue: 0,0:22:12.97,0:22:14.26,BottomCenter,,0,0,0,,我也去打电话
Dialogue: 0,0:22:14.26,0:22:17.13,BottomCenter,,0,0,0,,列出分支机构而不是仅仅说
Dialogue: 0,0:22:17.20,0:22:19.59,BottomCenter,,0,0,0,,列表中的标签以及分支
Dialogue: 0,0:22:19.73,0:22:21.17,BottomCenter,,0,0,0,,为了确保
Dialogue: 0,0:22:21.26,0:22:24.32,BottomCenter,,0,0,0,,如果我传递某种其他类型的序列
Dialogue: 0,0:22:24.40,0:22:26.40,BottomCenter,,0,0,0,,它被转换为列表
Dialogue: 0,0:22:26.59,0:22:29.20,BottomCenter,,0,0,0,,添加到另一个列表之前
Dialogue: 0,0:22:30.09,0:22:32.36,BottomCenter,,0,0,0,,所以这两行实际上只是为了验证
Dialogue: 0,0:22:32.36,0:22:34.93,BottomCenter,,0,0,0,,尊重树的定义
Dialogue: 0,0:22:35.06,0:22:37.79,BottomCenter,,0,0,0,,在我编写的任何程序的主体内
Dialogue: 0,0:22:38.93,0:22:41.20,BottomCenter,,0,0,0,,我们如何知道树枝是否是树
Dialogue: 0,0:22:41.20,0:22:43.26,BottomCenter,,0,0,0,,任何东西都可以成为一棵树
Dialogue: 0,0:22:43.52,0:22:45.09,BottomCenter,,0,0,0,,它必须是一个列表
Dialogue: 0,0:22:45.17,0:22:48.06,BottomCenter,,0,0,0,,它必须至少有一个标签元素
Dialogue: 0,0:22:48.76,0:22:51.26,BottomCenter,,0,0,0,,所以如果这不是真的将会返回下降
Dialogue: 0,0:22:51.52,0:22:53.67,BottomCenter,,0,0,0,,并且必须是所有分支都是这样的
Dialogue: 0,0:22:53.67,0:22:54.20,BottomCenter,,0,0,0,,树
Dialogue: 0,0:22:54.20,0:22:58.47,BottomCenter,,0,0,0,,所以事实上树是一个树招募函数本身
Dialogue: 0,0:22:58.56,0:23:01.06,BottomCenter,,0,0,0,,贯穿了分支中的每一个分支
Dialogue: 0,0:23:01.06,0:23:03.09,BottomCenter,,0,0,0,,树，如果它不是
Dialogue: 0,0:23:03.56,0:23:04.79,BottomCenter,,0,0,0,,树那个分支
Dialogue: 0,0:23:04.79,0:23:07.47,BottomCenter,,0,0,0,,那么整个东西不可能是一棵树
Dialogue: 0,0:23:07.76,0:23:10.90,BottomCenter,,0,0,0,,如果这两项技术通过了那么它一定是一棵树
Dialogue: 0,0:23:11.73,0:23:12.93,BottomCenter,,0,0,0,,因为它有一个标签
Dialogue: 0,0:23:12.93,0:23:15.29,BottomCenter,,0,0,0,,它有树枝
Dialogue: 0,0:23:16.52,0:23:17.09,BottomCenter,,0,0,0,,最后
Dialogue: 0,0:23:17.09,0:23:19.56,BottomCenter,,0,0,0,,我将在我的树抽象中添加一个函数
Dialogue: 0,0:23:19.56,0:23:21.47,BottomCenter,,0,0,0,,这是一张支票
Dialogue: 0,0:23:21.56,0:23:24.26,BottomCenter,,0,0,0,,如果一棵树实际上只是一片叶子
Dialogue: 0,0:23:24.52,0:23:27.79,BottomCenter,,0,0,0,,检查分支是否为空
Dialogue: 0,0:23:28.06,0:23:30.79,BottomCenter,,0,0,0,,如果我调用树上的分支并返回空列表
Dialogue: 0,0:23:30.79,0:23:32.06,BottomCenter,,0,0,0,,这是一个错误的值
Dialogue: 0,0:23:32.06,0:23:34.73,BottomCenter,,0,0,0,,所以不是分支树将是真正的值
Dialogue: 0,0:23:34.79,0:23:37.56,BottomCenter,,0,0,0,,只要这棵树没有树枝
Dialogue: 0,0:23:38.32,0:23:41.00,BottomCenter,,0,0,0,,现在我们有了数据抽象的代码
Dialogue: 0,0:23:41.00,0:23:42.13,BottomCenter,,0,0,0,,我们可以用它
Dialogue: 0,0:23:42.76,0:23:45.47,BottomCenter,,0,0,0,,我们可以创建一棵只有叶子的树
Dialogue: 0,0:23:45.73,0:23:48.56,BottomCenter,,0,0,0,,它是一片叶子吗 哦，是的，它是
Dialogue: 0,0:23:49.56,0:23:52.93,BottomCenter,,0,0,0,,如果我想创建一棵有树枝的树
Dialogue: 0,0:23:53.13,0:23:55.90,BottomCenter,,0,0,0,,然后我在列表中指定这些分支
Dialogue: 0,0:23:55.90,0:23:58.73,BottomCenter,,0,0,0,,因为每棵树都应该有一个分支列表
Dialogue: 0,0:23:58.73,0:24:00.73,BottomCenter,,0,0,0,,默认为空
Dialogue: 0,0:24:01.56,0:24:04.13,BottomCenter,,0,0,0,,现在如果我在这里输入一个值
Dialogue: 0,0:24:04.13,0:24:05.32,BottomCenter,,0,0,0,,我会收到一个错误
Dialogue: 0,0:24:05.32,0:24:07.67,BottomCenter,,0,0,0,,说树枝一定是树
Dialogue: 0,0:24:07.97,0:24:10.56,BottomCenter,,0,0,0,,当我构建这个时，情况一定是这样
Dialogue: 0,0:24:10.70,0:24:14.56,BottomCenter,,0,0,0,,我放入分支列表中的所有内容本身就是一棵树
Dialogue: 0,0:24:15.76,0:24:19.36,BottomCenter,,0,0,0,,如果我想要一棵有树枝的树成为我的树枝之一
Dialogue: 0,0:24:19.36,0:24:21.47,BottomCenter,,0,0,0,,然后我给那棵树分枝
Dialogue: 0,0:24:22.17,0:24:24.20,BottomCenter,,0,0,0,,在这种情况下，我们只放一片叶子
Dialogue: 0,0:24:25.00,0:24:27.56,BottomCenter,,0,0,0,,所以我完成了五根扎根的树
Dialogue: 0,0:24:28.00,0:24:31.29,BottomCenter,,0,0,0,,我想要另一个分支，它是单叶
Dialogue: 0,0:24:31.32,0:24:32.97,BottomCenter,,0,0,0,,以六为根
Dialogue: 0,0:24:33.26,0:24:35.97,BottomCenter,,0,0,0,,现在我已经列出了树的所有分支
Dialogue: 0,0:24:36.13,0:24:37.36,BottomCenter,,0,0,0,,那儿有棵树
Dialogue: 0,0:24:38.59,0:24:39.76,BottomCenter,,0,0,0,,请注意，当我
Dialogue: 0,0:24:39.93,0:24:42.13,BottomCenter,,0,0,0,,评估此构造函数表达式
Dialogue: 0,0:24:42.13,0:24:43.40,BottomCenter,,0,0,0,,没有错误
Dialogue: 0,0:24:43.40,0:24:45.47,BottomCenter,,0,0,0,,因为我已经建了一棵结构良好的树
Dialogue: 0,0:24:46.00,0:24:47.36,BottomCenter,,0,0,0,,现在恰好是
Dialogue: 0,0:24:47.47,0:24:51.09,BottomCenter,,0,0,0,,它有这个复杂的嵌套表示
Dialogue: 0,0:24:51.40,0:24:53.59,BottomCenter,,0,0,0,,但这不是我访问它的方式
Dialogue: 0,0:24:53.67,0:24:56.67,BottomCenter,,0,0,0,,并说我就问一下t的标签是什么
Dialogue: 0,0:24:56.90,0:24:57.79,BottomCenter,,0,0,0,,这是一个
Dialogue: 0,0:24:58.52,0:25:00.73,BottomCenter,,0,0,0,,t 的分支是什么
Dialogue: 0,0:25:01.59,0:25:03.13,BottomCenter,,0,0,0,,当一堆树
Dialogue: 0,0:25:03.13,0:25:04.97,BottomCenter,,0,0,0,,如果我想得到
Dialogue: 0,0:25:05.20,0:25:08.06,BottomCenter,,0,0,0,,索引零的分支然后我就这样写
Dialogue: 0,0:25:08.13,0:25:09.26,BottomCenter,,0,0,0,,那是一棵树
Dialogue: 0,0:25:09.56,0:25:12.36,BottomCenter,,0,0,0,,我可以获得该分支的根标签
Dialogue: 0,0:25:12.36,0:25:14.20,BottomCenter,,0,0,0,,只需索要标签即可
Dialogue: 0,0:25:14.47,0:25:16.86,BottomCenter,,0,0,0,,索引零分支的
Dialogue: 0,0:25:17.26,0:25:19.06,BottomCenter,,0,0,0,,将分支视为列表
Dialogue: 0,0:25:19.06,0:25:21.76,BottomCenter,,0,0,0,,我没有违反任何抽象障碍
Dialogue: 0,0:25:21.90,0:25:24.00,BottomCenter,,0,0,0,,因为我抽象地说
Dialogue: 0,0:25:24.09,0:25:26.36,BottomCenter,,0,0,0,,一棵树有一个分支列表
Dialogue: 0,0:25:28.79,0:25:32.06,BottomCenter,,0,0,0,,以树作为输入的函数
Dialogue: 0,0:25:32.13,0:25:34.73,BottomCenter,,0,0,0,,或返回树作为输出
Dialogue: 0,0:25:35.06,0:25:38.36,BottomCenter,,0,0,0,,树本身通常是递归的
Dialogue: 0,0:25:39.50,0:25:41.67,BottomCenter,,0,0,0,,让我们看一些例子
Dialogue: 0,0:25:42.40,0:25:44.86,BottomCenter,,0,0,0,,在实践中并不经常
Dialogue: 0,0:25:44.86,0:25:47.59,BottomCenter,,0,0,0,,使用树构造函数创建树
Dialogue: 0,0:25:47.59,0:25:49.76,BottomCenter,,0,0,0,,和一组明确的标签
Dialogue: 0,0:25:49.93,0:25:53.17,BottomCenter,,0,0,0,,而是以编程方式生成树
Dialogue: 0,0:25:53.67,0:25:56.73,BottomCenter,,0,0,0,,例如，如果我想创建一个函数
Dialogue: 0,0:25:56.97,0:25:59.50,BottomCenter,,0,0,0,,构建斐波那契树
Dialogue: 0,0:25:59.73,0:26:02.00,BottomCenter,,0,0,0,,然后我会用下面的方式写
Dialogue: 0,0:26:02.86,0:26:05.26,BottomCenter,,0,0,0,,如果 n 小于等于 1
Dialogue: 0,0:26:05.52,0:26:09.50,BottomCenter,,0,0,0,,这意味着 n 的 fib 树只是一片叶子
Dialogue: 0,0:26:10.26,0:26:13.06,BottomCenter,,0,0,0,,我使用树构造函数创建叶子
Dialogue: 0,0:26:14.52,0:26:15.32,BottomCenter,,0,0,0,,否则
Dialogue: 0,0:26:15.73,0:26:19.29,BottomCenter,,0,0,0,,我需要构建斐波那契树的两个分支
Dialogue: 0,0:26:19.50,0:26:21.70,BottomCenter,,0,0,0,,左分支和右分支
Dialogue: 0,0:26:22.13,0:26:24.06,BottomCenter,,0,0,0,,都将被建造
Dialogue: 0,0:26:24.13,0:26:26.56,BottomCenter,,0,0,0,,递归调用 fib 树
Dialogue: 0,0:26:31.59,0:26:33.76,BottomCenter,,0,0,0,,最后我想归还一棵树
Dialogue: 0,0:26:34.90,0:26:37.06,BottomCenter,,0,0,0,,这意味着给树构造函数着色
Dialogue: 0,0:26:37.29,0:26:38.86,BottomCenter,,0,0,0,,在某些标签值上
Dialogue: 0,0:26:38.90,0:26:42.26,BottomCenter,,0,0,0,,并将分支放入列表中
Dialogue: 0,0:26:43.56,0:26:45.32,BottomCenter,,0,0,0,,标签值又如何呢
Dialogue: 0,0:26:45.52,0:26:48.73,BottomCenter,,0,0,0,,在这里我应用斐波那契递推
Dialogue: 0,0:26:49.09,0:26:51.17,BottomCenter,,0,0,0,,我得到了左边树的标签
Dialogue: 0,0:26:51.17,0:26:53.56,BottomCenter,,0,0,0,,并将其添加到右侧树的标签中
Dialogue: 0,0:26:55.52,0:26:58.67,BottomCenter,,0,0,0,,fibtree 1 或 fibtree 0 的基本情况
Dialogue: 0,0:26:58.67,0:26:59.86,BottomCenter,,0,0,0,,只是一片叶子
Dialogue: 0,0:27:00.36,0:27:03.56,BottomCenter,,0,0,0,,fibtree 2 内部有结构
Dialogue: 0,0:27:03.90,0:27:05.00,BottomCenter,,0,0,0,,这是标签
Dialogue: 0,0:27:05.13,0:27:08.40,BottomCenter,,0,0,0,,有两个分支，都是叶子
Dialogue: 0,0:27:09.13,0:27:10.29,BottomCenter,,0,0,0,,纤维树四
Dialogue: 0,0:27:10.59,0:27:12.09,BottomCenter,,0,0,0,,是斐波那契树
Dialogue: 0,0:27:12.09,0:27:14.86,BottomCenter,,0,0,0,,到目前为止我们已经在示例中看到了
Dialogue: 0,0:27:15.56,0:27:16.52,BottomCenter,,0,0,0,,所以它的标签
Dialogue: 0,0:27:17.29,0:27:22.73,BottomCenter,,0,0,0,,是三，那么它有多少片叶子 1 2 3 4 5
Dialogue: 0,0:27:22.73,0:27:23.90,BottomCenter,,0,0,0,,不同的叶子
Dialogue: 0,0:27:25.36,0:27:28.13,BottomCenter,,0,0,0,,很多时候我们会编写接受以下内容的函数
Dialogue: 0,0:27:28.13,0:27:30.17,BottomCenter,,0,0,0,,树并用它们做有趣的事情
Dialogue: 0,0:27:31.00,0:27:33.00,BottomCenter,,0,0,0,,这是一件不太有趣的事情
Dialogue: 0,0:27:33.06,0:27:34.52,BottomCenter,,0,0,0,,举个简单的例子
Dialogue: 0,0:27:34.90,0:27:37.59,BottomCenter,,0,0,0,,如果我想数一棵树上的叶子 t
Dialogue: 0,0:27:38.20,0:27:41.06,BottomCenter,,0,0,0,,我要写一个树递归函数
Dialogue: 0,0:27:41.76,0:27:43.40,BottomCenter,,0,0,0,,处理树叶
Dialogue: 0,0:27:43.40,0:27:46.59,BottomCenter,,0,0,0,,偏离树处理函数的基本情况
Dialogue: 0,0:27:47.09,0:27:50.90,BottomCenter,,0,0,0,,如果 t 只是一片叶子，我数一下叶子的数量
Dialogue: 0,0:27:50.90,0:27:51.86,BottomCenter,,0,0,0,,有一片叶子
Dialogue: 0,0:27:52.93,0:27:55.70,BottomCenter,,0,0,0,,递归情况通常会进行递归调用
Dialogue: 0,0:27:55.70,0:27:56.90,BottomCenter,,0,0,0,,在每个分支上
Dialogue: 0,0:27:57.09,0:27:59.40,BottomCenter,,0,0,0,,然后汇总结果
Dialogue: 0,0:28:00.67,0:28:02.20,BottomCenter,,0,0,0,,在这种情况下我们要做的
Dialogue: 0,0:28:02.20,0:28:05.40,BottomCenter,,0,0,0,,就是取树的分支中的每个分支
Dialogue: 0,0:28:05.40,0:28:07.59,BottomCenter,,0,0,0,,并数一下每个树枝上的叶子
Dialogue: 0,0:28:08.09,0:28:09.67,BottomCenter,,0,0,0,,整个树中的叶子
Dialogue: 0,0:28:09.67,0:28:12.40,BottomCenter,,0,0,0,,只是树枝上所有叶子的总和
Dialogue: 0,0:28:14.32,0:28:16.56,BottomCenter,,0,0,0,,这是我们的第一个树处理函数
Dialogue: 0,0:28:19.29,0:28:21.00,BottomCenter,,0,0,0,,让我们再看一遍
Dialogue: 0,0:28:21.00,0:28:22.09,BottomCenter,,0,0,0,,t进来了
Dialogue: 0,0:28:22.09,0:28:25.06,BottomCenter,,0,0,0,,不知道是大树还是小树
Dialogue: 0,0:28:25.17,0:28:27.93,BottomCenter,,0,0,0,,如果在最简单的情况下它只是一片叶子
Dialogue: 0,0:28:28.13,0:28:31.13,BottomCenter,,0,0,0,,然后我知道该怎么做了 我只是说有一片叶子
Dialogue: 0,0:28:31.67,0:28:32.47,BottomCenter,,0,0,0,,否则
Dialogue: 0,0:28:32.97,0:28:34.76,BottomCenter,,0,0,0,,我总结了所有
Dialogue: 0,0:28:34.76,0:28:36.50,BottomCenter,,0,0,0,,的制作结果
Dialogue: 0,0:28:36.50,0:28:39.40,BottomCenter,,0,0,0,,对每个分支进行递归调用
Dialogue: 0,0:28:40.20,0:28:41.67,BottomCenter,,0,0,0,,数叶子
Dialogue: 0,0:28:42.32,0:28:46.32,BottomCenter,,0,0,0,,b for b 在树的分支中
Dialogue: 0,0:28:47.76,0:28:50.56,BottomCenter,,0,0,0,,那么 count leaves 函数有什么特别之处
Dialogue: 0,0:28:50.59,0:28:52.70,BottomCenter,,0,0,0,,是它在基本情况下返回的内容
Dialogue: 0,0:28:52.79,0:28:55.73,BottomCenter,,0,0,0,,以及它如何聚合递归调用
Dialogue: 0,0:28:56.17,0:28:58.90,BottomCenter,,0,0,0,,当然不要忘记返回结果
Dialogue: 0,0:29:00.13,0:29:02.70,BottomCenter,,0,0,0,,我们在那棵谎言树之前看到了四
Dialogue: 0,0:29:03.26,0:29:04.76,BottomCenter,,0,0,0,,有五片叶子
Dialogue: 0,0:29:04.86,0:29:07.06,BottomCenter,,0,0,0,,让我们确保我们的计数离开函数
Dialogue: 0,0:29:07.06,0:29:08.32,BottomCenter,,0,0,0,,返回五
Dialogue: 0,0:29:08.32,0:29:09.32,BottomCenter,,0,0,0,,确实如此
Dialogue: 0,0:29:10.00,0:29:12.93,BottomCenter,,0,0,0,,顺便说一句，现在 fib 树变得相当大了
Dialogue: 0,0:29:12.93,0:29:17.06,BottomCenter,,0,0,0,,斐波那契 10 号树位于顶部的斐波那契树 10
Dialogue: 0,0:29:17.47,0:29:18.79,BottomCenter,,0,0,0,,有很多叶子
Dialogue: 0,0:29:18.79,0:29:20.13,BottomCenter,,0,0,0,,有多少片叶子
Dialogue: 0,0:29:20.26,0:29:21.17,BottomCenter,,0,0,0,,我们数一下
Dialogue: 0,0:29:22.47,0:29:24.00,BottomCenter,,0,0,0,,89 叶
Dialogue: 0,0:29:24.29,0:29:28.67,BottomCenter,,0,0,0,,一个有趣的事实是 89 是斐波那契第 11 位
Dialogue: 0,0:29:30.97,0:29:32.59,BottomCenter,,0,0,0,,这是一个讨论问题
Dialogue: 0,0:29:33.26,0:29:34.52,BottomCenter,,0,0,0,,实施叶
Dialogue: 0,0:29:34.52,0:29:38.00,BottomCenter,,0,0,0,,返回树的叶子标签列表
Dialogue: 0,0:29:39.20,0:29:41.73,BottomCenter,,0,0,0,,那么它是如何在某棵树上工作的
Dialogue: 0,0:29:42.56,0:29:44.36,BottomCenter,,0,0,0,,你称其为叶子
Dialogue: 0,0:29:44.36,0:29:46.59,BottomCenter,,0,0,0,,它给你叶子的所有值
Dialogue: 0,0:29:46.59,0:29:49.50,BottomCenter,,0,0,0,,所以请注意根标签三不在这里
Dialogue: 0,0:29:49.56,0:29:51.17,BottomCenter,,0,0,0,,仅叶子标签
Dialogue: 0,0:29:52.09,0:29:54.26,BottomCenter,,0,0,0,,为了实现这个功能
Dialogue: 0,0:29:54.50,0:29:57.32,BottomCenter,,0,0,0,,我们将使用一些效果
Dialogue: 0,0:29:57.70,0:30:01.26,BottomCenter,,0,0,0,,也就是说，如果你有一些列表的列表
Dialogue: 0,0:30:01.26,0:30:02.52,BottomCenter,,0,0,0,,你得到一个清单
Dialogue: 0,0:30:02.52,0:30:03.26,BottomCenter,,0,0,0,,含有
Dialogue: 0,0:30:03.26,0:30:06.47,BottomCenter,,0,0,0,,输入中所有列表的元素
Dialogue: 0,0:30:06.97,0:30:08.86,BottomCenter,,0,0,0,,让我给你看一些例子
Dialogue: 0,0:30:09.36,0:30:12.73,BottomCenter,,0,0,0,,如果你对列表一二三四进行求和
Dialogue: 0,0:30:13.13,0:30:16.17,BottomCenter,,0,0,0,,你得到一个包含一二三和四的列表
Dialogue: 0,0:30:17.09,0:30:18.56,BottomCenter,,0,0,0,,为了打电话给一些
Dialogue: 0,0:30:18.56,0:30:19.93,BottomCenter,,0,0,0,,在列表的列表中
Dialogue: 0,0:30:19.93,0:30:23.13,BottomCenter,,0,0,0,,并让它聚合这些列表中的所有值
Dialogue: 0,0:30:23.13,0:30:25.29,BottomCenter,,0,0,0,,你必须提供一个起始值
Dialogue: 0,0:30:25.52,0:30:26.97,BottomCenter,,0,0,0,,一个空列表的
Dialogue: 0,0:30:27.97,0:30:31.50,BottomCenter,,0,0,0,,如果我将一个列表与一个相加，我会得到一个列表与一个
Dialogue: 0,0:30:31.97,0:30:34.20,BottomCenter,,0,0,0,,如果我总结一个列表
Dialogue: 0,0:30:34.59,0:30:36.70,BottomCenter,,0,0,0,,有两个元素
Dialogue: 0,0:30:36.70,0:30:40.52,BottomCenter,,0,0,0,,第一个元素是列表中的列表
Dialogue: 0,0:30:41.06,0:30:41.32,BottomCenter,,0,0,0,,然后
Dialogue: 0,0:30:41.32,0:30:44.00,BottomCenter,,0,0,0,,我得到的仍然是列表中的列表
Dialogue: 0,0:30:44.00,0:30:45.09,BottomCenter,,0,0,0,,在输出中
Dialogue: 0,0:30:45.17,0:30:46.09,BottomCenter,,0,0,0,,注意差异
Dialogue: 0,0:30:46.09,0:30:48.13,BottomCenter,,0,0,0,,这个结构和那个结构之间
Dialogue: 0,0:30:48.32,0:30:50.59,BottomCenter,,0,0,0,,一个是输出中的一个值
Dialogue: 0,0:30:50.59,0:30:54.40,BottomCenter,,0,0,0,,在这种情况下，包含一个的列表是此处的一个值
Dialogue: 0,0:30:54.73,0:30:57.56,BottomCenter,,0,0,0,,所以仅仅对整个树求和是不够的
Dialogue: 0,0:30:57.56,0:30:59.70,BottomCenter,,0,0,0,,并获取其中的所有标签
Dialogue: 0,0:30:59.76,0:31:00.52,BottomCenter,,0,0,0,,因为
Dialogue: 0,0:31:00.52,0:31:03.36,BottomCenter,,0,0,0,,some 不会删除所有嵌套结构
Dialogue: 0,0:31:03.36,0:31:05.29,BottomCenter,,0,0,0,,它只是摆脱了一层
Dialogue: 0,0:31:07.09,0:31:10.40,BottomCenter,,0,0,0,,好吧这里是树处理的实现
Dialogue: 0,0:31:10.40,0:31:13.06,BottomCenter,,0,0,0,,接受一些树的函数
Dialogue: 0,0:31:13.56,0:31:16.79,BottomCenter,,0,0,0,,并返回叶子标签的列表
Dialogue: 0,0:31:17.86,0:31:19.00,BottomCenter,,0,0,0,,如果它是一片叶子
Dialogue: 0,0:31:19.29,0:31:20.50,BottomCenter,,0,0,0,,然后我们得到标签
Dialogue: 0,0:31:20.86,0:31:22.59,BottomCenter,,0,0,0,,并将其放入列表中
Dialogue: 0,0:31:23.09,0:31:25.47,BottomCenter,,0,0,0,,否则我们总结一些东西
Dialogue: 0,0:31:26.40,0:31:28.32,BottomCenter,,0,0,0,,这里有八种选择
Dialogue: 0,0:31:28.76,0:31:31.76,BottomCenter,,0,0,0,,我建议你停下来想一想
Dialogue: 0,0:31:31.93,0:31:36.26,BottomCenter,,0,0,0,,我会在321告诉你答案
Dialogue: 0,0:31:37.36,0:31:39.00,BottomCenter,,0,0,0,,我们的目标是
Dialogue: 0,0:31:39.06,0:31:42.56,BottomCenter,,0,0,0,,获取每个分支的叶子标签列表
Dialogue: 0,0:31:42.59,0:31:44.00,BottomCenter,,0,0,0,,然后把它们全部放在
Dialogue: 0,0:31:44.09,0:31:47.47,BottomCenter,,0,0,0,,放入所有叶子标签的一长串列表中
Dialogue: 0,0:31:48.00,0:31:50.70,BottomCenter,,0,0,0,,我们通过对递归调用求和来得到
Dialogue: 0,0:31:50.70,0:31:52.06,BottomCenter,,0,0,0,,到 b 的叶子
Dialogue: 0,0:31:52.06,0:31:54.73,BottomCenter,,0,0,0,,对于树分支中的每个 b
Dialogue: 0,0:31:56.09,0:31:59.40,BottomCenter,,0,0,0,,所以这与计算叶子几乎相同
Dialogue: 0,0:31:59.52,0:32:01.73,BottomCenter,,0,0,0,,除了我们有不同的基本情况
Dialogue: 0,0:32:01.86,0:32:03.52,BottomCenter,,0,0,0,,以及一些不同的用途
Dialogue: 0,0:32:03.59,0:32:05.76,BottomCenter,,0,0,0,,意味着不同的聚合方式
Dialogue: 0,0:32:05.76,0:32:08.97,BottomCenter,,0,0,0,,递归调用的返回值
Dialogue: 0,0:32:09.90,0:32:12.56,BottomCenter,,0,0,0,,从另一棵树创建一棵树的函数是
Dialogue: 0,0:32:12.56,0:32:14.56,BottomCenter,,0,0,0,,通常也是递归的
Dialogue: 0,0:32:15.06,0:32:17.50,BottomCenter,,0,0,0,,例如如果我有一棵树
Dialogue: 0,0:32:17.52,0:32:19.06,BottomCenter,,0,0,0,,也许这是一棵斐波那契树
Dialogue: 0,0:32:19.06,0:32:20.56,BottomCenter,,0,0,0,,也许是不同的东西
Dialogue: 0,0:32:20.76,0:32:23.50,BottomCenter,,0,0,0,,我想做的是返回一棵新树
Dialogue: 0,0:32:23.50,0:32:25.56,BottomCenter,,0,0,0,,完全相同的结构
Dialogue: 0,0:32:25.86,0:32:28.70,BottomCenter,,0,0,0,,但叶子标签已增加
Dialogue: 0,0:32:29.20,0:32:31.79,BottomCenter,,0,0,0,,然后我会写一个树递归函数
Dialogue: 0,0:32:31.79,0:32:33.67,BottomCenter,,0,0,0,,建造新树
Dialogue: 0,0:32:34.09,0:32:37.32,BottomCenter,,0,0,0,,如果我正在建造一棵只有一片叶子的树
Dialogue: 0,0:32:37.67,0:32:39.13,BottomCenter,,0,0,0,,我得到了标签
Dialogue: 0,0:32:39.97,0:32:41.50,BottomCenter,,0,0,0,,我给它添加一个
Dialogue: 0,0:32:41.86,0:32:43.67,BottomCenter,,0,0,0,,然后我需要返回一棵树
Dialogue: 0,0:32:43.67,0:32:46.09,BottomCenter,,0,0,0,,因为这就是增量叶子的作用
Dialogue: 0,0:32:46.29,0:32:50.32,BottomCenter,,0,0,0,,所以快速检查一下我这里是否有正确的范围
Dialogue: 0,0:32:50.32,0:32:52.70,BottomCenter,,0,0,0,,我正在归还树木，就像我应该做的那样
Dialogue: 0,0:32:53.67,0:32:56.79,BottomCenter,,0,0,0,,在这种情况下，我们返回一片叶子，因为我们得到了一片叶子
Dialogue: 0,0:32:57.40,0:33:01.06,BottomCenter,,0,0,0,,如果给我一棵不是叶子的树
Dialogue: 0,0:33:01.17,0:33:01.97,BottomCenter,,0,0,0,,那么我需要
Dialogue: 0,0:33:01.97,0:33:05.47,BottomCenter,,0,0,0,,增加该树所有分支中的叶子
Dialogue: 0,0:33:06.06,0:33:09.90,BottomCenter,,0,0,0,,然后用这些新分支构建一棵新树
Dialogue: 0,0:33:10.26,0:33:12.73,BottomCenter,,0,0,0,,请注意，我保持标签相同
Dialogue: 0,0:33:12.97,0:33:16.90,BottomCenter,,0,0,0,,那是因为这个函数没有做任何事情
Dialogue: 0,0:33:16.90,0:33:18.13,BottomCenter,,0,0,0,,与标签
Dialogue: 0,0:33:18.17,0:33:20.47,BottomCenter,,0,0,0,,不是叶子的节点
Dialogue: 0,0:33:21.56,0:33:24.59,BottomCenter,,0,0,0,,这是另一个树处理函数增量 t
Dialogue: 0,0:33:24.73,0:33:26.59,BottomCenter,,0,0,0,,返回一棵像 t 这样的树
Dialogue: 0,0:33:26.73,0:33:29.40,BottomCenter,,0,0,0,,但所有标签都会增加
Dialogue: 0,0:33:29.76,0:33:31.17,BottomCenter,,0,0,0,,我来教你一个技巧
Dialogue: 0,0:33:31.40,0:33:32.59,BottomCenter,,0,0,0,,你并不总是
Dialogue: 0,0:33:32.59,0:33:35.70,BottomCenter,,0,0,0,,叶子需要有一个单独的基础案例
Dialogue: 0,0:33:35.79,0:33:38.40,BottomCenter,,0,0,0,,如果每棵树都受到同样的对待
Dialogue: 0,0:33:38.97,0:33:41.76,BottomCenter,,0,0,0,,这是一张单行纸，上面写着
Dialogue: 0,0:33:42.36,0:33:45.67,BottomCenter,,0,0,0,,返回一棵我已增加标签的树
Dialogue: 0,0:33:46.00,0:33:47.40,BottomCenter,,0,0,0,,我已经增加了
Dialogue: 0,0:33:47.40,0:33:50.20,BottomCenter,,0,0,0,,所有分支中的所有标签
Dialogue: 0,0:33:51.17,0:33:52.79,BottomCenter,,0,0,0,,这是树递归
Dialogue: 0,0:33:53.40,0:33:55.67,BottomCenter,,0,0,0,,我们如何达到基本情况
Dialogue: 0,0:33:55.93,0:33:59.26,BottomCenter,,0,0,0,,当没有树枝（例如叶子）时
Dialogue: 0,0:33:59.70,0:34:02.20,BottomCenter,,0,0,0,,这是一个空列表，我们就完成了
Dialogue: 0,0:34:02.20,0:34:05.26,BottomCenter,,0,0,0,,当我们到达叶子时，我们不会进行任何递归调用
Dialogue: 0,0:34:05.70,0:34:08.53,BottomCenter,,0,0,0,,我们不需要使用 if 语句来表达这一点
Dialogue: 0,0:34:08.67,0:34:11.26,BottomCenter,,0,0,0,,因为这是内置于列表推导式中的
Dialogue: 0,0:34:11.26,0:34:13.13,BottomCenter,,0,0,0,,如果这个列表是空的
Dialogue: 0,0:34:13.13,0:34:15.32,BottomCenter,,0,0,0,,那么整个领悟都是空的
Dialogue: 0,0:34:15.32,0:34:18.19,BottomCenter,,0,0,0,,并且不需要任何工作来构建
Dialogue: 0,0:34:20.80,0:34:24.17,BottomCenter,,0,0,0,,这是另一个树处理函数的示例
Dialogue: 0,0:34:25.09,0:34:27.86,BottomCenter,,0,0,0,,我将编写一个打印树的函数
Dialogue: 0,0:34:29.30,0:34:32.30,BottomCenter,,0,0,0,,它会首先打印那棵树的标签
Dialogue: 0,0:34:33.19,0:34:37.32,BottomCenter,,0,0,0,,然后对于每个分支它将调用打印树
Dialogue: 0,0:34:37.80,0:34:38.90,BottomCenter,,0,0,0,,在树枝上
Dialogue: 0,0:34:39.26,0:34:40.67,BottomCenter,,0,0,0,,我不返回任何东西
Dialogue: 0,0:34:40.90,0:34:41.53,BottomCenter,,0,0,0,,反而
Dialogue: 0,0:34:41.53,0:34:45.50,BottomCenter,,0,0,0,,该函数的存在是为了显示树值
Dialogue: 0,0:34:45.73,0:34:47.07,BottomCenter,,0,0,0,,这样我们就不用看
Dialogue: 0,0:34:47.07,0:34:48.76,BottomCenter,,0,0,0,,始终嵌套列表
Dialogue: 0,0:34:49.53,0:34:52.30,BottomCenter,,0,0,0,,如果我在 fib 树上调用 print 树
Dialogue: 0,0:34:53.13,0:34:53.92,BottomCenter,,0,0,0,,四
Dialogue: 0,0:34:54.36,0:34:56.40,BottomCenter,,0,0,0,,我可以看到所有的值
Dialogue: 0,0:34:56.96,0:34:58.90,BottomCenter,,0,0,0,,但我看不到这个结构
Dialogue: 0,0:34:59.46,0:35:01.30,BottomCenter,,0,0,0,,让我们写一个更好的打印树
Dialogue: 0,0:35:01.57,0:35:05.53,BottomCenter,,0,0,0,,使用缩进来显示结构
Dialogue: 0,0:35:06.69,0:35:08.96,BottomCenter,,0,0,0,,如果我想缩进
Dialogue: 0,0:35:09.53,0:35:13.96,BottomCenter,,0,0,0,,五对空格，然后写
Dialogue: 0,0:35:14.50,0:35:16.76,BottomCenter,,0,0,0,,之后的No.5
Dialogue: 0,0:35:17.09,0:35:17.96,BottomCenter,,0,0,0,,我会建造
Dialogue: 0,0:35:17.96,0:35:20.92,BottomCenter,,0,0,0,,使用乘法和加法的字符串
Dialogue: 0,0:35:21.09,0:35:24.57,BottomCenter,,0,0,0,,如果我打印出来然后我会得到五个缩进
Dialogue: 0,0:35:25.90,0:35:26.80,BottomCenter,,0,0,0,,默认情况下
Dialogue: 0,0:35:26.80,0:35:30.19,BottomCenter,,0,0,0,,我根本不希望根标签缩进
Dialogue: 0,0:35:31.36,0:35:34.32,BottomCenter,,0,0,0,,但我希望有发生缩进的可能性
Dialogue: 0,0:35:34.32,0:35:37.57,BottomCenter,,0,0,0,,稍后我将把这两个空格放在哪里
Dialogue: 0,0:35:37.57,0:35:39.96,BottomCenter,,0,0,0,,将它们乘以缩进级别
Dialogue: 0,0:35:40.09,0:35:44.07,BottomCenter,,0,0,0,,然后添加 t 标签的字符串表示形式
Dialogue: 0,0:35:45.69,0:35:46.53,BottomCenter,,0,0,0,,那样
Dialogue: 0,0:35:46.53,0:35:49.32,BottomCenter,,0,0,0,,发生缩进是我要缩进
Dialogue: 0,0:35:49.32,0:35:50.59,BottomCenter,,0,0,0,,所有分支机构
Dialogue: 0,0:35:51.67,0:35:54.07,BottomCenter,,0,0,0,,因为这是根据缩进定义的
Dialogue: 0,0:35:54.07,0:35:55.53,BottomCenter,,0,0,0,,如果我得到一个分支的一个分支
Dialogue: 0,0:35:55.53,0:35:57.50,BottomCenter,,0,0,0,,它将缩进两次
Dialogue: 0,0:35:58.26,0:36:01.19,BottomCenter,,0,0,0,,所以现在当我打印树纤维树四时
Dialogue: 0,0:36:01.19,0:36:03.32,BottomCenter,,0,0,0,,我可以清楚地看到结构
Dialogue: 0,0:36:03.59,0:36:05.30,BottomCenter,,0,0,0,,即使对于更大的树
Dialogue: 0,0:36:05.40,0:36:08.00,BottomCenter,,0,0,0,,我可以清楚地看到有纤维树四
Dialogue: 0,0:36:08.26,0:36:11.80,BottomCenter,,0,0,0,,又出现了小纤维树四作为树枝之一
Dialogue: 0,0:36:11.80,0:36:14.46,BottomCenter,,0,0,0,,这是纤维树五的另一个分支
Dialogue: 0,0:36:15.73,0:36:18.76,BottomCenter,,0,0,0,,标签的缩进级别
Dialogue: 0,0:36:18.96,0:36:22.19,BottomCenter,,0,0,0,,对应于它在树中的深度
Dialogue: 0,0:36:23.53,0:36:25.13,BottomCenter,,0,0,0,,让我们再看一个例子
Dialogue: 0,0:36:25.13,0:36:27.76,BottomCenter,,0,0,0,,关于沿路径求和所有标签
Dialogue: 0,0:36:27.76,0:36:29.96,BottomCenter,,0,0,0,,从到树叶的路线
Dialogue: 0,0:36:30.09,0:36:31.69,BottomCenter,,0,0,0,,然后打印出该总和
Dialogue: 0,0:36:32.53,0:36:35.40,BottomCenter,,0,0,0,,一些递归函数建立它们的结果
Dialogue: 0,0:36:35.67,0:36:39.30,BottomCenter,,0,0,0,,通过操纵递归调用的返回值
Dialogue: 0,0:36:39.53,0:36:41.80,BottomCenter,,0,0,0,,其中其他递归函数
Dialogue: 0,0:36:41.86,0:36:44.76,BottomCenter,,0,0,0,,通过传递信息来建立结果
Dialogue: 0,0:36:45.00,0:36:47.50,BottomCenter,,0,0,0,,作为参数进入递归调用
Dialogue: 0,0:36:47.90,0:36:50.00,BottomCenter,,0,0,0,,当以下情况时，这两种策略都很有用
Dialogue: 0,0:36:50.00,0:36:51.26,BottomCenter,,0,0,0,,处理树
Dialogue: 0,0:36:51.73,0:36:53.09,BottomCenter,,0,0,0,,让我们看一个例子
Dialogue: 0,0:36:53.09,0:36:54.90,BottomCenter,,0,0,0,,两种做事方式
Dialogue: 0,0:36:57.13,0:36:58.76,BottomCenter,,0,0,0,,在处理树木之前
Dialogue: 0,0:36:58.76,0:37:01.53,BottomCenter,,0,0,0,,让我们回到我们的老朋友阶乘
Dialogue: 0,0:37:02.32,0:37:05.67,BottomCenter,,0,0,0,,一种写法是如果等于零
Dialogue: 0,0:37:06.90,0:37:08.00,BottomCenter,,0,0,0,,我们返回一个
Dialogue: 0,0:37:08.17,0:37:10.26,BottomCenter,,0,0,0,,否则我们返回结束时间
Dialogue: 0,0:37:10.26,0:37:12.80,BottomCenter,,0,0,0,,对 n 减一调用事实的结果
Dialogue: 0,0:37:13.30,0:37:15.92,BottomCenter,,0,0,0,,如果我们在四个上运行这个例子
Dialogue: 0,0:37:15.96,0:37:17.13,BottomCenter,,0,0,0,,那么我们会得到四乘三
Dialogue: 0,0:37:17.13,0:37:18.86,BottomCenter,,0,0,0,,两倍乘以一等于24
Dialogue: 0,0:37:20.36,0:37:21.67,BottomCenter,,0,0,0,,这是一个例子
Dialogue: 0,0:37:21.67,0:37:25.13,BottomCenter,,0,0,0,,获取递归调用的返回值
Dialogue: 0,0:37:25.36,0:37:29.13,BottomCenter,,0,0,0,,并在这种情况下对其进行操作以使其相乘
Dialogue: 0,0:37:30.32,0:37:31.40,BottomCenter,,0,0,0,,但还有另一种方法
Dialogue: 0,0:37:31.90,0:37:35.30,BottomCenter,,0,0,0,,相反，我可以定义事实时间
Dialogue: 0,0:37:35.50,0:37:37.59,BottomCenter,,0,0,0,,其中包含 n 和 k
Dialogue: 0,0:37:38.32,0:37:40.13,BottomCenter,,0,0,0,,而不是返回
Dialogue: 0,0:37:40.26,0:37:44.32,BottomCenter,,0,0,0,,只是结束时间结束减一倍结束减二
Dialogue: 0,0:37:44.40,0:37:48.59,BottomCenter,,0,0,0,,这将返回 k 次 end 次 end 减一
Dialogue: 0,0:37:48.90,0:37:50.86,BottomCenter,,0,0,0,,乘以结束减二 乘以结束减三
Dialogue: 0,0:37:50.86,0:37:52.67,BottomCenter,,0,0,0,,一直降到一
Dialogue: 0,0:37:53.53,0:37:55.00,BottomCenter,,0,0,0,,我们将按如下方式进行
Dialogue: 0,0:37:55.17,0:37:58.30,BottomCenter,,0,0,0,,如果 n 为零将返回 k
Dialogue: 0,0:37:58.53,0:38:00.86,BottomCenter,,0,0,0,,因为 n 阶乘只是一
Dialogue: 0,0:38:01.36,0:38:04.92,BottomCenter,,0,0,0,,否则我们将返回调用的结果
Dialogue: 0,0:38:04.92,0:38:08.09,BottomCenter,,0,0,0,,n 减一的影响时间
Dialogue: 0,0:38:08.17,0:38:09.57,BottomCenter,,0,0,0,,和 k 乘以 n
Dialogue: 0,0:38:11.19,0:38:13.50,BottomCenter,,0,0,0,,我认为这个例子的有趣之处在于
Dialogue: 0,0:38:13.59,0:38:16.32,BottomCenter,,0,0,0,,是我们没有操纵返回值
Dialogue: 0,0:38:16.32,0:38:19.09,BottomCenter,,0,0,0,,这个递归称为效应时间
Dialogue: 0,0:38:19.69,0:38:21.53,BottomCenter,,0,0,0,,相反，我们只是返回它
Dialogue: 0,0:38:22.46,0:38:25.46,BottomCenter,,0,0,0,,这意味着递归调用的结果
Dialogue: 0,0:38:25.73,0:38:27.96,BottomCenter,,0,0,0,,最好是当前调用的结果
Dialogue: 0,0:38:28.67,0:38:30.26,BottomCenter,,0,0,0,,扩展这个推理
Dialogue: 0,0:38:30.30,0:38:32.96,BottomCenter,,0,0,0,,这意味着基本情况的结果
Dialogue: 0,0:38:33.17,0:38:34.13,BottomCenter,,0,0,0,,需要是
Dialogue: 0,0:38:34.32,0:38:37.57,BottomCenter,,0,0,0,,与原始递归调用的结果相同
Dialogue: 0,0:38:38.19,0:38:40.30,BottomCenter,,0,0,0,,在这种情况下事实证明是这样
Dialogue: 0,0:38:40.96,0:38:44.17,BottomCenter,,0,0,0,,所以如果我们尝试计算 k 次和阶乘
Dialogue: 0,0:38:44.30,0:38:45.67,BottomCenter,,0,0,0,,这是表达式
Dialogue: 0,0:38:46.00,0:38:47.86,BottomCenter,,0,0,0,,事实证明这是相同的
Dialogue: 0,0:38:48.00,0:38:52.13,BottomCenter,,0,0,0,,到 k 乘以 n 乘并减去一阶乘
Dialogue: 0,0:38:52.40,0:38:53.96,BottomCenter,,0,0,0,,这是 k 乘以 n
Dialogue: 0,0:38:54.50,0:38:56.76,BottomCenter,,0,0,0,,这是 和 减去一个阶乘
Dialogue: 0,0:38:57.40,0:38:59.96,BottomCenter,,0,0,0,,所以这里正在建立结果
Dialogue: 0,0:39:00.13,0:39:02.07,BottomCenter,,0,0,0,,当你达到基本情况时
Dialogue: 0,0:39:02.07,0:39:04.07,BottomCenter,,0,0,0,,你已经完成了所有的乘法
Dialogue: 0,0:39:04.46,0:39:05.90,BottomCenter,,0,0,0,,而在这个版本中
Dialogue: 0,0:39:06.07,0:39:07.86,BottomCenter,,0,0,0,,你根本没有做任何乘法
Dialogue: 0,0:39:07.86,0:39:09.26,BottomCenter,,0,0,0,,当你达到基本情况时
Dialogue: 0,0:39:09.26,0:39:11.57,BottomCenter,,0,0,0,,这一切都会在你回来后发生
Dialogue: 0,0:39:12.67,0:39:13.26,BottomCenter,,0,0,0,,事实上
Dialogue: 0,0:39:13.26,0:39:16.86,BottomCenter,,0,0,0,,如果我们想用事实时间来定义事实
Dialogue: 0,0:39:16.90,0:39:18.13,BottomCenter,,0,0,0,,那不会太难
Dialogue: 0,0:39:19.07,0:39:20.59,BottomCenter,,0,0,0,,我们刚刚返回了结果
Dialogue: 0,0:39:20.59,0:39:23.53,BottomCenter,,0,0,0,,在第 nn 次调用事实时间
Dialogue: 0,0:39:25.13,0:39:27.09,BottomCenter,,0,0,0,,事实上四仍然是24
Dialogue: 0,0:39:29.30,0:39:32.09,BottomCenter,,0,0,0,,好吧，现在让我们看一个关于树的例子
Dialogue: 0,0:39:32.73,0:39:35.36,BottomCenter,,0,0,0,,所以我有一个包含所有内容的文件
Dialogue: 0,0:39:35.53,0:39:38.53,BottomCenter,,0,0,0,,树构造函数和选择器函数已经在其中
Dialogue: 0,0:39:38.92,0:39:40.32,BottomCenter,,0,0,0,,称为树点 pi
Dialogue: 0,0:39:40.59,0:39:42.30,BottomCenter,,0,0,0,,所以如果我想能够使用所有这些
Dialogue: 0,0:39:42.30,0:39:45.26,BottomCenter,,0,0,0,,我可以写一个导入语句来导入它们
Dialogue: 0,0:39:46.17,0:39:47.67,BottomCenter,,0,0,0,,现在我可以造一棵树了
Dialogue: 0,0:39:48.19,0:39:49.19,BottomCenter,,0,0,0,,一棵数树
Dialogue: 0,0:39:49.92,0:39:51.07,BottomCenter,,0,0,0,,可能看起来像
Dialogue: 0,0:39:51.90,0:39:53.19,BottomCenter,,0,0,0,,三是根
Dialogue: 0,0:39:53.36,0:39:57.57,BottomCenter,,0,0,0,,然后我们有一个分支，它的叶子有四个
Dialogue: 0,0:39:57.80,0:40:00.53,BottomCenter,,0,0,0,,我们还有另一个不是叶子的树枝
Dialogue: 0,0:40:00.69,0:40:02.53,BottomCenter,,0,0,0,,五个和六个
Dialogue: 0,0:40:07.13,0:40:08.50,BottomCenter,,0,0,0,,让我们再有一棵树
Dialogue: 0,0:40:09.07,0:40:11.59,BottomCenter,,0,0,0,,里面有字母的
Dialogue: 0,0:40:12.67,0:40:14.92,BottomCenter,,0,0,0,,我们将 h 放在根部
Dialogue: 0,0:40:15.76,0:40:17.76,BottomCenter,,0,0,0,,它有一个根植于 a 的分支
Dialogue: 0,0:40:18.26,0:40:19.90,BottomCenter,,0,0,0,,这将有两片叶子
Dialogue: 0,0:40:21.86,0:40:24.73,BottomCenter,,0,0,0,,s叶和t叶
Dialogue: 0,0:40:25.96,0:40:27.53,BottomCenter,,0,0,0,,然后我们也会有
Dialogue: 0,0:40:28.19,0:40:29.07,BottomCenter,,0,0,0,,和 e
Dialogue: 0,0:40:30.19,0:40:33.36,BottomCenter,,0,0,0,,这是h路线下自己的叶子
Dialogue: 0,0:40:34.90,0:40:36.50,BottomCenter,,0,0,0,,所以匆忙是一棵树
Dialogue: 0,0:40:36.96,0:40:37.57,BottomCenter,,0,0,0,,具有
Dialogue: 0,0:40:37.57,0:40:40.50,BottomCenter,,0,0,0,,内部一堆列表的底层表示
Dialogue: 0,0:40:40.50,0:40:41.80,BottomCenter,,0,0,0,,列表中的列表
Dialogue: 0,0:40:42.67,0:40:44.86,BottomCenter,,0,0,0,,但我可以得到它的标签，那就是 h
Dialogue: 0,0:40:45.32,0:40:46.86,BottomCenter,,0,0,0,,我可以得到它的分支
Dialogue: 0,0:40:50.46,0:40:53.80,BottomCenter,,0,0,0,,好吧，假设我们要写一个函数
Dialogue: 0,0:40:54.09,0:40:55.90,BottomCenter,,0,0,0,,吸收一棵树
Dialogue: 0,0:40:56.40,0:40:59.17,BottomCenter,,0,0,0,,查找所有叶子和每片叶子
Dialogue: 0,0:40:59.36,0:41:01.69,BottomCenter,,0,0,0,,打印出所有标签的总和
Dialogue: 0,0:41:01.69,0:41:03.36,BottomCenter,,0,0,0,,从到那片叶子的路线
Dialogue: 0,0:41:07.59,0:41:10.17,BottomCenter,,0,0,0,,很像事实时间函数
Dialogue: 0,0:41:10.32,0:41:12.96,BottomCenter,,0,0,0,,我要添加第二个参数
Dialogue: 0,0:41:13.76,0:41:15.40,BottomCenter,,0,0,0,,到目前为止的总和
Dialogue: 0,0:41:18.26,0:41:20.53,BottomCenter,,0,0,0,,这样我就可以边走边积累这笔钱
Dialogue: 0,0:41:20.59,0:41:23.13,BottomCenter,,0,0,0,,然后当我到达叶子时我就把它打印出来
Dialogue: 0,0:41:24.09,0:41:25.92,BottomCenter,,0,0,0,,所以这是否是一片叶子
Dialogue: 0,0:41:25.96,0:41:27.30,BottomCenter,,0,0,0,,会有一个标签
Dialogue: 0,0:41:27.30,0:41:29.09,BottomCenter,,0,0,0,,我们应该将其添加到到目前为止
Dialogue: 0,0:41:34.00,0:41:34.80,BottomCenter,,0,0,0,,但是之后
Dialogue: 0,0:41:35.59,0:41:37.80,BottomCenter,,0,0,0,,我们会弄清楚我们是否在叶子上
Dialogue: 0,0:41:39.86,0:41:42.96,BottomCenter,,0,0,0,,如果是，那么我们打印出到目前为止的总和
Dialogue: 0,0:41:42.96,0:41:46.73,BottomCenter,,0,0,0,,其中包括叶子标签及其上方的所有内容
Dialogue: 0,0:41:47.19,0:41:49.96,BottomCenter,,0,0,0,,否则我们会遍历所有分支
Dialogue: 0,0:41:52.07,0:41:54.26,BottomCenter,,0,0,0,,t 是一棵树，所以我可以调用它的分支
Dialogue: 0,0:41:54.32,0:41:57.96,BottomCenter,,0,0,0,,我得到一个树列表，所以每个 b 都是一棵树
Dialogue: 0,0:41:58.67,0:42:01.80,BottomCenter,,0,0,0,,打印总和是我可以在树上调用的函数
Dialogue: 0,0:42:02.13,0:42:06.80,BottomCenter,,0,0,0,,所以如果我调用以零开头的数字的打印总和
Dialogue: 0,0:42:06.92,0:42:08.19,BottomCenter,,0,0,0,,我会看到七个
Dialogue: 0,0:42:08.69,0:42:10.50,BottomCenter,,0,0,0,,这七个来自
Dialogue: 0,0:42:10.90,0:42:12.57,BottomCenter,,0,0,0,,路线三
Dialogue: 0,0:42:12.90,0:42:15.00,BottomCenter,,0,0,0,,接下来是四个
Dialogue: 0,0:42:15.40,0:42:18.53,BottomCenter,,0,0,0,,它位于路线正下方，是一片叶子
Dialogue: 0,0:42:18.86,0:42:21.00,BottomCenter,,0,0,0,,另一件应该打印出来的是
Dialogue: 0,0:42:21.00,0:42:23.09,BottomCenter,,0,0,0,,沿路径从三个的总和
Dialogue: 0,0:42:23.59,0:42:24.69,BottomCenter,,0,0,0,,到五
Dialogue: 0,0:42:24.69,0:42:28.32,BottomCenter,,0,0,0,,哦，但是五不是一片叶子，所以我们还没有打印到六
Dialogue: 0,0:42:28.73,0:42:30.86,BottomCenter,,0,0,0,,三加五加六等于14
Dialogue: 0,0:42:31.00,0:42:32.76,BottomCenter,,0,0,0,,这是我们在这里找到的 14 号
Dialogue: 0,0:42:33.96,0:42:37.36,BottomCenter,,0,0,0,,当我们匆忙调用 print sums 时会发生什么
Dialogue: 0,0:42:37.36,0:42:41.07,BottomCenter,,0,0,0,,相反，我认为我们应该从树开始
Dialogue: 0,0:42:41.17,0:42:44.59,BottomCenter,,0,0,0,,一个空字符串，以便我们可以向其中添加更多字符串
Dialogue: 0,0:42:44.92,0:42:48.09,BottomCenter,,0,0,0,,此时我们打印出
Dialogue: 0,0:42:48.76,0:42:54.32,BottomCenter,,0,0,0,,来自 HAS，我们到达了一片叶子
Dialogue: 0,0:42:54.76,0:42:56.59,BottomCenter,,0,0,0,,或帽子 h
Dialogue: 0,0:42:57.19,0:42:58.00,BottomCenter,,0,0,0,,A
Dialogue: 0,0:42:58.53,0:43:01.19,BottomCenter,,0,0,0,,我们到达一片树叶或热源
Dialogue: 0,0:43:01.59,0:43:04.57,BottomCenter,,0,0,0,,这条路线下面的叶子是哪一片
Dialogue: 0,0:43:05.80,0:43:07.73,BottomCenter,,0,0,0,,以及这个函数的结构
Dialogue: 0,0:43:07.92,0:43:08.90,BottomCenter,,0,0,0,,是我们
Dialogue: 0,0:43:09.00,0:43:10.92,BottomCenter,,0,0,0,,边走边积累总和
Dialogue: 0,0:43:10.92,0:43:13.80,BottomCenter,,0,0,0,,总是将新值传递到到目前为止
Dialogue: 0,0:43:14.13,0:43:16.67,BottomCenter,,0,0,0,,我本来可以写到这里加上标签
Dialogue: 0,0:43:16.67,0:43:18.53,BottomCenter,,0,0,0,,而不是这个赋值语句
Dialogue: 0,0:43:19.13,0:43:20.67,BottomCenter,,0,0,0,,那也很好
Dialogue: 0,0:43:21.00,0:43:23.13,BottomCenter,,0,0,0,,或者我们可以只更新到目前为止
Dialogue: 0,0:43:23.30,0:43:25.92,BottomCenter,,0,0,0,,然后使用新值来打印
Dialogue: 0,0:43:26.07,0:43:29.40,BottomCenter,,0,0,0,,或传递给所有递归调用
