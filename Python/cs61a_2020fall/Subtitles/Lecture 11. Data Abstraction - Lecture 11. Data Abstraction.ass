[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: Lecture 11. Data Abstraction - Lecture 11. Data Abstraction
ScriptType: v4.00+
PlayResX: 1280
PlayResY: 720
Timer: 10.0000
WrapStyle: 0
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: TopLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,7,32,32,32,0
Style: TopCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,8,32,32,32,0
Style: TopRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,9,32,32,32,0
Style: BottomLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,1,32,32,32,0
Style: BottomCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,2,32,32,32,0
Style: BottomRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,3,32,32,32,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.47,0:00:02.47,BottomCenter,,0,0,0,,sixty one eight lecture No.11
Dialogue: 0,0:00:02.67,0:00:03.60,BottomCenter,,0,0,0,,announcements
Dialogue: 0,0:00:04.13,0:00:06.60,BottomCenter,,0,0,0,,thanks for recording yourself taking midterm one
Dialogue: 0,0:00:06.73,0:00:08.93,BottomCenter,,0,0,0,,if you have not yet been contacted
Dialogue: 0,0:00:08.97,0:00:11.40,BottomCenter,,0,0,0,,about saving your midterm one recording
Dialogue: 0,0:00:11.50,0:00:12.97,BottomCenter,,0,0,0,,you can delete it
Dialogue: 0,0:00:13.80,0:00:15.00,BottomCenter,,0,0,0,,if you had trouble making
Dialogue: 0,0:00:15.00,0:00:16.87,BottomCenter,,0,0,0,,the recording in the first place
Dialogue: 0,0:00:16.97,0:00:19.27,BottomCenter,,0,0,0,,we do have your notes about that
Dialogue: 0,0:00:19.33,0:00:20.47,BottomCenter,,0,0,0,,and that's okay
Dialogue: 0,0:00:20.47,0:00:21.90,BottomCenter,,0,0,0,,there will be no penalty
Dialogue: 0,0:00:22.00,0:00:24.37,BottomCenter,,0,0,0,,and we will try to improve the process
Dialogue: 0,0:00:24.37,0:00:25.73,BottomCenter,,0,0,0,,for future exams
Dialogue: 0,0:00:26.73,0:00:29.20,BottomCenter,,0,0,0,,most people had no problem making a recording
Dialogue: 0,0:00:29.57,0:00:32.10,BottomCenter,,0,0,0,,but the ones that did found it very frustrating
Dialogue: 0,0:00:32.10,0:00:33.37,BottomCenter,,0,0,0,,and I'm sorry for that
Dialogue: 0,0:00:34.00,0:00:35.77,BottomCenter,,0,0,0,,we'll try to figure out how to make it better
Dialogue: 0,0:00:36.50,0:00:38.60,BottomCenter,,0,0,0,,homework two is due on Thursday
Dialogue: 0,0:00:38.87,0:00:43.00,BottomCenter,,0,0,0,,and next week the cats project is due on Friday
Dialogue: 0,0:00:43.40,0:00:45.33,BottomCenter,,0,0,0,,you can get an early submission bonus point
Dialogue: 0,0:00:45.33,0:00:47.47,BottomCenter,,0,0,0,,for submitting the project on Thursday
Dialogue: 0,0:00:47.67,0:00:50.00,BottomCenter,,0,0,0,,and if you want the checkpoint which is one point
Dialogue: 0,0:00:50.00,0:00:51.57,BottomCenter,,0,0,0,,to make sure that you're tracking toward
Dialogue: 0,0:00:51.57,0:00:53.53,BottomCenter,,0,0,0,,the solution at an efficient rate
Dialogue: 0,0:00:53.80,0:00:56.67,BottomCenter,,0,0,0,,you need to complete the first part of the project by
Dialogue: 0,0:00:56.67,0:00:59.87,BottomCenter,,0,0,0,,Tuesday this project includes course topics
Dialogue: 0,0:00:59.87,0:01:01.72,BottomCenter,,0,0,0,,including today's lecture
Dialogue: 0,0:01:02.27,0:01:04.67,BottomCenter,,0,0,0,,as well as everything earlier in the course
Dialogue: 0,0:01:05.59,0:01:07.17,BottomCenter,,0,0,0,,and what is the cats project
Dialogue: 0,0:01:07.50,0:01:11.87,BottomCenter,,0,0,0,,well it's something that tests your typing speed
Dialogue: 0,0:01:11.96,0:01:14.79,BottomCenter,,0,0,0,,there's a command line interface and a web interface
Dialogue: 0,0:01:14.93,0:01:19.47,BottomCenter,,0,0,0,,and your code has to compute the accuracy and the speed
Dialogue: 0,0:01:20.33,0:01:21.67,BottomCenter,,0,0,0,,of whatever is typed
Dialogue: 0,0:01:22.26,0:01:23.50,BottomCenter,,0,0,0,,so let's try it
Dialogue: 0,0:01:28.76,0:01:30.06,BottomCenter,,0,0,0,,what a mess
Dialogue: 0,0:01:47.73,0:01:49.17,BottomCenter,,0,0,0,,look I made mistakes
Dialogue: 0,0:01:49.30,0:01:52.26,BottomCenter,,0,0,0,,my accuracy was only 87.5%
Dialogue: 0,0:01:53.26,0:01:54.56,BottomCenter,,0,0,0,,wouldn't it be nice
Dialogue: 0,0:01:54.70,0:01:57.56,BottomCenter,,0,0,0,,if it could correct my mistakes as I type
Dialogue: 0,0:01:58.67,0:02:01.29,BottomCenter,,0,0,0,,uh huh will enable auto correct
Dialogue: 0,0:02:02.00,0:02:06.96,BottomCenter,,0,0,0,,now as I type if I make a mistake like having
Dialogue: 0,0:02:07.29,0:02:09.53,BottomCenter,,0,0,0,,then it's going to try to correct it for me
Dialogue: 0,0:02:10.06,0:02:13.27,BottomCenter,,0,0,0,,it doesn't actually look at what you're trying to type
Dialogue: 0,0:02:13.33,0:02:14.19,BottomCenter,,0,0,0,,it just looks at
Dialogue: 0,0:02:14.19,0:02:16.87,BottomCenter,,0,0,0,,what you've typed so far in order to guess
Dialogue: 0,0:02:16.87,0:02:19.53,BottomCenter,,0,0,0,,about what you should have typed instead
Dialogue: 0,0:02:25.09,0:02:25.90,BottomCenter,,0,0,0,,up to
Dialogue: 0,0:02:26.72,0:02:28.16,BottomCenter,,0,0,0,,that point all you can see
Dialogue: 0,0:02:28.16,0:02:29.06,BottomCenter,,0,0,0,,my accuracy
Dialogue: 0,0:02:29.06,0:02:32.00,BottomCenter,,0,0,0,,is much better now that I have auto correct on
Dialogue: 0,0:02:32.16,0:02:34.16,BottomCenter,,0,0,0,,if I type a real word like wit
Dialogue: 0,0:02:34.16,0:02:35.72,BottomCenter,,0,0,0,,then it's not going to correct that
Dialogue: 0,0:02:35.80,0:02:37.12,BottomCenter,,0,0,0,,but if I type various
Dialogue: 0,0:02:37.12,0:02:37.80,BottomCenter,,0,0,0,,non words
Dialogue: 0,0:02:37.80,0:02:40.40,BottomCenter,,0,0,0,,then it will try to guess what word I meant to take
Dialogue: 0,0:02:42.19,0:02:43.87,BottomCenter,,0,0,0,,oh and even corrected that one
Dialogue: 0,0:02:45.69,0:02:47.30,BottomCenter,,0,0,0,,so that's the cats project
Dialogue: 0,0:02:47.30,0:02:48.53,BottomCenter,,0,0,0,,hope you enjoy it
Dialogue: 0,0:02:49.06,0:02:50.53,BottomCenter,,0,0,0,,you'll use some recursion
Dialogue: 0,0:02:50.66,0:02:51.72,BottomCenter,,0,0,0,,some containers
Dialogue: 0,0:02:51.80,0:02:55.53,BottomCenter,,0,0,0,,and some data abstraction to implement that program
Dialogue: 0,0:02:57.27,0:02:58.87,BottomCenter,,0,0,0,,data abstraction
Dialogue: 0,0:02:59.59,0:03:01.37,BottomCenter,,0,0,0,,a new method of abstraction
Dialogue: 0,0:03:02.56,0:03:03.37,BottomCenter,,0,0,0,,here we go
Dialogue: 0,0:03:04.06,0:03:07.77,BottomCenter,,0,0,0,,so most values are compound values
Dialogue: 0,0:03:07.87,0:03:09.30,BottomCenter,,0,0,0,,in the sense that they combine
Dialogue: 0,0:03:09.30,0:03:11.16,BottomCenter,,0,0,0,,different objects together
Dialogue: 0,0:03:11.46,0:03:14.96,BottomCenter,,0,0,0,,in order to create some object with multiple parts
Dialogue: 0,0:03:15.30,0:03:17.12,BottomCenter,,0,0,0,,such as a date which has a year
Dialogue: 0,0:03:17.12,0:03:20.59,BottomCenter,,0,0,0,,a month and a day all combined together into one thing
Dialogue: 0,0:03:21.19,0:03:22.90,BottomCenter,,0,0,0,,or a geographic position
Dialogue: 0,0:03:22.97,0:03:25.47,BottomCenter,,0,0,0,,would have a latitude and a longitude
Dialogue: 0,0:03:27.06,0:03:29.06,BottomCenter,,0,0,0,,an abstract dated type
Dialogue: 0,0:03:29.53,0:03:33.40,BottomCenter,,0,0,0,,lets us manipulate compound objects as units
Dialogue: 0,0:03:33.69,0:03:35.47,BottomCenter,,0,0,0,,that's a form of abstraction
Dialogue: 0,0:03:37.47,0:03:38.37,BottomCenter,,0,0,0,,what it does
Dialogue: 0,0:03:38.87,0:03:42.09,BottomCenter,,0,0,0,,is it allows us to isolate two parts of any program
Dialogue: 0,0:03:42.12,0:03:43.37,BottomCenter,,0,0,0,,that uses data
Dialogue: 0,0:03:44.53,0:03:47.47,BottomCenter,,0,0,0,,we want to separate how data are represented
Dialogue: 0,0:03:49.12,0:03:51.40,BottomCenter,,0,0,0,,and how data are manipulated
Dialogue: 0,0:03:52.69,0:03:53.90,BottomCenter,,0,0,0,,by doing this
Dialogue: 0,0:03:54.37,0:03:56.80,BottomCenter,,0,0,0,,we separate good concerns within our program
Dialogue: 0,0:03:57.69,0:03:59.47,BottomCenter,,0,0,0,,among two different areas
Dialogue: 0,0:03:59.47,0:04:01.90,BottomCenter,,0,0,0,,and we can change one without affecting the other
Dialogue: 0,0:04:02.77,0:04:05.19,BottomCenter,,0,0,0,,so data abstraction is a methodology
Dialogue: 0,0:04:05.37,0:04:09.16,BottomCenter,,0,0,0,,by which functions enforce an abstraction bay area
Dialogue: 0,0:04:09.80,0:04:14.00,BottomCenter,,0,0,0,,between representation of data and the use of that data
Dialogue: 0,0:04:15.72,0:04:16.39,BottomCenter,,0,0,0,,now
Dialogue: 0,0:04:16.39,0:04:19.60,BottomCenter,,0,0,0,,all programmers work with compound data at some point
Dialogue: 0,0:04:20.00,0:04:25.06,BottomCenter,,0,0,0,,but only great programmers embrace data abstraction
Dialogue: 0,0:04:25.67,0:04:28.30,BottomCenter,,0,0,0,,in order to make their programs more modular
Dialogue: 0,0:04:28.80,0:04:32.12,BottomCenter,,0,0,0,,and you too will be a great programmer very soon
Dialogue: 0,0:04:34.10,0:04:35.89,BottomCenter,,0,0,0,,let's take a look at an example
Dialogue: 0,0:04:36.19,0:04:37.30,BottomCenter,,0,0,0,,rational numbers
Dialogue: 0,0:04:37.30,0:04:39.50,BottomCenter,,0,0,0,,and we'll see what we mean by data abstraction
Dialogue: 0,0:04:40.50,0:04:42.47,BottomCenter,,0,0,0,,so a rational number can be expressed
Dialogue: 0,0:04:42.52,0:04:45.30,BottomCenter,,0,0,0,,as numerator divided by a denominator
Dialogue: 0,0:04:45.50,0:04:48.60,BottomCenter,,0,0,0,,where both numerator and denominators are integers
Dialogue: 0,0:04:48.73,0:04:51.06,BottomCenter,,0,0,0,,and since we can represent integers exactly
Dialogue: 0,0:04:51.06,0:04:54.50,BottomCenter,,0,0,0,,this gives us an exact representation of fractions
Dialogue: 0,0:04:55.12,0:04:58.26,BottomCenter,,0,0,0,,so a pair of integers lets us tell you exactly what a
Dialogue: 0,0:04:58.37,0:04:59.52,BottomCenter,,0,0,0,,fraction we have
Dialogue: 0,0:04:59.67,0:05:01.52,BottomCenter,,0,0,0,,such as one divided by three
Dialogue: 0,0:05:01.80,0:05:04.50,BottomCenter,,0,0,0,,but as soon as we actually divide one by three
Dialogue: 0,0:05:04.69,0:05:06.32,BottomCenter,,0,0,0,,then we'll get back a float
Dialogue: 0,0:05:06.93,0:05:09.39,BottomCenter,,0,0,0,,which is not an exact representation
Dialogue: 0,0:05:09.39,0:05:11.73,BottomCenter,,0,0,0,,but a finite approximation of it
Dialogue: 0,0:05:12.37,0:05:14.10,BottomCenter,,0,0,0,,through a binary expansion
Dialogue: 0,0:05:14.76,0:05:15.17,BottomCenter,,0,0,0,,so
Dialogue: 0,0:05:15.17,0:05:17.52,BottomCenter,,0,0,0,,we want to separate the numerator and the denominator
Dialogue: 0,0:05:17.60,0:05:19.00,BottomCenter,,0,0,0,,not divide one by the other
Dialogue: 0,0:05:19.00,0:05:21.12,BottomCenter,,0,0,0,,but instead have a compound data type
Dialogue: 0,0:05:22.80,0:05:24.56,BottomCenter,,0,0,0,,so we assume that we can compose
Dialogue: 0,0:05:24.56,0:05:26.97,BottomCenter,,0,0,0,,decompose rational numbers as follows
Dialogue: 0,0:05:26.97,0:05:29.32,BottomCenter,,0,0,0,,we have a function rational which takes
Dialogue: 0,0:05:29.39,0:05:31.80,BottomCenter,,0,0,0,,n and d enumerator and a denominator
Dialogue: 0,0:05:31.87,0:05:33.00,BottomCenter,,0,0,0,,which are integers
Dialogue: 0,0:05:33.19,0:05:37.10,BottomCenter,,0,0,0,,and returns a compound data type a rational number x
Dialogue: 0,0:05:38.76,0:05:39.97,BottomCenter,,0,0,0,,we have another function
Dialogue: 0,0:05:40.00,0:05:40.69,BottomCenter,,0,0,0,,numer x
Dialogue: 0,0:05:40.69,0:05:43.97,BottomCenter,,0,0,0,,which returns the numerator of a rational number x
Dialogue: 0,0:05:44.47,0:05:46.32,BottomCenter,,0,0,0,,and likewise we have a d nom
Dialogue: 0,0:05:46.32,0:05:49.12,BottomCenter,,0,0,0,,x function which returns to the denominator
Dialogue: 0,0:05:49.37,0:05:51.10,BottomCenter,,0,0,0,,so we have a way of combining together
Dialogue: 0,0:05:51.10,0:05:52.73,BottomCenter,,0,0,0,,enumerator and a denominator
Dialogue: 0,0:05:52.87,0:05:56.52,BottomCenter,,0,0,0,,and then we have a way of selecting those two parts
Dialogue: 0,0:05:57.10,0:05:58.69,BottomCenter,,0,0,0,,this is called a constructor
Dialogue: 0,0:05:58.69,0:05:59.76,BottomCenter,,0,0,0,,it builds a new
Dialogue: 0,0:06:00.30,0:06:03.69,BottomCenter,,0,0,0,,value which is an instance from an abstract data type
Dialogue: 0,0:06:04.32,0:06:05.80,BottomCenter,,0,0,0,,and then these are selectors
Dialogue: 0,0:06:05.80,0:06:07.73,BottomCenter,,0,0,0,,which are the functions that get back
Dialogue: 0,0:06:08.00,0:06:11.30,BottomCenter,,0,0,0,,those parts of the whole rational number
Dialogue: 0,0:06:14.26,0:06:15.32,BottomCenter,,0,0,0,,what we can do then
Dialogue: 0,0:06:15.32,0:06:15.50,BottomCenter,,0,0,0,,is
Dialogue: 0,0:06:15.50,0:06:17.97,BottomCenter,,0,0,0,,we can start writing other functions that manipulate
Dialogue: 0,0:06:17.97,0:06:19.12,BottomCenter,,0,0,0,,rational numbers
Dialogue: 0,0:06:20.26,0:06:22.97,BottomCenter,,0,0,0,,such as adding them together or multiplying them
Dialogue: 0,0:06:22.97,0:06:23.97,BottomCenter,,0,0,0,,let's take a look
Dialogue: 0,0:06:24.80,0:06:26.80,BottomCenter,,0,0,0,,so just to refresh your memory
Dialogue: 0,0:06:26.80,0:06:30.12,BottomCenter,,0,0,0,,if we want to multiply three halves and three fists
Dialogue: 0,0:06:30.17,0:06:31.89,BottomCenter,,0,0,0,,we get nine tenths
Dialogue: 0,0:06:31.89,0:06:33.06,BottomCenter,,0,0,0,,and why is that
Dialogue: 0,0:06:33.12,0:06:35.89,BottomCenter,,0,0,0,,well the general formula for multiplying together
Dialogue: 0,0:06:35.93,0:06:37.30,BottomCenter,,0,0,0,,two rational numbers
Dialogue: 0,0:06:38.12,0:06:39.73,BottomCenter,,0,0,0,,is that the numerator
Dialogue: 0,0:06:40.73,0:06:41.87,BottomCenter,,0,0,0,,of the result
Dialogue: 0,0:06:41.89,0:06:43.87,BottomCenter,,0,0,0,,is the product of the numerators of the first
Dialogue: 0,0:06:43.87,0:06:44.67,BottomCenter,,0,0,0,,in the second
Dialogue: 0,0:06:45.32,0:06:48.17,BottomCenter,,0,0,0,,and the denominator is the product of the denominators
Dialogue: 0,0:06:49.56,0:06:50.26,BottomCenter,,0,0,0,,adding together
Dialogue: 0,0:06:50.26,0:06:52.60,BottomCenter,,0,0,0,,two rational numbers is slightly more complicated
Dialogue: 0,0:06:52.73,0:06:56.19,BottomCenter,,0,0,0,,three halfs plus three fist gives you 21 tenths
Dialogue: 0,0:06:56.19,0:06:57.39,BottomCenter,,0,0,0,,how do we get that
Dialogue: 0,0:06:57.69,0:07:00.39,BottomCenter,,0,0,0,,while in general if we have two rational numbers
Dialogue: 0,0:07:00.56,0:07:02.56,BottomCenter,,0,0,0,,then we multiply the numerator of the first
Dialogue: 0,0:07:02.56,0:07:04.39,BottomCenter,,0,0,0,,by the denominator of the second
Dialogue: 0,0:07:04.67,0:07:06.87,BottomCenter,,0,0,0,,add that through the numerator of the second
Dialogue: 0,0:07:06.89,0:07:08.87,BottomCenter,,0,0,0,,time is the denominator of the first
Dialogue: 0,0:07:09.19,0:07:10.50,BottomCenter,,0,0,0,,and that's our new numerator
Dialogue: 0,0:07:10.50,0:07:12.30,BottomCenter,,0,0,0,,and our new denominator is the product
Dialogue: 0,0:07:12.30,0:07:13.47,BottomCenter,,0,0,0,,of the denominators
Dialogue: 0,0:07:13.47,0:07:15.76,BottomCenter,,0,0,0,,of the first and 2nd rational number
Dialogue: 0,0:07:15.76,0:07:16.97,BottomCenter,,0,0,0,,that we're adding together
Dialogue: 0,0:07:17.87,0:07:20.10,BottomCenter,,0,0,0,,so now we have formulas for how to multiply
Dialogue: 0,0:07:20.19,0:07:21.89,BottomCenter,,0,0,0,,and add rational numbers
Dialogue: 0,0:07:22.39,0:07:24.12,BottomCenter,,0,0,0,,how do we write code that does that
Dialogue: 0,0:07:24.30,0:07:25.39,BottomCenter,,0,0,0,,we will write it
Dialogue: 0,0:07:25.52,0:07:29.06,BottomCenter,,0,0,0,,in terms of our constructor and selectors
Dialogue: 0,0:07:29.80,0:07:32.39,BottomCenter,,0,0,0,,so here's a function which multiplies together
Dialogue: 0,0:07:32.52,0:07:34.60,BottomCenter,,0,0,0,,two rational numbers x and y
Dialogue: 0,0:07:34.97,0:07:36.76,BottomCenter,,0,0,0,,it returns a new rational number
Dialogue: 0,0:07:37.50,0:07:38.19,BottomCenter,,0,0,0,,the numerator
Dialogue: 0,0:07:38.19,0:07:39.37,BottomCenter,,0,0,0,,of which is the product of
Dialogue: 0,0:07:39.37,0:07:41.00,BottomCenter,,0,0,0,,the numerators of the inputs
Dialogue: 0,0:07:41.00,0:07:44.17,BottomCenter,,0,0,0,,and the denominator is the product of the denominators
Dialogue: 0,0:07:44.17,0:07:45.32,BottomCenter,,0,0,0,,of the inputs
Dialogue: 0,0:07:45.37,0:07:47.10,BottomCenter,,0,0,0,,just like our formula says
Dialogue: 0,0:07:48.76,0:07:50.19,BottomCenter,,0,0,0,,we see that we've used the constructor
Dialogue: 0,0:07:50.19,0:07:51.76,BottomCenter,,0,0,0,,to create a new rational number
Dialogue: 0,0:07:51.76,0:07:55.32,BottomCenter,,0,0,0,,and we've used the selectors to select out the parts
Dialogue: 0,0:07:55.32,0:07:59.10,BottomCenter,,0,0,0,,of xmy that we need in order to complete this formula
Dialogue: 0,0:08:00.56,0:08:03.00,BottomCenter,,0,0,0,,likewise we can write a function that adds together
Dialogue: 0,0:08:03.97,0:08:05.30,BottomCenter,,0,0,0,,two rational numbers
Dialogue: 0,0:08:06.76,0:08:09.32,BottomCenter,,0,0,0,,we give names to their numerator and denominator
Dialogue: 0,0:08:09.39,0:08:11.56,BottomCenter,,0,0,0,,because we use those multiple times
Dialogue: 0,0:08:12.26,0:08:13.37,BottomCenter,,0,0,0,,in our expression
Dialogue: 0,0:08:13.37,0:08:14.97,BottomCenter,,0,0,0,,and then we return a rational
Dialogue: 0,0:08:15.26,0:08:17.32,BottomCenter,,0,0,0,,which follows the formula on the right
Dialogue: 0,0:08:18.30,0:08:19.76,BottomCenter,,0,0,0,,one more function lets us
Dialogue: 0,0:08:19.89,0:08:22.30,BottomCenter,,0,0,0,,really work with rational numbers
Dialogue: 0,0:08:22.37,0:08:25.26,BottomCenter,,0,0,0,,and that is equal rational which returns true
Dialogue: 0,0:08:25.39,0:08:27.69,BottomCenter,,0,0,0,,if x and y are the same number
Dialogue: 0,0:08:28.67,0:08:30.67,BottomCenter,,0,0,0,,now we can't just compare their parts
Dialogue: 0,0:08:30.67,0:08:33.20,BottomCenter,,0,0,0,,because one half is the same rational number as
Dialogue: 0,0:08:33.20,0:08:34.12,BottomCenter,,0,0,0,,two fourths
Dialogue: 0,0:08:34.39,0:08:37.87,BottomCenter,,0,0,0,,so in order to resolve whether x and y are equal
Dialogue: 0,0:08:37.87,0:08:39.89,BottomCenter,,0,0,0,,we multiply the numerator of the first
Dialogue: 0,0:08:39.89,0:08:41.79,BottomCenter,,0,0,0,,by the denominator of the second
Dialogue: 0,0:08:42.33,0:08:44.12,BottomCenter,,0,0,0,,and check and see if that's equal to
Dialogue: 0,0:08:44.33,0:08:45.89,BottomCenter,,0,0,0,,the numerator of the second
Dialogue: 0,0:08:45.89,0:08:47.79,BottomCenter,,0,0,0,,times the denominator of the third
Dialogue: 0,0:08:47.79,0:08:48.60,BottomCenter,,0,0,0,,first
Dialogue: 0,0:08:49.66,0:08:50.52,BottomCenter,,0,0,0,,hung twister
Dialogue: 0,0:08:51.29,0:08:53.89,BottomCenter,,0,0,0,,okay so what you see here
Dialogue: 0,0:08:54.10,0:08:55.47,BottomCenter,,0,0,0,,is that we've defined
Dialogue: 0,0:08:55.47,0:08:57.52,BottomCenter,,0,0,0,,all of the ways in which we will manipulate
Dialogue: 0,0:08:57.52,0:08:58.60,BottomCenter,,0,0,0,,rational numbers
Dialogue: 0,0:08:58.60,0:09:01.26,BottomCenter,,0,0,0,,in terms of three functions
Dialogue: 0,0:09:01.26,0:09:04.97,BottomCenter,,0,0,0,,and these functions implement an abstract data type
Dialogue: 0,0:09:05.89,0:09:07.47,BottomCenter,,0,0,0,,for rational numbers
Dialogue: 0,0:09:07.76,0:09:09.12,BottomCenter,,0,0,0,,what that means is
Dialogue: 0,0:09:09.26,0:09:12.60,BottomCenter,,0,0,0,,all of our manipulation of the numbers is written in
Dialogue: 0,0:09:12.60,0:09:14.29,BottomCenter,,0,0,0,,terms of these functions
Dialogue: 0,0:09:14.60,0:09:16.79,BottomCenter,,0,0,0,,we haven't even defined these functions yet
Dialogue: 0,0:09:17.37,0:09:20.66,BottomCenter,,0,0,0,,but since we know that these are the tools we use
Dialogue: 0,0:09:20.70,0:09:23.07,BottomCenter,,0,0,0,,to access the parts of rational numbers
Dialogue: 0,0:09:23.07,0:09:24.79,BottomCenter,,0,0,0,,or create new rational numbers
Dialogue: 0,0:09:24.87,0:09:26.87,BottomCenter,,0,0,0,,we can write functions in terms of these
Dialogue: 0,0:09:26.89,0:09:28.37,BottomCenter,,0,0,0,,and then implement them later
Dialogue: 0,0:09:31.20,0:09:36.39,BottomCenter,,0,0,0,,a pair consists of two values that are joined together
Dialogue: 0,0:09:36.47,0:09:40.92,BottomCenter,,0,0,0,,bundled together in such a way that you can treat them
Dialogue: 0,0:09:41.26,0:09:43.26,BottomCenter,,0,0,0,,as a unit as a whole
Dialogue: 0,0:09:43.39,0:09:45.29,BottomCenter,,0,0,0,,even though there are two parts
Dialogue: 0,0:09:47.70,0:09:49.89,BottomCenter,,0,0,0,,now there's lots of different ways to represent a
Dialogue: 0,0:09:49.89,0:09:51.00,BottomCenter,,0,0,0,,pair of things
Dialogue: 0,0:09:51.12,0:09:53.10,BottomCenter,,0,0,0,,but we're going to use a built in
Dialogue: 0,0:09:53.50,0:09:56.26,BottomCenter,,0,0,0,,data type first called the list
Dialogue: 0,0:09:57.57,0:09:59.29,BottomCenter,,0,0,0,,so I can write the line of code
Dialogue: 0,0:09:59.29,0:10:04.66,BottomCenter,,0,0,0,,pair equals open bracket one coma two close bracket
Dialogue: 0,0:10:05.60,0:10:09.20,BottomCenter,,0,0,0,,and what we have here is what's called a list literal
Dialogue: 0,0:10:09.60,0:10:13.89,BottomCenter,,0,0,0,,which creates a new list that contains one and two
Dialogue: 0,0:10:14.07,0:10:15.50,BottomCenter,,0,0,0,,as two values
Dialogue: 0,0:10:15.50,0:10:17.39,BottomCenter,,0,0,0,,and as we have two values in the list
Dialogue: 0,0:10:17.39,0:10:18.60,BottomCenter,,0,0,0,,we'll color the pair
Dialogue: 0,0:10:19.33,0:10:21.29,BottomCenter,,0,0,0,,and when I display this pair
Dialogue: 0,0:10:21.33,0:10:24.57,BottomCenter,,0,0,0,,I see its contents written just like the literal
Dialogue: 0,0:10:25.66,0:10:27.12,BottomCenter,,0,0,0,,so a list literal has a comma
Dialogue: 0,0:10:27.12,0:10:29.37,BottomCenter,,0,0,0,,separated expression in brackets
Dialogue: 0,0:10:29.92,0:10:31.60,BottomCenter,,0,0,0,,once I have a list
Dialogue: 0,0:10:31.76,0:10:34.10,BottomCenter,,0,0,0,,which is the value of a list literal
Dialogue: 0,0:10:34.79,0:10:38.12,BottomCenter,,0,0,0,,I can access the elements within the list
Dialogue: 0,0:10:38.52,0:10:42.66,BottomCenter,,0,0,0,,through what's called unpecking that list
Dialogue: 0,0:10:42.92,0:10:44.50,BottomCenter,,0,0,0,,into different values
Dialogue: 0,0:10:44.52,0:10:47.60,BottomCenter,,0,0,0,,so by saying x comma y equals pair
Dialogue: 0,0:10:48.52,0:10:52.37,BottomCenter,,0,0,0,,I'll bind x to the zero element and y
Dialogue: 0,0:10:52.70,0:10:54.07,BottomCenter,,0,0,0,,to the first element
Dialogue: 0,0:10:54.79,0:10:55.66,BottomCenter,,0,0,0,,after which
Dialogue: 0,0:10:55.66,0:10:59.16,BottomCenter,,0,0,0,,if I look at what x is bound to lc one and what
Dialogue: 0,0:10:59.16,0:11:01.76,BottomCenter,,0,0,0,,y is bound to lc two
Dialogue: 0,0:11:02.20,0:11:04.07,BottomCenter,,0,0,0,,that's because that's the contents
Dialogue: 0,0:11:04.07,0:11:05.66,BottomCenter,,0,0,0,,of the list that I've created
Dialogue: 0,0:11:06.70,0:11:08.92,BottomCenter,,0,0,0,,so we now have a way to bundle together
Dialogue: 0,0:11:09.20,0:11:11.76,BottomCenter,,0,0,0,,values and split them apart again
Dialogue: 0,0:11:13.10,0:11:15.26,BottomCenter,,0,0,0,,this is called unpacking a list
Dialogue: 0,0:11:16.37,0:11:18.97,BottomCenter,,0,0,0,,another way to access the elements of a list
Dialogue: 0,0:11:19.20,0:11:22.16,BottomCenter,,0,0,0,,is to the element selection operator
Dialogue: 0,0:11:22.39,0:11:24.92,BottomCenter,,0,0,0,,which again uses square brackets
Dialogue: 0,0:11:25.20,0:11:27.97,BottomCenter,,0,0,0,,so these square brackets are different from this one
Dialogue: 0,0:11:27.97,0:11:29.87,BottomCenter,,0,0,0,,although they're certainly related
Dialogue: 0,0:11:30.79,0:11:33.52,BottomCenter,,0,0,0,,but this is just square brackets without anything
Dialogue: 0,0:11:33.52,0:11:37.89,BottomCenter,,0,0,0,,before it whereas this has some expression before it
Dialogue: 0,0:11:38.52,0:11:41.76,BottomCenter,,0,0,0,,so when you have square brackets after an expression
Dialogue: 0,0:11:42.16,0:11:45.16,BottomCenter,,0,0,0,,that involves selecting an element from
Dialogue: 0,0:11:45.39,0:11:48.70,BottomCenter,,0,0,0,,the value which is to the left of the brackets
Dialogue: 0,0:11:49.47,0:11:54.07,BottomCenter,,0,0,0,,so pair is a list value and its zero th element is one
Dialogue: 0,0:11:54.16,0:11:56.60,BottomCenter,,0,0,0,,its first element is two
Dialogue: 0,0:11:57.79,0:12:00.70,BottomCenter,,0,0,0,,so element selection using the selection operator is
Dialogue: 0,0:12:00.70,0:12:04.16,BottomCenter,,0,0,0,,another way to access the elements in a list
Dialogue: 0,0:12:05.26,0:12:07.50,BottomCenter,,0,0,0,,there's also a function that does the same thing
Dialogue: 0,0:12:07.60,0:12:10.73,BottomCenter,,0,0,0,,as we've seen many times over in python
Dialogue: 0,0:12:10.89,0:12:13.12,BottomCenter,,0,0,0,,each operator has some function
Dialogue: 0,0:12:13.60,0:12:16.89,BottomCenter,,0,0,0,,most of which are within the module called operator
Dialogue: 0,0:12:17.33,0:12:20.97,BottomCenter,,0,0,0,,so the element selection operator is called get item
Dialogue: 0,0:12:21.26,0:12:22.29,BottomCenter,,0,0,0,,all one word
Dialogue: 0,0:12:22.66,0:12:25.29,BottomCenter,,0,0,0,,it's okay to say it fast because it's all one word
Dialogue: 0,0:12:25.70,0:12:27.79,BottomCenter,,0,0,0,,get item pair zero
Dialogue: 0,0:12:28.16,0:12:29.10,BottomCenter,,0,0,0,,gives me
Dialogue: 0,0:12:29.50,0:12:33.87,BottomCenter,,0,0,0,,the zero element of the pair list and that's what
Dialogue: 0,0:12:34.66,0:12:37.33,BottomCenter,,0,0,0,,get item pair one will give me the value two
Dialogue: 0,0:12:38.12,0:12:40.16,BottomCenter,,0,0,0,,this is an element selection function
Dialogue: 0,0:12:40.37,0:12:41.79,BottomCenter,,0,0,0,,or the get item function
Dialogue: 0,0:12:42.97,0:12:46.20,BottomCenter,,0,0,0,,okay we now have a basic introduction to what lists are
Dialogue: 0,0:12:46.47,0:12:48.20,BottomCenter,,0,0,0,,and so far we've used them
Dialogue: 0,0:12:48.73,0:12:51.16,BottomCenter,,0,0,0,,to create pairs
Dialogue: 0,0:12:51.76,0:12:53.20,BottomCenter,,0,0,0,,and why is that useful
Dialogue: 0,0:12:53.20,0:12:57.20,BottomCenter,,0,0,0,,well a rational number is a pair of integers
Dialogue: 0,0:12:57.29,0:12:59.39,BottomCenter,,0,0,0,,the numerator and the denominator
Dialogue: 0,0:13:00.29,0:13:03.00,BottomCenter,,0,0,0,,so here's a definition of the constructor
Dialogue: 0,0:13:03.60,0:13:07.50,BottomCenter,,0,0,0,,of the abstract data type for rational numbers
Dialogue: 0,0:13:07.70,0:13:08.73,BottomCenter,,0,0,0,,it's a function
Dialogue: 0,0:13:08.73,0:13:11.50,BottomCenter,,0,0,0,,that takes in the numerator and denominator
Dialogue: 0,0:13:12.33,0:13:12.89,BottomCenter,,0,0,0,,and we need
Dialogue: 0,0:13:12.89,0:13:15.60,BottomCenter,,0,0,0,,some way of representing of that pair of things
Dialogue: 0,0:13:15.60,0:13:16.79,BottomCenter,,0,0,0,,we'll use a list
Dialogue: 0,0:13:17.16,0:13:17.33,BottomCenter,,0,0,0,,so
Dialogue: 0,0:13:17.33,0:13:20.16,BottomCenter,,0,0,0,,we construct a rational number that represents n over d
Dialogue: 0,0:13:20.70,0:13:22.92,BottomCenter,,0,0,0,,just by returning the list of n come a d
Dialogue: 0,0:13:24.20,0:13:26.73,BottomCenter,,0,0,0,,so this constructs a list and the list
Dialogue: 0,0:13:27.29,0:13:30.16,BottomCenter,,0,0,0,,we're using as a rational number
Dialogue: 0,0:13:30.39,0:13:32.33,BottomCenter,,0,0,0,,now this can contain anything
Dialogue: 0,0:13:32.52,0:13:35.52,BottomCenter,,0,0,0,,they don't necessarily just contain integers
Dialogue: 0,0:13:35.89,0:13:38.66,BottomCenter,,0,0,0,,but we're using it to represent a rational number
Dialogue: 0,0:13:38.79,0:13:41.87,BottomCenter,,0,0,0,,in which both n amp d should be integers
Dialogue: 0,0:13:44.00,0:13:46.12,BottomCenter,,0,0,0,,now how do we get the numerator out
Dialogue: 0,0:13:46.12,0:13:48.50,BottomCenter,,0,0,0,,assuming that x is what was created
Dialogue: 0,0:13:48.52,0:13:50.20,BottomCenter,,0,0,0,,by the rational constructor
Dialogue: 0,0:13:50.57,0:13:53.87,BottomCenter,,0,0,0,,while we just access the zero of element
Dialogue: 0,0:13:54.79,0:13:58.10,BottomCenter,,0,0,0,,and that the nominator is element that index one
Dialogue: 0,0:14:00.16,0:14:02.26,BottomCenter,,0,0,0,,so we're going to select an item from a list here
Dialogue: 0,0:14:02.26,0:14:03.57,BottomCenter,,0,0,0,,in order to implement
Dialogue: 0,0:14:03.89,0:14:05.26,BottomCenter,,0,0,0,,what we want which is selecting
Dialogue: 0,0:14:05.26,0:14:07.26,BottomCenter,,0,0,0,,the denominator of a rational number
Dialogue: 0,0:14:09.00,0:14:11.70,BottomCenter,,0,0,0,,so let me show you the first example of why
Dialogue: 0,0:14:11.70,0:14:13.89,BottomCenter,,0,0,0,,data abstraction can be useful
Dialogue: 0,0:14:15.70,0:14:18.76,BottomCenter,,0,0,0,,recall that we implemented multiplication
Dialogue: 0,0:14:18.89,0:14:20.92,BottomCenter,,0,0,0,,among rational numbers
Dialogue: 0,0:14:21.10,0:14:25.20,BottomCenter,,0,0,0,,and here's an example three halves times five thirds
Dialogue: 0,0:14:26.29,0:14:27.10,BottomCenter,,0,0,0,,what do you get
Dialogue: 0,0:14:27.29,0:14:30.33,BottomCenter,,0,0,0,,well you multiply the numerators together to get 15
Dialogue: 0,0:14:30.50,0:14:33.33,BottomCenter,,0,0,0,,you multiply the denominators together to get six
Dialogue: 0,0:14:34.47,0:14:38.76,BottomCenter,,0,0,0,,and the answer is not 21th but five haves
Dialogue: 0,0:14:39.12,0:14:40.29,BottomCenter,,0,0,0,,and why is that
Dialogue: 0,0:14:40.57,0:14:42.66,BottomCenter,,0,0,0,,when we had 15 6 but
Dialogue: 0,0:14:42.87,0:14:45.60,BottomCenter,,0,0,0,,those were not relatively prime integers
Dialogue: 0,0:14:46.26,0:14:48.89,BottomCenter,,0,0,0,,we can reduce the fraction
Dialogue: 0,0:14:49.00,0:14:50.57,BottomCenter,,0,0,0,,to lowest terms
Dialogue: 0,0:14:50.57,0:14:53.66,BottomCenter,,0,0,0,,by multiplying both the numerator and the denominator
Dialogue: 0,0:14:53.66,0:14:54.89,BottomCenter,,0,0,0,,by one third
Dialogue: 0,0:14:55.29,0:14:58.97,BottomCenter,,0,0,0,,and that gives us an equivalent fraction five halves
Dialogue: 0,0:14:59.00,0:15:00.07,BottomCenter,,0,0,0,,that's simpler
Dialogue: 0,0:15:01.33,0:15:02.50,BottomCenter,,0,0,0,,now the reason
Dialogue: 0,0:15:02.50,0:15:05.47,BottomCenter,,0,0,0,,we do this is in order to keep the integers small
Dialogue: 0,0:15:05.92,0:15:08.60,BottomCenter,,0,0,0,,so that they're easier to look at and understand
Dialogue: 0,0:15:10.89,0:15:13.73,BottomCenter,,0,0,0,,what about two fists plus 11th
Dialogue: 0,0:15:14.37,0:15:17.00,BottomCenter,,0,0,0,,well we can apply the same procedure we had before
Dialogue: 0,0:15:17.00,0:15:18.29,BottomCenter,,0,0,0,,for adding together
Dialogue: 0,0:15:18.73,0:15:19.97,BottomCenter,,0,0,0,,rational numbers
Dialogue: 0,0:15:21.73,0:15:23.60,BottomCenter,,0,0,0,,and we'll get one half
Dialogue: 0,0:15:24.20,0:15:25.79,BottomCenter,,0,0,0,,now why is it one half
Dialogue: 0,0:15:26.10,0:15:29.73,BottomCenter,,0,0,0,,it's because through the cross multiplying in addition
Dialogue: 0,0:15:29.73,0:15:32.26,BottomCenter,,0,0,0,,we got twenty five over fifty
Dialogue: 0,0:15:33.39,0:15:35.97,BottomCenter,,0,0,0,,and so there's the 20 there's the five
Dialogue: 0,0:15:36.10,0:15:38.16,BottomCenter,,0,0,0,,we add those together to get twenty five
Dialogue: 0,0:15:38.26,0:15:40.00,BottomCenter,,0,0,0,,fifty is five times 10
Dialogue: 0,0:15:40.50,0:15:42.26,BottomCenter,,0,0,0,,but then we can reduce that
Dialogue: 0,0:15:42.66,0:15:43.79,BottomCenter,,0,0,0,,to lowest terms
Dialogue: 0,0:15:43.79,0:15:46.39,BottomCenter,,0,0,0,,by multiplying both the numerator and denominator
Dialogue: 0,0:15:46.39,0:15:48.50,BottomCenter,,0,0,0,,by one over twenty five
Dialogue: 0,0:15:49.33,0:15:51.33,BottomCenter,,0,0,0,,leaving us with one half
Dialogue: 0,0:15:53.60,0:15:56.16,BottomCenter,,0,0,0,,so how would we change our implementation to do that
Dialogue: 0,0:15:56.92,0:15:58.26,BottomCenter,,0,0,0,,well here's the idea
Dialogue: 0,0:15:59.12,0:16:01.29,BottomCenter,,0,0,0,,addition and multiplication
Dialogue: 0,0:16:01.52,0:16:04.07,BottomCenter,,0,0,0,,actually were correct in the first place
Dialogue: 0,0:16:04.60,0:16:05.79,BottomCenter,,0,0,0,,what was wrong
Dialogue: 0,0:16:06.16,0:16:08.92,BottomCenter,,0,0,0,,was our definition of rational
Dialogue: 0,0:16:10.07,0:16:12.07,BottomCenter,,0,0,0,,a rational number should be something that's
Dialogue: 0,0:16:12.07,0:16:13.66,BottomCenter,,0,0,0,,always represented in
Dialogue: 0,0:16:13.76,0:16:18.87,BottomCenter,,0,0,0,,lowest terms or with two relatively prime integers
Dialogue: 0,0:16:20.10,0:16:22.60,BottomCenter,,0,0,0,,so one thing I can do is import a function
Dialogue: 0,0:16:22.60,0:16:23.92,BottomCenter,,0,0,0,,that computes the greatest
Dialogue: 0,0:16:23.92,0:16:25.12,BottomCenter,,0,0,0,,common devisor
Dialogue: 0,0:16:25.39,0:16:26.52,BottomCenter,,0,0,0,,in a previous lecture
Dialogue: 0,0:16:26.52,0:16:28.87,BottomCenter,,0,0,0,,I showed you how to write a function that does this
Dialogue: 0,0:16:29.00,0:16:31.50,BottomCenter,,0,0,0,,but it also happens to be built into python
Dialogue: 0,0:16:32.89,0:16:35.00,BottomCenter,,0,0,0,,and then what I'm going to do is redefine
Dialogue: 0,0:16:35.00,0:16:36.57,BottomCenter,,0,0,0,,the rational constructor
Dialogue: 0,0:16:36.73,0:16:39.60,BottomCenter,,0,0,0,,to take any numerator in any denominator
Dialogue: 0,0:16:41.16,0:16:43.66,BottomCenter,,0,0,0,,and then constructs a rational number that represents
Dialogue: 0,0:16:43.66,0:16:46.50,BottomCenter,,0,0,0,,n over d but does it in a way
Dialogue: 0,0:16:46.76,0:16:47.57,BottomCenter,,0,0,0,,such that
Dialogue: 0,0:16:47.57,0:16:50.50,BottomCenter,,0,0,0,,the numerator and denominator that are accessed later
Dialogue: 0,0:16:50.57,0:16:52.87,BottomCenter,,0,0,0,,are always relatively prime
Dialogue: 0,0:16:53.73,0:16:55.39,BottomCenter,,0,0,0,,which you can achieve
Dialogue: 0,0:16:55.39,0:16:58.00,BottomCenter,,0,0,0,,by computing the greatest common devisor
Dialogue: 0,0:16:58.00,0:17:00.26,BottomCenter,,0,0,0,,of both the numerator and the denominator
Dialogue: 0,0:17:00.66,0:17:04.26,BottomCenter,,0,0,0,,that's three in this case or 25 in this case
Dialogue: 0,0:17:05.09,0:17:07.52,BottomCenter,,0,0,0,,and then returning a pair
Dialogue: 0,0:17:07.93,0:17:09.29,BottomCenter,,0,0,0,,that contains
Dialogue: 0,0:17:09.56,0:17:11.40,BottomCenter,,0,0,0,,the numerator and denominator
Dialogue: 0,0:17:11.56,0:17:15.09,BottomCenter,,0,0,0,,each divided by the greatest comment devisor
Dialogue: 0,0:17:15.17,0:17:17.86,BottomCenter,,0,0,0,,so that they're guaranteed to be relatively prime
Dialogue: 0,0:17:18.47,0:17:21.17,BottomCenter,,0,0,0,,and we use integer division here because we know
Dialogue: 0,0:17:21.52,0:17:24.29,BottomCenter,,0,0,0,,that g evenly divides both n and d
Dialogue: 0,0:17:24.29,0:17:26.47,BottomCenter,,0,0,0,,that's the property of a greatest common devisor
Dialogue: 0,0:17:26.47,0:17:27.32,BottomCenter,,0,0,0,,is it's the devizer
Dialogue: 0,0:17:27.32,0:17:30.26,BottomCenter,,0,0,0,,it evenly divides those numbers
Dialogue: 0,0:17:31.13,0:17:33.79,BottomCenter,,0,0,0,,okay so we computed the greatest common devisor
Dialogue: 0,0:17:34.00,0:17:36.97,BottomCenter,,0,0,0,,we changed the constructor
Dialogue: 0,0:17:37.70,0:17:41.59,BottomCenter,,0,0,0,,we don't have to make any changes to add rational or mo
Dialogue: 0,0:17:41.59,0:17:44.17,BottomCenter,,0,0,0,,rational or print or anything like that
Dialogue: 0,0:17:44.29,0:17:47.90,BottomCenter,,0,0,0,,because we've been using data abstraction
Dialogue: 0,0:17:48.56,0:17:50.20,BottomCenter,,0,0,0,,which means that everything
Dialogue: 0,0:17:50.20,0:17:52.93,BottomCenter,,0,0,0,,was defined in terms of this constructor
Dialogue: 0,0:17:53.17,0:17:54.93,BottomCenter,,0,0,0,,so changing this constructor
Dialogue: 0,0:17:55.29,0:17:58.73,BottomCenter,,0,0,0,,changes the behavior of all the other functions as well
Dialogue: 0,0:17:58.90,0:18:00.13,BottomCenter,,0,0,0,,and that's a good thing
Dialogue: 0,0:18:03.17,0:18:05.20,BottomCenter,,0,0,0,,abstraction barriers
Dialogue: 0,0:18:05.56,0:18:08.40,BottomCenter,,0,0,0,,separate different parts of a program
Dialogue: 0,0:18:08.97,0:18:12.09,BottomCenter,,0,0,0,,so that each part only needs to know so much
Dialogue: 0,0:18:12.40,0:18:13.97,BottomCenter,,0,0,0,,about the rest of the program
Dialogue: 0,0:18:15.29,0:18:16.93,BottomCenter,,0,0,0,,now these separations are
Dialogue: 0,0:18:16.93,0:18:17.79,BottomCenter,,0,0,0,,important because
Dialogue: 0,0:18:17.79,0:18:19.56,BottomCenter,,0,0,0,,they allow you to make changes
Dialogue: 0,0:18:19.56,0:18:21.17,BottomCenter,,0,0,0,,to one part of your program
Dialogue: 0,0:18:21.59,0:18:25.13,BottomCenter,,0,0,0,,and have other parts take advantage of those changes
Dialogue: 0,0:18:25.26,0:18:27.52,BottomCenter,,0,0,0,,without breaking in any way
Dialogue: 0,0:18:27.52,0:18:29.70,BottomCenter,,0,0,0,,or creating in consistencies
Dialogue: 0,0:18:31.36,0:18:33.97,BottomCenter,,0,0,0,,so let's talk about the abstraction barriers
Dialogue: 0,0:18:34.29,0:18:37.52,BottomCenter,,0,0,0,,in the development of a rational arithmetic system
Dialogue: 0,0:18:37.52,0:18:40.59,BottomCenter,,0,0,0,,that we've been working on for this lecture
Dialogue: 0,0:18:42.17,0:18:44.06,BottomCenter,,0,0,0,,so there's a part of the program
Dialogue: 0,0:18:44.17,0:18:47.79,BottomCenter,,0,0,0,,that uses rational numbers to perform computation
Dialogue: 0,0:18:48.29,0:18:49.50,BottomCenter,,0,0,0,,so I actually want to know
Dialogue: 0,0:18:49.50,0:18:51.76,BottomCenter,,0,0,0,,what's one half times one third
Dialogue: 0,0:18:52.56,0:18:53.70,BottomCenter,,0,0,0,,in those cases
Dialogue: 0,0:18:53.70,0:18:57.13,BottomCenter,,0,0,0,,we're actually treating rationals as whole data values
Dialogue: 0,0:18:57.26,0:18:59.17,BottomCenter,,0,0,0,,they just represent some number
Dialogue: 0,0:18:59.47,0:19:00.93,BottomCenter,,0,0,0,,we don't care how
Dialogue: 0,0:19:01.50,0:19:02.70,BottomCenter,,0,0,0,,we just want to know
Dialogue: 0,0:19:02.70,0:19:04.36,BottomCenter,,0,0,0,,what it happens when you multiply
Dialogue: 0,0:19:04.36,0:19:05.47,BottomCenter,,0,0,0,,these things together
Dialogue: 0,0:19:06.67,0:19:08.09,BottomCenter,,0,0,0,,and in order to do that
Dialogue: 0,0:19:08.26,0:19:10.93,BottomCenter,,0,0,0,,we use certain functions that are part
Dialogue: 0,0:19:10.93,0:19:12.52,BottomCenter,,0,0,0,,of the data abstraction
Dialogue: 0,0:19:13.06,0:19:14.86,BottomCenter,,0,0,0,,for rational numbers
Dialogue: 0,0:19:14.93,0:19:18.56,BottomCenter,,0,0,0,,add rational mole rational rationals are equal etc
Dialogue: 0,0:19:18.93,0:19:20.32,BottomCenter,,0,0,0,,are all things that take in
Dialogue: 0,0:19:20.32,0:19:22.09,BottomCenter,,0,0,0,,rational numbers and do things with them
Dialogue: 0,0:19:22.09,0:19:23.67,BottomCenter,,0,0,0,,perhaps returning new ones
Dialogue: 0,0:19:24.32,0:19:25.97,BottomCenter,,0,0,0,,but using these
Dialogue: 0,0:19:25.97,0:19:28.29,BottomCenter,,0,0,0,,functions doesn't mean you need to know much at all
Dialogue: 0,0:19:28.67,0:19:31.40,BottomCenter,,0,0,0,,about how rational numbers are represented
Dialogue: 0,0:19:33.36,0:19:35.26,BottomCenter,,0,0,0,,in a next layer down
Dialogue: 0,0:19:35.73,0:19:38.26,BottomCenter,,0,0,0,,where we look at the implementation
Dialogue: 0,0:19:38.47,0:19:40.29,BottomCenter,,0,0,0,,instead of just the use
Dialogue: 0,0:19:40.97,0:19:43.40,BottomCenter,,0,0,0,,of these arithmetic operators
Dialogue: 0,0:19:44.06,0:19:47.13,BottomCenter,,0,0,0,,we find parts of the program that create rationals
Dialogue: 0,0:19:47.29,0:19:49.73,BottomCenter,,0,0,0,,or implement rational operations
Dialogue: 0,0:19:50.50,0:19:51.20,BottomCenter,,0,0,0,,and they treat
Dialogue: 0,0:19:51.20,0:19:54.06,BottomCenter,,0,0,0,,rationals as a numerator and a denominator
Dialogue: 0,0:19:54.29,0:19:55.32,BottomCenter,,0,0,0,,paired together
Dialogue: 0,0:19:56.36,0:19:57.00,BottomCenter,,0,0,0,,now they may
Dialogue: 0,0:19:57.00,0:20:00.52,BottomCenter,,0,0,0,,not need to know exactly how that pairing happens
Dialogue: 0,0:20:00.86,0:20:03.56,BottomCenter,,0,0,0,,but they do need to know that a rational number
Dialogue: 0,0:20:03.56,0:20:05.59,BottomCenter,,0,0,0,,has a numerator and a denominator
Dialogue: 0,0:20:05.76,0:20:07.59,BottomCenter,,0,0,0,,these two things can be selected
Dialogue: 0,0:20:08.09,0:20:08.97,BottomCenter,,0,0,0,,and they need to know that
Dialogue: 0,0:20:08.97,0:20:10.76,BottomCenter,,0,0,0,,you create a new rational number
Dialogue: 0,0:20:10.93,0:20:14.00,BottomCenter,,0,0,0,,by combining a numerator and a denominator together
Dialogue: 0,0:20:16.79,0:20:17.79,BottomCenter,,0,0,0,,and these all happened
Dialogue: 0,0:20:17.79,0:20:19.79,BottomCenter,,0,0,0,,using the functions called rational
Dialogue: 0,0:20:20.06,0:20:21.52,BottomCenter,,0,0,0,,numer and dina
Dialogue: 0,0:20:23.36,0:20:26.20,BottomCenter,,0,0,0,,so I had drew a really thick line right there
Dialogue: 0,0:20:26.36,0:20:29.09,BottomCenter,,0,0,0,,to represent an abstraction barrier
Dialogue: 0,0:20:30.13,0:20:32.67,BottomCenter,,0,0,0,,that barrier says anything
Dialogue: 0,0:20:32.67,0:20:35.70,BottomCenter,,0,0,0,,that's using rational numbers to perform computation
Dialogue: 0,0:20:36.06,0:20:39.59,BottomCenter,,0,0,0,,should only do it in terms of these functions
Dialogue: 0,0:20:39.76,0:20:43.86,BottomCenter,,0,0,0,,and should not be using functions of a different layer
Dialogue: 0,0:20:45.93,0:20:48.29,BottomCenter,,0,0,0,,in this way the programs that we write
Dialogue: 0,0:20:48.52,0:20:50.93,BottomCenter,,0,0,0,,make as few assumptions as possible
Dialogue: 0,0:20:50.93,0:20:53.86,BottomCenter,,0,0,0,,about exactly what representations were using
Dialogue: 0,0:20:54.06,0:20:58.20,BottomCenter,,0,0,0,,and instead obey the abstraction that has been set out
Dialogue: 0,0:20:58.50,0:20:59.86,BottomCenter,,0,0,0,,by the programmer
Dialogue: 0,0:21:01.59,0:21:04.06,BottomCenter,,0,0,0,,so what if we go one layer down from that
Dialogue: 0,0:21:04.70,0:21:06.40,BottomCenter,,0,0,0,,well there are parts of the program
Dialogue: 0,0:21:06.47,0:21:09.90,BottomCenter,,0,0,0,,that implement selectors and constructors for rationals
Dialogue: 0,0:21:10.52,0:21:14.20,BottomCenter,,0,0,0,,and those implementations of rational numer and dinam
Dialogue: 0,0:21:15.26,0:21:18.79,BottomCenter,,0,0,0,,treat rational numbers as two element lists
Dialogue: 0,0:21:19.70,0:21:20.97,BottomCenter,,0,0,0,,so they do
Dialogue: 0,0:21:21.06,0:21:22.50,BottomCenter,,0,0,0,,understand their whole data values
Dialogue: 0,0:21:22.50,0:21:25.32,BottomCenter,,0,0,0,,that they're consisting of numerators and denominators
Dialogue: 0,0:21:25.32,0:21:27.36,BottomCenter,,0,0,0,,and then we have a further detail
Dialogue: 0,0:21:27.86,0:21:29.70,BottomCenter,,0,0,0,,that the numerator and denominator
Dialogue: 0,0:21:29.73,0:21:32.13,BottomCenter,,0,0,0,,are glued together using a list
Dialogue: 0,0:21:34.20,0:21:37.09,BottomCenter,,0,0,0,,so for this we use list literals and element selection
Dialogue: 0,0:21:37.97,0:21:40.67,BottomCenter,,0,0,0,,and again there's an abstraction barrier
Dialogue: 0,0:21:41.56,0:21:42.59,BottomCenter,,0,0,0,,if we're in the business of
Dialogue: 0,0:21:42.59,0:21:45.76,BottomCenter,,0,0,0,,creating rationals or implementing rational operations
Dialogue: 0,0:21:45.79,0:21:47.32,BottomCenter,,0,0,0,,we shouldn't need to know
Dialogue: 0,0:21:47.56,0:21:49.70,BottomCenter,,0,0,0,,that we're using lists under the hood
Dialogue: 0,0:21:49.93,0:21:53.20,BottomCenter,,0,0,0,,and we shouldn't cross this abstraction barrier
Dialogue: 0,0:21:53.26,0:21:56.70,BottomCenter,,0,0,0,,and use a list literal or element selection directly
Dialogue: 0,0:21:57.13,0:21:57.97,BottomCenter,,0,0,0,,instead
Dialogue: 0,0:21:58.13,0:22:00.76,BottomCenter,,0,0,0,,if we write our programs in terms of just rational
Dialogue: 0,0:22:00.76,0:22:01.97,BottomCenter,,0,0,0,,numer and dinom
Dialogue: 0,0:22:02.26,0:22:04.40,BottomCenter,,0,0,0,,then changes to those functions later
Dialogue: 0,0:22:04.50,0:22:07.00,BottomCenter,,0,0,0,,we'll be propagated throughout our program
Dialogue: 0,0:22:07.20,0:22:08.59,BottomCenter,,0,0,0,,and we could for instance
Dialogue: 0,0:22:08.73,0:22:12.09,BottomCenter,,0,0,0,,start expressing every fraction in lowest terms
Dialogue: 0,0:22:13.36,0:22:14.36,BottomCenter,,0,0,0,,now is that it
Dialogue: 0,0:22:14.56,0:22:15.20,BottomCenter,,0,0,0,,well actually
Dialogue: 0,0:22:15.20,0:22:17.93,BottomCenter,,0,0,0,,there are many layers of abstraction in a program
Dialogue: 0,0:22:18.36,0:22:20.06,BottomCenter,,0,0,0,,and there is stuff that's even
Dialogue: 0,0:22:20.06,0:22:22.47,BottomCenter,,0,0,0,,lower detail than what we've seen so far
Dialogue: 0,0:22:23.32,0:22:26.90,BottomCenter,,0,0,0,,so this are somehow implemented in the python language
Dialogue: 0,0:22:27.70,0:22:29.47,BottomCenter,,0,0,0,,we don't really need to know exactly
Dialogue: 0,0:22:29.47,0:22:31.50,BottomCenter,,0,0,0,,how that implementation works
Dialogue: 0,0:22:31.50,0:22:33.76,BottomCenter,,0,0,0,,all we need to know is that this can be created
Dialogue: 0,0:22:33.76,0:22:35.00,BottomCenter,,0,0,0,,with list literals
Dialogue: 0,0:22:35.13,0:22:37.70,BottomCenter,,0,0,0,,and taken apart using element selection
Dialogue: 0,0:22:38.67,0:22:39.90,BottomCenter,,0,0,0,,and so any place
Dialogue: 0,0:22:39.90,0:22:42.29,BottomCenter,,0,0,0,,where we are implementing selectors and constructors
Dialogue: 0,0:22:42.29,0:22:43.40,BottomCenter,,0,0,0,,for rationals
Dialogue: 0,0:22:43.50,0:22:46.17,BottomCenter,,0,0,0,,shouldn't worry about the implementation of lists
Dialogue: 0,0:22:46.17,0:22:48.73,BottomCenter,,0,0,0,,it should just know that list can be created
Dialogue: 0,0:22:49.09,0:22:50.52,BottomCenter,,0,0,0,,and selected from
Dialogue: 0,0:22:51.59,0:22:54.13,BottomCenter,,0,0,0,,so each big line is an abstraction barrier
Dialogue: 0,0:22:54.29,0:22:55.86,BottomCenter,,0,0,0,,and you should know that when you're writing
Dialogue: 0,0:22:55.86,0:22:57.50,BottomCenter,,0,0,0,,one part of a large program
Dialogue: 0,0:22:57.90,0:23:00.70,BottomCenter,,0,0,0,,that it should use the level abstraction
Dialogue: 0,0:23:00.86,0:23:03.17,BottomCenter,,0,0,0,,appropriate to what you're trying to do
Dialogue: 0,0:23:03.59,0:23:05.00,BottomCenter,,0,0,0,,and the higher you stay up
Dialogue: 0,0:23:05.32,0:23:07.56,BottomCenter,,0,0,0,,without crossing of these boundaries
Dialogue: 0,0:23:07.79,0:23:10.26,BottomCenter,,0,0,0,,the easier it will be to change your program
Dialogue: 0,0:23:10.26,0:23:11.32,BottomCenter,,0,0,0,,in the future
Dialogue: 0,0:23:13.17,0:23:14.93,BottomCenter,,0,0,0,,so let's look at an example
Dialogue: 0,0:23:15.17,0:23:17.73,BottomCenter,,0,0,0,,of violating abstraction barriers
Dialogue: 0,0:23:18.26,0:23:22.06,BottomCenter,,0,0,0,,so I've said add rational one two and one four
Dialogue: 0,0:23:22.17,0:23:24.79,BottomCenter,,0,0,0,,so a half plus a four should give me three force
Dialogue: 0,0:23:24.90,0:23:26.29,BottomCenter,,0,0,0,,and under the code we've written
Dialogue: 0,0:23:26.29,0:23:27.67,BottomCenter,,0,0,0,,this will work just fine
Dialogue: 0,0:23:28.40,0:23:30.93,BottomCenter,,0,0,0,,I have a definition of dividing a rational
Dialogue: 0,0:23:31.29,0:23:33.32,BottomCenter,,0,0,0,,which returns a list
Dialogue: 0,0:23:33.52,0:23:34.76,BottomCenter,,0,0,0,,of whatever is the zero
Dialogue: 0,0:23:34.76,0:23:37.29,BottomCenter,,0,0,0,,element of x times the first element of y
Dialogue: 0,0:23:37.79,0:23:40.06,BottomCenter,,0,0,0,,and then we have the first element of x
Dialogue: 0,0:23:40.06,0:23:41.40,BottomCenter,,0,0,0,,and the zero element of y
Dialogue: 0,0:23:42.06,0:23:45.56,BottomCenter,,0,0,0,,again in our current implementation this will work
Dialogue: 0,0:23:45.56,0:23:47.76,BottomCenter,,0,0,0,,no errors will be raised
Dialogue: 0,0:23:48.47,0:23:51.93,BottomCenter,,0,0,0,,and yet we've done something terribly wrong
Dialogue: 0,0:23:52.56,0:23:55.00,BottomCenter,,0,0,0,,we violated abstraction barriers
Dialogue: 0,0:23:55.97,0:23:57.36,BottomCenter,,0,0,0,,so for instance here
Dialogue: 0,0:23:58.13,0:24:02.20,BottomCenter,,0,0,0,,we've assumed in our use of ad rational
Dialogue: 0,0:24:02.56,0:24:05.56,BottomCenter,,0,0,0,,that a rational is represented as a list of
Dialogue: 0,0:24:05.56,0:24:06.67,BottomCenter,,0,0,0,,two integers
Dialogue: 0,0:24:07.93,0:24:09.70,BottomCenter,,0,0,0,,which means if we went and changed
Dialogue: 0,0:24:09.70,0:24:10.97,BottomCenter,,0,0,0,,the rational constructor
Dialogue: 0,0:24:10.97,0:24:13.20,BottomCenter,,0,0,0,,it wouldn't be used in this block of coat
Dialogue: 0,0:24:13.26,0:24:15.47,BottomCenter,,0,0,0,,because I didn't actually call rational here
Dialogue: 0,0:24:15.47,0:24:17.29,BottomCenter,,0,0,0,,so I did not use constructors
Dialogue: 0,0:24:18.32,0:24:19.56,BottomCenter,,0,0,0,,is that so bad
Dialogue: 0,0:24:19.73,0:24:22.00,BottomCenter,,0,0,0,,well it's pretty bad
Dialogue: 0,0:24:22.26,0:24:24.86,BottomCenter,,0,0,0,,but it gets really bad when you see that it happened
Dialogue: 0,0:24:24.86,0:24:26.13,BottomCenter,,0,0,0,,twice in a row
Dialogue: 0,0:24:26.47,0:24:28.73,BottomCenter,,0,0,0,,okay now I'm getting angry
Dialogue: 0,0:24:28.86,0:24:30.56,BottomCenter,,0,0,0,,that's unacceptable that you would
Dialogue: 0,0:24:30.56,0:24:32.26,BottomCenter,,0,0,0,,just violate abstraction
Dialogue: 0,0:24:32.26,0:24:33.52,BottomCenter,,0,0,0,,barriers like that
Dialogue: 0,0:24:34.52,0:24:35.73,BottomCenter,,0,0,0,,I hope we're done
Dialogue: 0,0:24:36.32,0:24:40.59,BottomCenter,,0,0,0,,oh oh down here we're dividing rational numbers
Dialogue: 0,0:24:40.73,0:24:41.26,BottomCenter,,0,0,0,,which should
Dialogue: 0,0:24:41.26,0:24:44.26,BottomCenter,,0,0,0,,treat rationals as numerators and denominators
Dialogue: 0,0:24:44.26,0:24:47.36,BottomCenter,,0,0,0,,but not necessarily assume that their lists
Dialogue: 0,0:24:47.73,0:24:49.29,BottomCenter,,0,0,0,,so instead of using the
Dialogue: 0,0:24:49.73,0:24:51.73,BottomCenter,,0,0,0,,numer selector function
Dialogue: 0,0:24:52.13,0:24:53.47,BottomCenter,,0,0,0,,instead I've used
Dialogue: 0,0:24:53.70,0:24:56.50,BottomCenter,,0,0,0,,the element selection that works for lists
Dialogue: 0,0:24:57.00,0:24:59.86,BottomCenter,,0,0,0,,thereby assuming that x is a list
Dialogue: 0,0:25:00.06,0:25:01.06,BottomCenter,,0,0,0,,instead of saying oh
Dialogue: 0,0:25:01.06,0:25:03.67,BottomCenter,,0,0,0,,it's something that has a numerator in a denominator
Dialogue: 0,0:25:03.73,0:25:06.09,BottomCenter,,0,0,0,,but I don't know exactly what it is
Dialogue: 0,0:25:07.06,0:25:07.86,BottomCenter,,0,0,0,,so
Dialogue: 0,0:25:07.86,0:25:10.79,BottomCenter,,0,0,0,,I've gone down to too low of the level
Dialogue: 0,0:25:12.29,0:25:13.26,BottomCenter,,0,0,0,,and oh look
Dialogue: 0,0:25:13.76,0:25:15.29,BottomCenter,,0,0,0,,I did that four times
Dialogue: 0,0:25:15.29,0:25:18.36,BottomCenter,,0,0,0,,and then I returned a rational number
Dialogue: 0,0:25:18.67,0:25:19.59,BottomCenter,,0,0,0,,but again
Dialogue: 0,0:25:19.76,0:25:23.32,BottomCenter,,0,0,0,,I did not use the constructor called rational to do it
Dialogue: 0,0:25:24.09,0:25:25.50,BottomCenter,,0,0,0,,this is not okay
Dialogue: 0,0:25:26.17,0:25:27.26,BottomCenter,,0,0,0,,this you know
Dialogue: 0,0:25:27.26,0:25:31.26,BottomCenter,,0,0,0,,if I saw somebody's computer with this code on it
Dialogue: 0,0:25:31.47,0:25:34.32,BottomCenter,,0,0,0,,I think I would honestly just light it on fire
Dialogue: 0,0:25:34.97,0:25:36.93,BottomCenter,,0,0,0,,and just watch it burn
Dialogue: 0,0:25:37.26,0:25:37.90,BottomCenter,,0,0,0,,because
Dialogue: 0,0:25:37.90,0:25:41.70,BottomCenter,,0,0,0,,code that violates obstruction barriers should burn
Dialogue: 0,0:25:45.29,0:25:48.90,BottomCenter,,0,0,0,,the purpose of maintaining abstraction barriers
Dialogue: 0,0:25:49.17,0:25:52.67,BottomCenter,,0,0,0,,is so that you can change your data representation
Dialogue: 0,0:25:52.70,0:25:55.90,BottomCenter,,0,0,0,,without having to rewrite your entire program
Dialogue: 0,0:25:58.47,0:26:00.47,BottomCenter,,0,0,0,,let's poke a little bit deeper
Dialogue: 0,0:26:00.47,0:26:03.32,BottomCenter,,0,0,0,,into this idea of data representation
Dialogue: 0,0:26:03.93,0:26:05.00,BottomCenter,,0,0,0,,what does data
Dialogue: 0,0:26:05.29,0:26:05.97,BottomCenter,,0,0,0,,what does it mean
Dialogue: 0,0:26:05.97,0:26:08.40,BottomCenter,,0,0,0,,for something to represent a rational number
Dialogue: 0,0:26:09.56,0:26:10.70,BottomCenter,,0,0,0,,well we need to guarantee
Dialogue: 0,0:26:10.70,0:26:13.20,BottomCenter,,0,0,0,,that the constructor and selector functions
Dialogue: 0,0:26:13.20,0:26:14.29,BottomCenter,,0,0,0,,work together
Dialogue: 0,0:26:14.59,0:26:16.97,BottomCenter,,0,0,0,,to specify the right behavior
Dialogue: 0,0:26:17.86,0:26:21.20,BottomCenter,,0,0,0,,you don't have a representation of a rational number
Dialogue: 0,0:26:21.40,0:26:23.73,BottomCenter,,0,0,0,,unless it behaves like a rational number
Dialogue: 0,0:26:25.50,0:26:28.40,BottomCenter,,0,0,0,,a behavior condition would read something like
Dialogue: 0,0:26:28.70,0:26:30.93,BottomCenter,,0,0,0,,if we construct rational number x
Dialogue: 0,0:26:30.93,0:26:33.20,BottomCenter,,0,0,0,,from numerator n and denominator d
Dialogue: 0,0:26:33.70,0:26:36.47,BottomCenter,,0,0,0,,then it should be the case that numer x divided by
Dialogue: 0,0:26:36.97,0:26:40.36,BottomCenter,,0,0,0,,nom x equals n divided by d
Dialogue: 0,0:26:42.36,0:26:45.50,BottomCenter,,0,0,0,,here we relate the constructor called on nnnd
Dialogue: 0,0:26:45.90,0:26:48.97,BottomCenter,,0,0,0,,to the selectors and an operation between them
Dialogue: 0,0:26:51.32,0:26:53.29,BottomCenter,,0,0,0,,data abstraction uses selectors and
Dialogue: 0,0:26:53.47,0:26:55.59,BottomCenter,,0,0,0,,constructors to define behavior
Dialogue: 0,0:26:55.73,0:26:58.29,BottomCenter,,0,0,0,,that's the whole idea of data abstraction
Dialogue: 0,0:26:59.29,0:27:01.32,BottomCenter,,0,0,0,,if the behavior conditions are met
Dialogue: 0,0:27:01.47,0:27:03.90,BottomCenter,,0,0,0,,then the representation is valid
Dialogue: 0,0:27:06.06,0:27:08.13,BottomCenter,,0,0,0,,so the key underlying idea
Dialogue: 0,0:27:08.52,0:27:11.93,BottomCenter,,0,0,0,,related to data abstraction is that you can recognize
Dialogue: 0,0:27:11.97,0:27:13.86,BottomCenter,,0,0,0,,what sort of data something is
Dialogue: 0,0:27:14.00,0:27:15.59,BottomCenter,,0,0,0,,by its behavior
Dialogue: 0,0:27:15.90,0:27:17.36,BottomCenter,,0,0,0,,not necessarily
Dialogue: 0,0:27:17.36,0:27:20.40,BottomCenter,,0,0,0,,by how you constructed it or how you implemented
Dialogue: 0,0:27:20.47,0:27:22.79,BottomCenter,,0,0,0,,the constructor and selectors
Dialogue: 0,0:27:24.90,0:27:26.73,BottomCenter,,0,0,0,,so let's look back at our example
Dialogue: 0,0:27:27.52,0:27:29.13,BottomCenter,,0,0,0,,we have add mull
Dialogue: 0,0:27:29.26,0:27:30.70,BottomCenter,,0,0,0,,on an equality measurement
Dialogue: 0,0:27:30.70,0:27:32.76,BottomCenter,,0,0,0,,and a way of printing rational numbers
Dialogue: 0,0:27:32.90,0:27:35.36,BottomCenter,,0,0,0,,all of this doesn't assume anything
Dialogue: 0,0:27:35.40,0:27:37.09,BottomCenter,,0,0,0,,about the representation itself
Dialogue: 0,0:27:37.29,0:27:40.59,BottomCenter,,0,0,0,,only that the constructor and selectors exist
Dialogue: 0,0:27:41.93,0:27:43.79,BottomCenter,,0,0,0,,the constructor and selectors
Dialogue: 0,0:27:43.86,0:27:46.00,BottomCenter,,0,0,0,,below this abstraction barrier
Dialogue: 0,0:27:46.56,0:27:49.76,BottomCenter,,0,0,0,,are implementing rational numbers in terms of lists
Dialogue: 0,0:27:51.79,0:27:54.36,BottomCenter,,0,0,0,,so it's the case that I can say x and y
Dialogue: 0,0:27:55.00,0:27:57.90,BottomCenter,,0,0,0,,are the rational number one two
Dialogue: 0,0:27:58.00,0:28:01.59,BottomCenter,,0,0,0,,and the rational No.3 eighths
Dialogue: 0,0:28:03.50,0:28:05.73,BottomCenter,,0,0,0,,I should say one half and three eights
Dialogue: 0,0:28:06.32,0:28:08.20,BottomCenter,,0,0,0,,so what happens when I print
Dialogue: 0,0:28:08.36,0:28:11.97,BottomCenter,,0,0,0,,the result of multiplying together x and y
Dialogue: 0,0:28:12.52,0:28:14.40,BottomCenter,,0,0,0,,I got three over sixteen
Dialogue: 0,0:28:15.17,0:28:16.59,BottomCenter,,0,0,0,,it should be the case that I can
Dialogue: 0,0:28:16.59,0:28:18.32,BottomCenter,,0,0,0,,change my representation
Dialogue: 0,0:28:18.59,0:28:20.67,BottomCenter,,0,0,0,,and all of this will still work
Dialogue: 0,0:28:22.90,0:28:23.86,BottomCenter,,0,0,0,,so here we go
Dialogue: 0,0:28:24.47,0:28:27.97,BottomCenter,,0,0,0,,instead of using a list to couple together n and d
Dialogue: 0,0:28:28.32,0:28:29.36,BottomCenter,,0,0,0,,into one thing
Dialogue: 0,0:28:29.56,0:28:30.93,BottomCenter,,0,0,0,,we're going to use a function
Dialogue: 0,0:28:35.06,0:28:37.26,BottomCenter,,0,0,0,,we're going to find a function called select
Dialogue: 0,0:28:37.97,0:28:39.26,BottomCenter,,0,0,0,,which takes in
Dialogue: 0,0:28:40.56,0:28:41.52,BottomCenter,,0,0,0,,some name
Dialogue: 0,0:28:42.76,0:28:45.00,BottomCenter,,0,0,0,,if that name is n
Dialogue: 0,0:28:45.29,0:28:47.50,BottomCenter,,0,0,0,,then it's going to return the numerator
Dialogue: 0,0:28:47.90,0:28:49.93,BottomCenter,,0,0,0,,otherwise if the name is d
Dialogue: 0,0:28:50.67,0:28:51.70,BottomCenter,,0,0,0,,it will return
Dialogue: 0,0:28:52.09,0:28:53.17,BottomCenter,,0,0,0,,the denominator
Dialogue: 0,0:28:54.13,0:28:55.13,BottomCenter,,0,0,0,,and what else
Dialogue: 0,0:28:55.26,0:28:57.47,BottomCenter,,0,0,0,,well we're not going to worry about those other cases
Dialogue: 0,0:28:57.47,0:28:59.32,BottomCenter,,0,0,0,,we'll just return the select function
Dialogue: 0,0:28:59.40,0:29:00.93,BottomCenter,,0,0,0,,from the rational function
Dialogue: 0,0:29:01.76,0:29:03.76,BottomCenter,,0,0,0,,now it must be the case that the constructor
Dialogue: 0,0:29:03.76,0:29:05.17,BottomCenter,,0,0,0,,and the selectors
Dialogue: 0,0:29:05.20,0:29:06.76,BottomCenter,,0,0,0,,are complements of each other
Dialogue: 0,0:29:07.17,0:29:08.67,BottomCenter,,0,0,0,,that when you construct something
Dialogue: 0,0:29:08.67,0:29:10.13,BottomCenter,,0,0,0,,with the rational constructor
Dialogue: 0,0:29:10.13,0:29:12.17,BottomCenter,,0,0,0,,you can then select its numerator
Dialogue: 0,0:29:12.50,0:29:14.59,BottomCenter,,0,0,0,,using the numer function
Dialogue: 0,0:29:16.17,0:29:19.26,BottomCenter,,0,0,0,,so if x is the result of calling rational
Dialogue: 0,0:29:19.29,0:29:20.86,BottomCenter,,0,0,0,,then it's a select function
Dialogue: 0,0:29:20.90,0:29:24.50,BottomCenter,,0,0,0,,which I can call on n to get the numerator
Dialogue: 0,0:29:25.32,0:29:29.29,BottomCenter,,0,0,0,,and likewise I'd call x on d to get the denominator
Dialogue: 0,0:29:31.32,0:29:33.00,BottomCenter,,0,0,0,,let's try our example again
Dialogue: 0,0:29:34.36,0:29:37.40,BottomCenter,,0,0,0,,I set x and y to be one half and three eighths
Dialogue: 0,0:29:37.47,0:29:39.56,BottomCenter,,0,0,0,,I then printed the result of multiplying
Dialogue: 0,0:29:39.56,0:29:40.70,BottomCenter,,0,0,0,,x and y together
Dialogue: 0,0:29:40.70,0:29:42.52,BottomCenter,,0,0,0,,and I got three sixteenths
Dialogue: 0,0:29:43.00,0:29:44.50,BottomCenter,,0,0,0,,did we really change anything
Dialogue: 0,0:29:44.79,0:29:48.06,BottomCenter,,0,0,0,,well certainly we did because x is now a function
Dialogue: 0,0:29:49.29,0:29:51.52,BottomCenter,,0,0,0,,so that's a change in representation
Dialogue: 0,0:29:51.52,0:29:53.40,BottomCenter,,0,0,0,,that led to another
Dialogue: 0,0:29:53.50,0:29:56.29,BottomCenter,,0,0,0,,valid representation of rational numbers
Dialogue: 0,0:29:56.29,0:29:56.76,BottomCenter,,0,0,0,,that works
Dialogue: 0,0:29:56.76,0:29:59.47,BottomCenter,,0,0,0,,just as well with our old code as what we had before
Dialogue: 0,0:30:00.67,0:30:03.29,BottomCenter,,0,0,0,,but uses an entirely different mechanism
Dialogue: 0,0:30:03.32,0:30:06.00,BottomCenter,,0,0,0,,to keep track of the numerator and the denominator
Dialogue: 0,0:30:06.50,0:30:09.06,BottomCenter,,0,0,0,,and notice that we did this with just functions
Dialogue: 0,0:30:09.06,0:30:12.36,BottomCenter,,0,0,0,,we didn't actually need that built in list
Dialogue: 0,0:30:12.90,0:30:14.52,BottomCenter,,0,0,0,,data type at all
Dialogue: 0,0:30:17.26,0:30:20.09,BottomCenter,,0,0,0,,so what exactly happened when we implemented
Dialogue: 0,0:30:20.47,0:30:22.47,BottomCenter,,0,0,0,,rational numbers as functions
Dialogue: 0,0:30:22.67,0:30:25.76,BottomCenter,,0,0,0,,when we defined the constructor and selectors
Dialogue: 0,0:30:25.76,0:30:27.13,BottomCenter,,0,0,0,,and it was this function
Dialogue: 0,0:30:27.17,0:30:28.26,BottomCenter,,0,0,0,,the select function
Dialogue: 0,0:30:28.26,0:30:30.13,BottomCenter,,0,0,0,,that represented the rational number
Dialogue: 0,0:30:30.40,0:30:32.52,BottomCenter,,0,0,0,,it was returned by the constructor
Dialogue: 0,0:30:32.52,0:30:34.26,BottomCenter,,0,0,0,,which was a higher order function
Dialogue: 0,0:30:34.86,0:30:35.90,BottomCenter,,0,0,0,,and the selector
Dialogue: 0,0:30:35.93,0:30:38.56,BottomCenter,,0,0,0,,just called the function that resulted
Dialogue: 0,0:30:38.56,0:30:39.97,BottomCenter,,0,0,0,,from calling rational
Dialogue: 0,0:30:40.00,0:30:41.97,BottomCenter,,0,0,0,,in order to get the numerator back
Dialogue: 0,0:30:43.40,0:30:46.06,BottomCenter,,0,0,0,,by defining a function within another function
Dialogue: 0,0:30:46.17,0:30:48.73,BottomCenter,,0,0,0,,we were able to refer to the n and the d
Dialogue: 0,0:30:48.90,0:30:50.36,BottomCenter,,0,0,0,,in the enclosing scope
Dialogue: 0,0:30:50.47,0:30:52.67,BottomCenter,,0,0,0,,and so this select function that we returned
Dialogue: 0,0:30:52.73,0:30:54.73,BottomCenter,,0,0,0,,did have carrying with it
Dialogue: 0,0:30:54.93,0:30:56.59,BottomCenter,,0,0,0,,the numerator and denominator
Dialogue: 0,0:30:56.59,0:30:58.20,BottomCenter,,0,0,0,,that we wanted to access later
Dialogue: 0,0:30:58.40,0:31:00.13,BottomCenter,,0,0,0,,as part of its parent frame
Dialogue: 0,0:31:01.93,0:31:03.79,BottomCenter,,0,0,0,,so let's say a simpler example
Dialogue: 0,0:31:03.79,0:31:06.36,BottomCenter,,0,0,0,,we set x equal to rational three eighths
Dialogue: 0,0:31:06.59,0:31:09.09,BottomCenter,,0,0,0,,and then we ask for the numerator of x
Dialogue: 0,0:31:09.09,0:31:10.32,BottomCenter,,0,0,0,,which should be three
Dialogue: 0,0:31:11.13,0:31:13.29,BottomCenter,,0,0,0,,the environment diagram looks like this
Dialogue: 0,0:31:13.76,0:31:16.40,BottomCenter,,0,0,0,,rational numeran d nam are defined
Dialogue: 0,0:31:16.70,0:31:19.29,BottomCenter,,0,0,0,,and then we call rational on three and eight
Dialogue: 0,0:31:19.40,0:31:22.13,BottomCenter,,0,0,0,,which creates a select function whose parent
Dialogue: 0,0:31:22.17,0:31:23.70,BottomCenter,,0,0,0,,is the f one frame
Dialogue: 0,0:31:23.70,0:31:25.29,BottomCenter,,0,0,0,,where n and d are bound
Dialogue: 0,0:31:26.00,0:31:27.79,BottomCenter,,0,0,0,,that's returned and bound to x
Dialogue: 0,0:31:27.93,0:31:29.90,BottomCenter,,0,0,0,,x equals rational three eights
Dialogue: 0,0:31:30.32,0:31:33.17,BottomCenter,,0,0,0,,once we have x we can ask for its numerator
Dialogue: 0,0:31:33.50,0:31:35.17,BottomCenter,,0,0,0,,which creates a new frame in which
Dialogue: 0,0:31:35.17,0:31:37.26,BottomCenter,,0,0,0,,x is bound to the select function
Dialogue: 0,0:31:38.50,0:31:39.86,BottomCenter,,0,0,0,,the body of numer
Dialogue: 0,0:31:39.90,0:31:42.26,BottomCenter,,0,0,0,,says that we're supposed to call x on n
Dialogue: 0,0:31:42.26,0:31:44.26,BottomCenter,,0,0,0,,so that's exactly what happens in this
Dialogue: 0,0:31:44.36,0:31:46.20,BottomCenter,,0,0,0,,3rd frame f three
Dialogue: 0,0:31:46.86,0:31:48.40,BottomCenter,,0,0,0,,where name is bound to n
Dialogue: 0,0:31:48.50,0:31:50.79,BottomCenter,,0,0,0,,the body of select is executed
Dialogue: 0,0:31:50.93,0:31:53.09,BottomCenter,,0,0,0,,name is n and so it returns it
Dialogue: 0,0:31:53.36,0:31:56.73,BottomCenter,,0,0,0,,looking here we see that the name n is not defined
Dialogue: 0,0:31:56.79,0:31:58.90,BottomCenter,,0,0,0,,but if we look in the parent f one
Dialogue: 0,0:31:58.97,0:32:01.67,BottomCenter,,0,0,0,,n is bound to three and so that's what's returned
Dialogue: 0,0:32:05.47,0:32:08.90,BottomCenter,,0,0,0,,I've already extolled the virtues of sequences
Dialogue: 0,0:32:09.59,0:32:11.20,BottomCenter,,0,0,0,,but there are other
Dialogue: 0,0:32:11.20,0:32:13.73,BottomCenter,,0,0,0,,things fundamental to computation as well
Dialogue: 0,0:32:14.50,0:32:16.76,BottomCenter,,0,0,0,,and one of them is called a dictionary
Dialogue: 0,0:32:17.67,0:32:21.32,BottomCenter,,0,0,0,,and a dictionary allows you to associate values with
Dialogue: 0,0:32:21.36,0:32:22.29,BottomCenter,,0,0,0,,keys
Dialogue: 0,0:32:23.36,0:32:26.67,BottomCenter,,0,0,0,,so to create a dictionary you use curly braces
Dialogue: 0,0:32:27.76,0:32:31.59,BottomCenter,,0,0,0,,and what you do is you associate with some key
Dialogue: 0,0:32:32.17,0:32:33.52,BottomCenter,,0,0,0,,in this case I
Dialogue: 0,0:32:33.79,0:32:36.29,BottomCenter,,0,0,0,,a value in this case one
Dialogue: 0,0:32:36.90,0:32:40.13,BottomCenter,,0,0,0,,and by separating by commas I can associate
Dialogue: 0,0:32:40.40,0:32:41.73,BottomCenter,,0,0,0,,multiple different
Dialogue: 0,0:32:42.59,0:32:44.50,BottomCenter,,0,0,0,,values with different keys
Dialogue: 0,0:32:46.73,0:32:47.36,BottomCenter,,0,0,0,,so right here
Dialogue: 0,0:32:47.36,0:32:50.32,BottomCenter,,0,0,0,,I've described part of the roman numeral system
Dialogue: 0,0:32:51.73,0:32:53.86,BottomCenter,,0,0,0,,which is an association between
Dialogue: 0,0:32:54.29,0:32:56.36,BottomCenter,,0,0,0,,capital letters and numbers
Dialogue: 0,0:32:57.56,0:33:00.67,BottomCenter,,0,0,0,,now I evaluated this expression
Dialogue: 0,0:33:00.67,0:33:02.79,BottomCenter,,0,0,0,,it created a dictionary for me
Dialogue: 0,0:33:03.47,0:33:05.20,BottomCenter,,0,0,0,,notice something wild happened
Dialogue: 0,0:33:05.26,0:33:07.90,BottomCenter,,0,0,0,,this one looks different from this one
Dialogue: 0,0:33:08.47,0:33:09.86,BottomCenter,,0,0,0,,and there's a reason for that
Dialogue: 0,0:33:10.47,0:33:13.40,BottomCenter,,0,0,0,,dictionaries don't have an order inherently
Dialogue: 0,0:33:13.70,0:33:15.73,BottomCenter,,0,0,0,,they establish a relationship between x and x
Dialogue: 0,0:33:16.00,0:33:17.09,BottomCenter,,0,0,0,,and v and 5
Dialogue: 0,0:33:17.52,0:33:20.09,BottomCenter,,0,0,0,,but they don't establish any fixed relationship between
Dialogue: 0,0:33:20.09,0:33:21.50,BottomCenter,,0,0,0,,v and x
Dialogue: 0,0:33:21.67,0:33:22.47,BottomCenter,,0,0,0,,and so
Dialogue: 0,0:33:22.56,0:33:25.67,BottomCenter,,0,0,0,,pythons free to shuffle them around however it chooses
Dialogue: 0,0:33:27.13,0:33:29.17,BottomCenter,,0,0,0,,okay so let's call this numerals
Dialogue: 0,0:33:30.47,0:33:32.86,BottomCenter,,0,0,0,,and numerals is this association
Dialogue: 0,0:33:33.36,0:33:35.76,BottomCenter,,0,0,0,,and if I select an element
Dialogue: 0,0:33:36.00,0:33:39.86,BottomCenter,,0,0,0,,what I'm going to pass in instead of an index is a key
Dialogue: 0,0:33:40.76,0:33:41.40,BottomCenter,,0,0,0,,at which point
Dialogue: 0,0:33:41.40,0:33:44.20,BottomCenter,,0,0,0,,I can get the value associated with that key
Dialogue: 0,0:33:44.93,0:33:46.90,BottomCenter,,0,0,0,,now I cannot go the other way around
Dialogue: 0,0:33:47.79,0:33:49.67,BottomCenter,,0,0,0,,10 is not a key it's a value
Dialogue: 0,0:33:50.86,0:33:51.67,BottomCenter,,0,0,0,,okay
Dialogue: 0,0:33:51.93,0:33:54.90,BottomCenter,,0,0,0,,so now we know the basic functionality of dictionaries
Dialogue: 0,0:33:55.17,0:33:57.17,BottomCenter,,0,0,0,,you create them with a dictionary literal
Dialogue: 0,0:33:57.17,0:33:58.86,BottomCenter,,0,0,0,,which separates by commas
Dialogue: 0,0:33:58.86,0:34:02.13,BottomCenter,,0,0,0,,key value pairs that are separated by colons
Dialogue: 0,0:34:03.06,0:34:07.36,BottomCenter,,0,0,0,,and then using element selection you can select a key
Dialogue: 0,0:34:07.52,0:34:09.26,BottomCenter,,0,0,0,,and it will give you back to value
Dialogue: 0,0:34:11.00,0:34:12.86,BottomCenter,,0,0,0,,there are a few more things you can do
Dialogue: 0,0:34:13.40,0:34:15.30,BottomCenter,,0,0,0,,you can look at all the keys
Dialogue: 0,0:34:17.53,0:34:20.07,BottomCenter,,0,0,0,,and these are the dictionary keys xv and I
Dialogue: 0,0:34:20.26,0:34:22.13,BottomCenter,,0,0,0,,and you can look at all the values
Dialogue: 0,0:34:22.86,0:34:25.13,BottomCenter,,0,0,0,,you can also look at all the items
Dialogue: 0,0:34:25.53,0:34:27.73,BottomCenter,,0,0,0,,and those are the key value pairs
Dialogue: 0,0:34:28.92,0:34:31.19,BottomCenter,,0,0,0,,now if you had this list right here
Dialogue: 0,0:34:32.59,0:34:33.69,BottomCenter,,0,0,0,,of items
Dialogue: 0,0:34:35.17,0:34:37.46,BottomCenter,,0,0,0,,you could actually build a dictionary out of it
Dialogue: 0,0:34:37.50,0:34:39.90,BottomCenter,,0,0,0,,just by calling the dict constructor
Dialogue: 0,0:34:40.46,0:34:42.13,BottomCenter,,0,0,0,,at which point you could look up
Dialogue: 0,0:34:42.36,0:34:44.40,BottomCenter,,0,0,0,,x in there and it would give you tit
Dialogue: 0,0:34:47.32,0:34:51.46,BottomCenter,,0,0,0,,now you can ask python if a particular key is in a
Dialogue: 0,0:34:51.73,0:34:52.59,BottomCenter,,0,0,0,,dictionary
Dialogue: 0,0:34:53.96,0:34:55.32,BottomCenter,,0,0,0,,so x is in there
Dialogue: 0,0:34:55.69,0:34:57.76,BottomCenter,,0,0,0,,and x ray is not
Dialogue: 0,0:34:58.80,0:35:01.09,BottomCenter,,0,0,0,,if you want to get out the value for a key
Dialogue: 0,0:35:01.09,0:35:02.40,BottomCenter,,0,0,0,,but you're not sure it's there
Dialogue: 0,0:35:02.40,0:35:05.00,BottomCenter,,0,0,0,,and you want to supply a default instead
Dialogue: 0,0:35:05.26,0:35:06.92,BottomCenter,,0,0,0,,you can use the get method
Dialogue: 0,0:35:07.26,0:35:08.57,BottomCenter,,0,0,0,,so if I get x
Dialogue: 0,0:35:09.13,0:35:10.59,BottomCenter,,0,0,0,,with a default of zero
Dialogue: 0,0:35:10.59,0:35:13.19,BottomCenter,,0,0,0,,it will give me 10 because x has a value
Dialogue: 0,0:35:13.57,0:35:14.90,BottomCenter,,0,0,0,,but if I get x ray
Dialogue: 0,0:35:15.17,0:35:17.26,BottomCenter,,0,0,0,,it will give me zero the default
Dialogue: 0,0:35:18.32,0:35:19.96,BottomCenter,,0,0,0,,two more things that I'll show you
Dialogue: 0,0:35:20.36,0:35:24.46,BottomCenter,,0,0,0,,there's an expression called a dictionary comprehension
Dialogue: 0,0:35:25.17,0:35:27.46,BottomCenter,,0,0,0,,which is like a list comprehension
Dialogue: 0,0:35:27.69,0:35:30.00,BottomCenter,,0,0,0,,I won't go through the details of its execution
Dialogue: 0,0:35:30.00,0:35:30.80,BottomCenter,,0,0,0,,procedure
Dialogue: 0,0:35:30.86,0:35:32.69,BottomCenter,,0,0,0,,but I will show you how it works
Dialogue: 0,0:35:33.67,0:35:36.92,BottomCenter,,0,0,0,,so let's say I want to associate x with
Dialogue: 0,0:35:38.07,0:35:41.53,BottomCenter,,0,0,0,,x squared for some x in a range
Dialogue: 0,0:35:41.86,0:35:43.57,BottomCenter,,0,0,0,,let's say the range up to 10
Dialogue: 0,0:35:45.07,0:35:46.86,BottomCenter,,0,0,0,,I've just created a dictionary
Dialogue: 0,0:35:47.30,0:35:50.50,BottomCenter,,0,0,0,,where the keys are the elements in range 10
Dialogue: 0,0:35:50.80,0:35:54.17,BottomCenter,,0,0,0,,and the values are that number square
Dialogue: 0,0:35:55.17,0:35:56.96,BottomCenter,,0,0,0,,so if I call this squares
Dialogue: 0,0:35:57.00,0:36:00.67,BottomCenter,,0,0,0,,and I look up the square of seven
Dialogue: 0,0:36:00.96,0:36:02.92,BottomCenter,,0,0,0,,I should get 49
Dialogue: 0,0:36:04.96,0:36:07.40,BottomCenter,,0,0,0,,now there are some restrictions on dictionaries
Dialogue: 0,0:36:08.26,0:36:10.50,BottomCenter,,0,0,0,,you can't have the same key twice
Dialogue: 0,0:36:13.26,0:36:14.00,BottomCenter,,0,0,0,,so if you do
Dialogue: 0,0:36:14.00,0:36:16.73,BottomCenter,,0,0,0,,it will just throw out one of your elements
Dialogue: 0,0:36:17.09,0:36:19.40,BottomCenter,,0,0,0,,and that's part of the design of what dictionaries are
Dialogue: 0,0:36:19.40,0:36:21.19,BottomCenter,,0,0,0,,you get one value per key
Dialogue: 0,0:36:23.07,0:36:25.92,BottomCenter,,0,0,0,,now instead of having the same key twice
Dialogue: 0,0:36:25.92,0:36:27.59,BottomCenter,,0,0,0,,it's fine if I have
Dialogue: 0,0:36:27.90,0:36:31.67,BottomCenter,,0,0,0,,a sequence of multiple values for a given key
Dialogue: 0,0:36:31.92,0:36:34.00,BottomCenter,,0,0,0,,because this is really just one value
Dialogue: 0,0:36:34.09,0:36:35.13,BottomCenter,,0,0,0,,it's a sequence
Dialogue: 0,0:36:35.36,0:36:37.09,BottomCenter,,0,0,0,,it contains other values with it
Dialogue: 0,0:36:39.90,0:36:40.73,BottomCenter,,0,0,0,,however
Dialogue: 0,0:36:40.92,0:36:44.57,BottomCenter,,0,0,0,,I'm not allowed to use lists or dictionaries as keys
Dialogue: 0,0:36:45.09,0:36:48.07,BottomCenter,,0,0,0,,so I can't write the list containing one
Dialogue: 0,0:36:49.00,0:36:50.59,BottomCenter,,0,0,0,,is associated with two
Dialogue: 0,0:36:51.09,0:36:53.96,BottomCenter,,0,0,0,,and I'll get this error unhashable type
Dialogue: 0,0:36:54.32,0:36:57.30,BottomCenter,,0,0,0,,I wish I could tell you exactly what that means
Dialogue: 0,0:36:57.30,0:36:58.17,BottomCenter,,0,0,0,,but I'm not allowed
Dialogue: 0,0:36:58.17,0:37:00.07,BottomCenter,,0,0,0,,because I have to leave some topics
Dialogue: 0,0:37:00.09,0:37:01.30,BottomCenter,,0,0,0,,for future classes
Dialogue: 0,0:37:01.30,0:37:02.46,BottomCenter,,0,0,0,,like 61 b
Dialogue: 0,0:37:03.57,0:37:06.76,BottomCenter,,0,0,0,,so just accept that you can't put list's keys
Dialogue: 0,0:37:06.76,0:37:09.26,BottomCenter,,0,0,0,,you cannot put other dictionaries's keys
Dialogue: 0,0:37:09.59,0:37:12.19,BottomCenter,,0,0,0,,and that's just a constraint of the language
Dialogue: 0,0:37:14.96,0:37:17.90,BottomCenter,,0,0,0,,so dictionaries associate values with keys
Dialogue: 0,0:37:18.17,0:37:19.32,BottomCenter,,0,0,0,,they're unordered
Dialogue: 0,0:37:19.32,0:37:21.76,BottomCenter,,0,0,0,,so don't rely on the order that you put things in
Dialogue: 0,0:37:21.76,0:37:23.69,BottomCenter,,0,0,0,,because it will not be maintained
Dialogue: 0,0:37:24.76,0:37:27.67,BottomCenter,,0,0,0,,keys cannot be list or dictionaries
Dialogue: 0,0:37:27.67,0:37:29.90,BottomCenter,,0,0,0,,or any mutable type in the language
Dialogue: 0,0:37:29.90,0:37:31.57,BottomCenter,,0,0,0,,we'll talk about what that means soon
Dialogue: 0,0:37:32.90,0:37:34.26,BottomCenter,,0,0,0,,two keys cannot be equal
Dialogue: 0,0:37:34.26,0:37:36.09,BottomCenter,,0,0,0,,because you can only have a key once
Dialogue: 0,0:37:37.40,0:37:38.92,BottomCenter,,0,0,0,,this first restriction is tied
Dialogue: 0,0:37:38.92,0:37:41.53,BottomCenter,,0,0,0,,to how dictionaries are implemented
Dialogue: 0,0:37:42.17,0:37:43.59,BottomCenter,,0,0,0,,and the second one is part of the
Dialogue: 0,0:37:43.59,0:37:45.69,BottomCenter,,0,0,0,,design of what a dictionary is supposed to do
Dialogue: 0,0:37:47.90,0:37:48.36,BottomCenter,,0,0,0,,like I said
Dialogue: 0,0:37:48.36,0:37:50.76,BottomCenter,,0,0,0,,if you want to associate multiple values with a key
Dialogue: 0,0:37:51.17,0:37:52.40,BottomCenter,,0,0,0,,put them all on a sequence