[Script Info]
; Script generated by Bilibili Evolved Danmaku Converter
; https://github.com/the1812/Bilibili-Evolved/
Title: Lecture 12. Trees - Lecture 12. Trees
ScriptType: v4.00+
PlayResX: 1280
PlayResY: 720
Timer: 10.0000
WrapStyle: 0
ScaledBorderAndShadow: no

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: TopLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,7,32,32,32,0
Style: TopCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,8,32,32,32,0
Style: TopRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,9,32,32,32,0
Style: BottomLeft,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,1,32,32,32,0
Style: BottomCenter,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,2,32,32,32,0
Style: BottomRight,微软雅黑,48,&H00FFFFFF,&H00FFFFFF,&H99000000,&H99000000,0,0,0,0,100,100,0,0,3,1,0,3,32,32,32,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.27,0:00:02.20,BottomCenter,,0,0,0,,61 a lecture No.12
Dialogue: 0,0:00:02.60,0:00:03.53,BottomCenter,,0,0,0,,announcements
Dialogue: 0,0:00:04.13,0:00:06.40,BottomCenter,,0,0,0,,the cats project is due next Friday
Dialogue: 0,0:00:06.67,0:00:09.73,BottomCenter,,0,0,0,,but you need to finish phase one by next Tuesday
Dialogue: 0,0:00:09.80,0:00:11.77,BottomCenter,,0,0,0,,in order to get the checkpoint
Dialogue: 0,0:00:12.10,0:00:13.50,BottomCenter,,0,0,0,,that's there to make sure you're making
Dialogue: 0,0:00:13.50,0:00:14.67,BottomCenter,,0,0,0,,progress so that you finish
Dialogue: 0,0:00:14.67,0:00:15.53,BottomCenter,,0,0,0,,on time
Dialogue: 0,0:00:15.87,0:00:18.33,BottomCenter,,0,0,0,,it's a good idea to finish phase one even sooner than
Dialogue: 0,0:00:18.33,0:00:20.50,BottomCenter,,0,0,0,,Tuesday and you can just submit
Dialogue: 0,0:00:20.50,0:00:22.13,BottomCenter,,0,0,0,,whatever you have that includes a
Dialogue: 0,0:00:22.13,0:00:24.33,BottomCenter,,0,0,0,,completed phase one in order to get credit
Dialogue: 0,0:00:25.13,0:00:26.90,BottomCenter,,0,0,0,,you'll get a bonus point for submitting the whole
Dialogue: 0,0:00:26.90,0:00:28.73,BottomCenter,,0,0,0,,project by next Thursday
Dialogue: 0,0:00:29.90,0:00:31.80,BottomCenter,,0,0,0,,and what are the phases anyway
Dialogue: 0,0:00:32.50,0:00:33.97,BottomCenter,,0,0,0,,well in phase one
Dialogue: 0,0:00:34.10,0:00:37.40,BottomCenter,,0,0,0,,you measure typing speed and select things to type
Dialogue: 0,0:00:37.70,0:00:38.47,BottomCenter,,0,0,0,,in phase ii
Dialogue: 0,0:00:38.47,0:00:40.90,BottomCenter,,0,0,0,,you build the autocorrect system that I talked about
Dialogue: 0,0:00:40.90,0:00:42.90,BottomCenter,,0,0,0,,in the last announcement video
Dialogue: 0,0:00:43.37,0:00:45.97,BottomCenter,,0,0,0,,and in phase iii you build multiplayer
Dialogue: 0,0:00:46.77,0:00:49.57,BottomCenter,,0,0,0,,if you want to try out multiplayer before you build it
Dialogue: 0,0:00:49.57,0:00:53.67,BottomCenter,,0,0,0,,you can go to our implementation at cats csixtona org
Dialogue: 0,0:00:54.20,0:00:56.17,BottomCenter,,0,0,0,,it finds other opponents
Dialogue: 0,0:00:56.27,0:00:58.47,BottomCenter,,0,0,0,,by finding other people who are also
Dialogue: 0,0:00:58.47,0:01:00.07,BottomCenter,,0,0,0,,trying to play a multiplayer game
Dialogue: 0,0:01:00.17,0:01:02.46,BottomCenter,,0,0,0,,and then starting up a multiplayer game
Dialogue: 0,0:01:03.70,0:01:04.67,BottomCenter,,0,0,0,,here we go
Dialogue: 0,0:01:13.00,0:01:14.70,BottomCenter,,0,0,0,,oh this person's fast
Dialogue: 0,0:01:22.50,0:01:23.29,BottomCenter,,0,0,0,,oh
Dialogue: 0,0:01:24.73,0:01:27.56,BottomCenter,,0,0,0,,lost by almost 5 seconds
Dialogue: 0,0:01:28.17,0:01:30.12,BottomCenter,,0,0,0,,so if you want you could try that out
Dialogue: 0,0:01:30.37,0:01:32.47,BottomCenter,,0,0,0,,but more importantly you have to build it
Dialogue: 0,0:01:33.97,0:01:34.53,BottomCenter,,0,0,0,,by the way
Dialogue: 0,0:01:34.53,0:01:37.06,BottomCenter,,0,0,0,,if you haven't hovered your mouse over this gift yet
Dialogue: 0,0:01:37.06,0:01:38.53,BottomCenter,,0,0,0,,I recommend doing so
Dialogue: 0,0:01:39.76,0:01:43.26,BottomCenter,,0,0,0,,we have an exam prep session Friday at 200 pm
Dialogue: 0,0:01:43.80,0:01:45.20,BottomCenter,,0,0,0,,extra q amp a coming up
Dialogue: 0,0:01:45.30,0:01:47.73,BottomCenter,,0,0,0,,recording so far are all stored here
Dialogue: 0,0:01:48.06,0:01:49.50,BottomCenter,,0,0,0,,and the last announcement
Dialogue: 0,0:01:49.59,0:01:53.09,BottomCenter,,0,0,0,,is that the hog strategy contest is over
Dialogue: 0,0:01:53.93,0:01:55.93,BottomCenter,,0,0,0,,and I wanted to say congratulations
Dialogue: 0,0:01:55.93,0:01:57.17,BottomCenter,,0,0,0,,actually to everybody
Dialogue: 0,0:01:57.17,0:01:59.93,BottomCenter,,0,0,0,,who participated in the hog strategy contest
Dialogue: 0,0:02:00.09,0:02:04.37,BottomCenter,,0,0,0,,we had a massive number over 150 entries
Dialogue: 0,0:02:04.53,0:02:06.00,BottomCenter,,0,0,0,,which I think is just awesome
Dialogue: 0,0:02:06.06,0:02:06.70,BottomCenter,,0,0,0,,the thing that
Dialogue: 0,0:02:06.70,0:02:07.73,BottomCenter,,0,0,0,,makes me most happy
Dialogue: 0,0:02:07.73,0:02:09.53,BottomCenter,,0,0,0,,is just seeing lots of participation
Dialogue: 0,0:02:10.00,0:02:12.12,BottomCenter,,0,0,0,,but since there were rules
Dialogue: 0,0:02:12.37,0:02:14.19,BottomCenter,,0,0,0,,we do need to announce a winner
Dialogue: 0,0:02:14.37,0:02:19.09,BottomCenter,,0,0,0,,and with first place winning 146 times
Dialogue: 0,0:02:19.27,0:02:21.69,BottomCenter,,0,0,0,,there was a five way tie
Dialogue: 0,0:02:22.12,0:02:24.00,BottomCenter,,0,0,0,,I don't think this has ever happened before
Dialogue: 0,0:02:25.12,0:02:27.77,BottomCenter,,0,0,0,,how could it be that there's a five way tire for first
Dialogue: 0,0:02:27.97,0:02:30.69,BottomCenter,,0,0,0,,well actually the submissions were different
Dialogue: 0,0:02:30.69,0:02:32.12,BottomCenter,,0,0,0,,but the rule
Dialogue: 0,0:02:32.12,0:02:34.87,BottomCenter,,0,0,0,,state that a submission scores a match point each time
Dialogue: 0,0:02:34.87,0:02:36.69,BottomCenter,,0,0,0,,it has an expected win rate
Dialogue: 0,0:02:36.80,0:02:40.69,BottomCenter,,0,0,0,,strictly above 50 point 0001 %
Dialogue: 0,0:02:41.47,0:02:44.69,BottomCenter,,0,0,0,,and these five entries were also
Dialogue: 0,0:02:44.90,0:02:47.09,BottomCenter,,0,0,0,,close in their wind rates
Dialogue: 0,0:02:47.30,0:02:50.30,BottomCenter,,0,0,0,,that none of them beat another one by this
Dialogue: 0,0:02:50.40,0:02:51.90,BottomCenter,,0,0,0,,very small margin
Dialogue: 0,0:02:52.33,0:02:54.12,BottomCenter,,0,0,0,,but they were not all the same
Dialogue: 0,0:02:54.59,0:02:57.77,BottomCenter,,0,0,0,,the five entries bobby tables anonymous poet
Dialogue: 0,0:02:57.80,0:03:01.16,BottomCenter,,0,0,0,,the golden ratio wet app program and blockchain
Dialogue: 0,0:03:01.77,0:03:03.96,BottomCenter,,0,0,0,,one or lost against each other
Dialogue: 0,0:03:03.96,0:03:05.69,BottomCenter,,0,0,0,,in a very interesting pattern
Dialogue: 0,0:03:06.09,0:03:09.30,BottomCenter,,0,0,0,,bobby tables had a win rate above 50%
Dialogue: 0,0:03:09.40,0:03:11.56,BottomCenter,,0,0,0,,when playing against the golden ratio
Dialogue: 0,0:03:11.80,0:03:15.06,BottomCenter,,0,0,0,,a golden ratio had a win rate above 50% when playing
Dialogue: 0,0:03:15.06,0:03:16.59,BottomCenter,,0,0,0,,against the anonymous poet
Dialogue: 0,0:03:16.59,0:03:19.40,BottomCenter,,0,0,0,,but the anonymous poet had a win rate above 50% when
Dialogue: 0,0:03:19.40,0:03:20.30,BottomCenter,,0,0,0,,playing against
Dialogue: 0,0:03:20.30,0:03:21.40,BottomCenter,,0,0,0,,bobby tables
Dialogue: 0,0:03:22.30,0:03:24.47,BottomCenter,,0,0,0,,blockchain and anonymous poet
Dialogue: 0,0:03:24.50,0:03:27.97,BottomCenter,,0,0,0,,had a win rate of exactly 50% against each other
Dialogue: 0,0:03:28.06,0:03:30.77,BottomCenter,,0,0,0,,I think they were effectively the same strategy
Dialogue: 0,0:03:31.37,0:03:33.56,BottomCenter,,0,0,0,,whereas all the other ones were different
Dialogue: 0,0:03:34.12,0:03:36.37,BottomCenter,,0,0,0,,bobby tables among the top five
Dialogue: 0,0:03:36.87,0:03:39.56,BottomCenter,,0,0,0,,won more than half the time against two opponents
Dialogue: 0,0:03:39.56,0:03:42.59,BottomCenter,,0,0,0,,and lost more than half the time against two opponents
Dialogue: 0,0:03:43.09,0:03:45.40,BottomCenter,,0,0,0,,it was actually only wet app program
Dialogue: 0,0:03:45.53,0:03:47.33,BottomCenter,,0,0,0,,that one more than half the time
Dialogue: 0,0:03:47.33,0:03:48.69,BottomCenter,,0,0,0,,against more opponents
Dialogue: 0,0:03:48.72,0:03:50.66,BottomCenter,,0,0,0,,than it lost but it still
Dialogue: 0,0:03:50.66,0:03:52.93,BottomCenter,,0,0,0,,had a lower than fifty percent one rate against
Dialogue: 0,0:03:52.93,0:03:54.00,BottomCenter,,0,0,0,,bobby tables
Dialogue: 0,0:03:55.37,0:03:57.59,BottomCenter,,0,0,0,,in any case these were the rules
Dialogue: 0,0:03:57.59,0:03:59.50,BottomCenter,,0,0,0,,and so none of these entries
Dialogue: 0,0:03:59.50,0:04:02.37,BottomCenter,,0,0,0,,scored a match point against any of the other entries
Dialogue: 0,0:04:02.56,0:04:05.59,BottomCenter,,0,0,0,,leading to a five way first place ti
Dialogue: 0,0:04:06.30,0:04:08.53,BottomCenter,,0,0,0,,congratulations to everybody who is part
Dialogue: 0,0:04:08.53,0:04:09.46,BottomCenter,,0,0,0,,of one of those
Dialogue: 0,0:04:09.53,0:04:10.59,BottomCenter,,0,0,0,,winning entries
Dialogue: 0,0:04:10.87,0:04:14.53,BottomCenter,,0,0,0,,here's the list of folks in reverse alphabetical order
Dialogue: 0,0:04:15.00,0:04:18.37,BottomCenter,,0,0,0,,awesome job you all get extra credit points
Dialogue: 0,0:04:18.52,0:04:19.73,BottomCenter,,0,0,0,,and if you want to see more
Dialogue: 0,0:04:19.73,0:04:21.73,BottomCenter,,0,0,0,,about what happened in the hug contest
Dialogue: 0,0:04:21.80,0:04:23.76,BottomCenter,,0,0,0,,you can go to the leaderboard here
Dialogue: 0,0:04:24.67,0:04:26.17,BottomCenter,,0,0,0,,so those are all the announcements
Dialogue: 0,0:04:26.17,0:04:29.52,BottomCenter,,0,0,0,,now we'll talk about today's content which is trees
Dialogue: 0,0:04:29.89,0:04:32.56,BottomCenter,,0,0,0,,trees are one of my favorite topics in this course
Dialogue: 0,0:04:33.06,0:04:34.12,BottomCenter,,0,0,0,,when we bring together
Dialogue: 0,0:04:34.12,0:04:37.10,BottomCenter,,0,0,0,,what we've learned about containers and data
Dialogue: 0,0:04:37.37,0:04:39.76,BottomCenter,,0,0,0,,with what we've learned about recursion
Dialogue: 0,0:04:40.00,0:04:42.56,BottomCenter,,0,0,0,,in order to built recursive data
Dialogue: 0,0:04:42.93,0:04:44.97,BottomCenter,,0,0,0,,and this is one of the main reasons that we learned
Dialogue: 0,0:04:44.97,0:04:46.93,BottomCenter,,0,0,0,,about recursive functions in this course
Dialogue: 0,0:04:47.06,0:04:49.26,BottomCenter,,0,0,0,,is to process tree structured data
Dialogue: 0,0:04:50.06,0:04:51.73,BottomCenter,,0,0,0,,and today you'll mostly see
Dialogue: 0,0:04:51.87,0:04:54.47,BottomCenter,,0,0,0,,trees filled with numbers or strings
Dialogue: 0,0:04:54.89,0:04:56.76,BottomCenter,,0,0,0,,but tree structure data appears in
Dialogue: 0,0:04:56.76,0:04:58.50,BottomCenter,,0,0,0,,lots of other programs as well
Dialogue: 0,0:04:58.76,0:05:02.17,BottomCenter,,0,0,0,,when you're representing a website or an org chart
Dialogue: 0,0:05:02.52,0:05:04.32,BottomCenter,,0,0,0,,or a system of government
Dialogue: 0,0:05:04.56,0:05:07.47,BottomCenter,,0,0,0,,or anything else that has a hierarchical structure
Dialogue: 0,0:05:07.69,0:05:10.19,BottomCenter,,0,0,0,,then you're going to need tree structured data
Dialogue: 0,0:05:12.37,0:05:16.00,BottomCenter,,0,0,0,,bucks and pointer notation is a way to represent
Dialogue: 0,0:05:16.50,0:05:19.80,BottomCenter,,0,0,0,,lists within our environment diagrams
Dialogue: 0,0:05:21.06,0:05:23.93,BottomCenter,,0,0,0,,so the reason why we need a notation is that
Dialogue: 0,0:05:23.93,0:05:27.06,BottomCenter,,0,0,0,,sequential data can actually become quite complicated
Dialogue: 0,0:05:27.39,0:05:29.60,BottomCenter,,0,0,0,,and that's because of the closure property
Dialogue: 0,0:05:29.93,0:05:33.32,BottomCenter,,0,0,0,,a method for combining data values satisfies
Dialogue: 0,0:05:33.37,0:05:35.30,BottomCenter,,0,0,0,,this closure property
Dialogue: 0,0:05:35.60,0:05:38.30,BottomCenter,,0,0,0,,if it's the case that the result of combination
Dialogue: 0,0:05:38.37,0:05:41.50,BottomCenter,,0,0,0,,can itself be combined using the same method
Dialogue: 0,0:05:42.19,0:05:44.32,BottomCenter,,0,0,0,,if I can put items within a list
Dialogue: 0,0:05:44.32,0:05:46.32,BottomCenter,,0,0,0,,I should be able to take that list
Dialogue: 0,0:05:46.32,0:05:47.97,BottomCenter,,0,0,0,,and put it into a list
Dialogue: 0,0:05:49.10,0:05:51.87,BottomCenter,,0,0,0,,closure is powerful because it permits us to create
Dialogue: 0,0:05:52.17,0:05:54.12,BottomCenter,,0,0,0,,hierarchical structures
Dialogue: 0,0:05:54.97,0:05:57.00,BottomCenter,,0,0,0,,hierarchical structures are made up of parts
Dialogue: 0,0:05:57.00,0:05:59.10,BottomCenter,,0,0,0,,which themselves are made up of parts
Dialogue: 0,0:05:59.12,0:06:02.89,BottomCenter,,0,0,0,,and so on and that is an extremely useful way
Dialogue: 0,0:06:02.89,0:06:05.76,BottomCenter,,0,0,0,,to represent all sorts of things in the world
Dialogue: 0,0:06:07.32,0:06:08.67,BottomCenter,,0,0,0,,so the important point
Dialogue: 0,0:06:08.67,0:06:11.52,BottomCenter,,0,0,0,,here is that list can contain other lists as elements
Dialogue: 0,0:06:11.56,0:06:13.52,BottomCenter,,0,0,0,,in addition to anything else
Dialogue: 0,0:06:13.97,0:06:14.97,BottomCenter,,0,0,0,,and that means
Dialogue: 0,0:06:14.97,0:06:16.37,BottomCenter,,0,0,0,,that we need a way to keep track of
Dialogue: 0,0:06:16.37,0:06:17.60,BottomCenter,,0,0,0,,what's inside of what
Dialogue: 0,0:06:18.30,0:06:21.12,BottomCenter,,0,0,0,,that's where we use box and pointer notation
Dialogue: 0,0:06:24.26,0:06:27.30,BottomCenter,,0,0,0,,lists are represented in environment diagrams
Dialogue: 0,0:06:27.30,0:06:30.87,BottomCenter,,0,0,0,,as a row of index labeled adjacent boxes
Dialogue: 0,0:06:30.87,0:06:32.30,BottomCenter,,0,0,0,,one per element
Dialogue: 0,0:06:33.12,0:06:35.93,BottomCenter,,0,0,0,,each box either contains a permanent value
Dialogue: 0,0:06:36.10,0:06:38.89,BottomCenter,,0,0,0,,or points to a compound value
Dialogue: 0,0:06:40.52,0:06:43.69,BottomCenter,,0,0,0,,so if I just say pair equals the list one two
Dialogue: 0,0:06:44.06,0:06:46.30,BottomCenter,,0,0,0,,I'll write that in my environment diagram
Dialogue: 0,0:06:46.32,0:06:48.00,BottomCenter,,0,0,0,,by binding the name pair
Dialogue: 0,0:06:48.06,0:06:50.67,BottomCenter,,0,0,0,,to a list that contains one and two
Dialogue: 0,0:06:51.12,0:06:53.06,BottomCenter,,0,0,0,,these small numbers in the corner
Dialogue: 0,0:06:53.30,0:06:55.76,BottomCenter,,0,0,0,,are just indices of the list
Dialogue: 0,0:06:56.12,0:06:58.89,BottomCenter,,0,0,0,,and so since the list has two elements
Dialogue: 0,0:06:58.89,0:07:01.87,BottomCenter,,0,0,0,,we see two adjacent boxes
Dialogue: 0,0:07:02.97,0:07:04.97,BottomCenter,,0,0,0,,now for a more complex example
Dialogue: 0,0:07:05.60,0:07:09.19,BottomCenter,,0,0,0,,nested list is bound to a list that contains a list
Dialogue: 0,0:07:09.19,0:07:10.76,BottomCenter,,0,0,0,,a list and another list
Dialogue: 0,0:07:11.17,0:07:13.67,BottomCenter,,0,0,0,,and this 3rd list contains lists itself
Dialogue: 0,0:07:13.97,0:07:16.97,BottomCenter,,0,0,0,,and within it are all sorts of things even a function
Dialogue: 0,0:07:17.97,0:07:20.37,BottomCenter,,0,0,0,,so let's walk through everything that's on the screen
Dialogue: 0,0:07:21.30,0:07:23.89,BottomCenter,,0,0,0,,nested list is a three element list
Dialogue: 0,0:07:24.10,0:07:28.32,BottomCenter,,0,0,0,,and so we see it bound to three adjacent rectangles
Dialogue: 0,0:07:29.17,0:07:32.73,BottomCenter,,0,0,0,,now each element of nested list is actually
Dialogue: 0,0:07:32.93,0:07:33.89,BottomCenter,,0,0,0,,another list
Dialogue: 0,0:07:34.06,0:07:37.56,BottomCenter,,0,0,0,,and so that's why we see pointers to compound values
Dialogue: 0,0:07:37.56,0:07:39.39,BottomCenter,,0,0,0,,lists are compound values
Dialogue: 0,0:07:39.50,0:07:41.39,BottomCenter,,0,0,0,,functions or compound values
Dialogue: 0,0:07:41.39,0:07:43.56,BottomCenter,,0,0,0,,anything that has multiple parts
Dialogue: 0,0:07:43.73,0:07:46.26,BottomCenter,,0,0,0,,is going to be represented using an arrow
Dialogue: 0,0:07:46.39,0:07:49.30,BottomCenter,,0,0,0,,to some depiction of that thing
Dialogue: 0,0:07:51.26,0:07:54.47,BottomCenter,,0,0,0,,okay so here we see that the elemented index zero
Dialogue: 0,0:07:54.52,0:07:56.89,BottomCenter,,0,0,0,,is just a list containing one and two
Dialogue: 0,0:07:57.80,0:08:00.39,BottomCenter,,0,0,0,,the element that index one is the empty list
Dialogue: 0,0:08:00.73,0:08:02.26,BottomCenter,,0,0,0,,here we see the empty list
Dialogue: 0,0:08:02.60,0:08:04.19,BottomCenter,,0,0,0,,and the element that index 3
Dialogue: 0,0:08:04.56,0:08:08.10,BottomCenter,,0,0,0,,is its self a list that contains two other lists
Dialogue: 0,0:08:08.32,0:08:11.80,BottomCenter,,0,0,0,,and so that's why we see this hierarchical structure
Dialogue: 0,0:08:12.52,0:08:13.32,BottomCenter,,0,0,0,,where
Dialogue: 0,0:08:13.32,0:08:16.19,BottomCenter,,0,0,0,,this is made up of parts which are made up of parts
Dialogue: 0,0:08:18.12,0:08:19.67,BottomCenter,,0,0,0,,the primitive values three
Dialogue: 0,0:08:19.67,0:08:22.69,BottomCenter,,0,0,0,,false and none can be written directly into the box
Dialogue: 0,0:08:23.56,0:08:25.87,BottomCenter,,0,0,0,,so can for the function
Dialogue: 0,0:08:25.97,0:08:28.60,BottomCenter,,0,0,0,,we write as we've always written functions before
Dialogue: 0,0:08:29.06,0:08:31.87,BottomCenter,,0,0,0,,and we use a small arrow to say that it's contained
Dialogue: 0,0:08:32.07,0:08:34.29,BottomCenter,,0,0,0,,as this element at index one
Dialogue: 0,0:08:34.33,0:08:36.50,BottomCenter,,0,0,0,,of the list that's within this list
Dialogue: 0,0:08:36.50,0:08:37.73,BottomCenter,,0,0,0,,that's within this list
Dialogue: 0,0:08:41.07,0:08:43.60,BottomCenter,,0,0,0,,slicing is an operation that you can perform
Dialogue: 0,0:08:43.60,0:08:47.26,BottomCenter,,0,0,0,,on sequences such as lists and ranges
Dialogue: 0,0:08:49.39,0:08:53.73,BottomCenter,,0,0,0,,let's say I have a sequence already 3 5 7 9 11
Dialogue: 0,0:08:54.60,0:08:56.37,BottomCenter,,0,0,0,,and what I'd like to get out
Dialogue: 0,0:08:56.39,0:08:58.66,BottomCenter,,0,0,0,,is just the five and the seven
Dialogue: 0,0:08:58.87,0:09:01.33,BottomCenter,,0,0,0,,so these are elements at index one and two
Dialogue: 0,0:09:02.00,0:09:03.73,BottomCenter,,0,0,0,,well I could
Dialogue: 0,0:09:04.92,0:09:08.37,BottomCenter,,0,0,0,,get myself the indices one and two
Dialogue: 0,0:09:09.37,0:09:12.57,BottomCenter,,0,0,0,,and then I could use that in a list comprehension
Dialogue: 0,0:09:12.76,0:09:14.39,BottomCenter,,0,0,0,,I want odds I
Dialogue: 0,0:09:14.97,0:09:18.66,BottomCenter,,0,0,0,,for I in range 1 2 3
Dialogue: 0,0:09:20.70,0:09:21.37,BottomCenter,,0,0,0,,and remember
Dialogue: 0,0:09:21.37,0:09:24.33,BottomCenter,,0,0,0,,range one to three gives me one and two but not three
Dialogue: 0,0:09:25.16,0:09:25.57,BottomCenter,,0,0,0,,okay
Dialogue: 0,0:09:25.57,0:09:28.26,BottomCenter,,0,0,0,,so that's one way to select out the five and the seven
Dialogue: 0,0:09:28.29,0:09:30.10,BottomCenter,,0,0,0,,a sub list of this list
Dialogue: 0,0:09:31.33,0:09:35.07,BottomCenter,,0,0,0,,slicing is a notation for doing this more compactly
Dialogue: 0,0:09:35.16,0:09:38.26,BottomCenter,,0,0,0,,it does the same thing but without you typing so much
Dialogue: 0,0:09:38.37,0:09:39.87,BottomCenter,,0,0,0,,you just write odds
Dialogue: 0,0:09:39.87,0:09:41.66,BottomCenter,,0,0,0,,and then in square brackets you say
Dialogue: 0,0:09:41.66,0:09:43.60,BottomCenter,,0,0,0,,I want to go from one to three
Dialogue: 0,0:09:45.76,0:09:48.87,BottomCenter,,0,0,0,,so it has the same rules as ranges
Dialogue: 0,0:09:49.33,0:09:52.29,BottomCenter,,0,0,0,,the indices include the lower bound
Dialogue: 0,0:09:52.29,0:09:54.07,BottomCenter,,0,0,0,,but exclude the upper bound
Dialogue: 0,0:09:55.57,0:09:57.76,BottomCenter,,0,0,0,,now there's some additional flexibility
Dialogue: 0,0:09:58.50,0:10:00.12,BottomCenter,,0,0,0,,just like if you leave out
Dialogue: 0,0:10:00.50,0:10:03.00,BottomCenter,,0,0,0,,one of the boundaries in a range
Dialogue: 0,0:10:03.10,0:10:05.50,BottomCenter,,0,0,0,,if you leave out the beginning number
Dialogue: 0,0:10:05.50,0:10:06.20,BottomCenter,,0,0,0,,it's going to start
Dialogue: 0,0:10:06.20,0:10:08.33,BottomCenter,,0,0,0,,from the very beginning of the list
Dialogue: 0,0:10:08.39,0:10:13.12,BottomCenter,,0,0,0,,so odds up to three gives me indice zero one and two
Dialogue: 0,0:10:13.97,0:10:15.37,BottomCenter,,0,0,0,,I can also leave out the end
Dialogue: 0,0:10:15.37,0:10:16.76,BottomCenter,,0,0,0,,and it will go all the way to the end
Dialogue: 0,0:10:16.76,0:10:18.87,BottomCenter,,0,0,0,,so if I want to start at index one
Dialogue: 0,0:10:18.92,0:10:20.92,BottomCenter,,0,0,0,,then I'll skip the three at index zero
Dialogue: 0,0:10:20.92,0:10:22.10,BottomCenter,,0,0,0,,and get all of five
Dialogue: 0,0:10:22.10,0:10:23.52,BottomCenter,,0,0,0,,seven nine and eleven
Dialogue: 0,0:10:23.87,0:10:26.66,BottomCenter,,0,0,0,,and you can even skip the beginning and the end
Dialogue: 0,0:10:26.70,0:10:27.76,BottomCenter,,0,0,0,,and you get back
Dialogue: 0,0:10:27.79,0:10:30.20,BottomCenter,,0,0,0,,all of the elements in the original list
Dialogue: 0,0:10:32.47,0:10:34.57,BottomCenter,,0,0,0,,so these square brackets for the colon inside
Dialogue: 0,0:10:34.57,0:10:36.16,BottomCenter,,0,0,0,,are called a slicing operator
Dialogue: 0,0:10:38.66,0:10:41.12,BottomCenter,,0,0,0,,slicing always creates new values
Dialogue: 0,0:10:41.26,0:10:44.16,BottomCenter,,0,0,0,,so here are some examples I have digits which is a list
Dialogue: 0,0:10:44.20,0:10:46.70,BottomCenter,,0,0,0,,and then I slice it three different times
Dialogue: 0,0:10:47.00,0:10:49.16,BottomCenter,,0,0,0,,the environment diagram that I get
Dialogue: 0,0:10:49.26,0:10:51.33,BottomCenter,,0,0,0,,includes four different lists
Dialogue: 0,0:10:51.33,0:10:54.26,BottomCenter,,0,0,0,,notice the digits is unchanged by the slicing
Dialogue: 0,0:10:54.52,0:10:58.07,BottomCenter,,0,0,0,,but when I sliced the one out
Dialogue: 0,0:10:58.29,0:10:59.47,BottomCenter,,0,0,0,,saying that I want to go
Dialogue: 0,0:10:59.47,0:11:01.07,BottomCenter,,0,0,0,,from the beginning all the way up
Dialogue: 0,0:11:01.07,0:11:03.00,BottomCenter,,0,0,0,,but not including index one
Dialogue: 0,0:11:03.12,0:11:05.66,BottomCenter,,0,0,0,,I got a new list of the value one in it
Dialogue: 0,0:11:06.79,0:11:08.70,BottomCenter,,0,0,0,,asking for the middle gave me a
Dialogue: 0,0:11:08.70,0:11:10.70,BottomCenter,,0,0,0,,third list with eight and two
Dialogue: 0,0:11:10.87,0:11:13.66,BottomCenter,,0,0,0,,and asking for everything from index two to the end
Dialogue: 0,0:11:13.79,0:11:16.10,BottomCenter,,0,0,0,,gave me a 4th list with two and eight
Dialogue: 0,0:11:18.47,0:11:20.50,BottomCenter,,0,0,0,,processing container values
Dialogue: 0,0:11:20.50,0:11:21.52,BottomCenter,,0,0,0,,often involves
Dialogue: 0,0:11:21.52,0:11:24.39,BottomCenter,,0,0,0,,iterating over all of the values contained
Dialogue: 0,0:11:24.39,0:11:27.50,BottomCenter,,0,0,0,,in the list or dictionary that you're interested in
Dialogue: 0,0:11:28.16,0:11:31.00,BottomCenter,,0,0,0,,but there are some functions built in
Dialogue: 0,0:11:31.07,0:11:33.10,BottomCenter,,0,0,0,,that help us do this more efficiently
Dialogue: 0,0:11:34.33,0:11:35.39,BottomCenter,,0,0,0,,in particular
Dialogue: 0,0:11:35.60,0:11:37.52,BottomCenter,,0,0,0,,there are several functions that perform
Dialogue: 0,0:11:37.52,0:11:39.07,BottomCenter,,0,0,0,,sequence aggregation
Dialogue: 0,0:11:39.79,0:11:40.97,BottomCenter,,0,0,0,,so these are functions that
Dialogue: 0,0:11:40.97,0:11:43.16,BottomCenter,,0,0,0,,take iterable arguments and aggregate them
Dialogue: 0,0:11:43.16,0:11:44.37,BottomCenter,,0,0,0,,into a single value
Dialogue: 0,0:11:45.52,0:11:47.33,BottomCenter,,0,0,0,,I'm just going to show you the actual
Dialogue: 0,0:11:47.33,0:11:49.37,BottomCenter,,0,0,0,,documentation in python three
Dialogue: 0,0:11:49.57,0:11:51.73,BottomCenter,,0,0,0,,and help you understand how it works
Dialogue: 0,0:11:52.47,0:11:54.60,BottomCenter,,0,0,0,,so there is a built in function called some
Dialogue: 0,0:11:55.16,0:11:59.00,BottomCenter,,0,0,0,,which takes an adorable argument such as a list
Dialogue: 0,0:11:59.76,0:12:00.87,BottomCenter,,0,0,0,,now this notation
Dialogue: 0,0:12:00.87,0:12:01.73,BottomCenter,,0,0,0,,doesn't actually
Dialogue: 0,0:12:01.73,0:12:04.07,BottomCenter,,0,0,0,,mean you write square brackets when you call it
Dialogue: 0,0:12:04.29,0:12:07.12,BottomCenter,,0,0,0,,instead this is something that's used in python docks
Dialogue: 0,0:12:07.12,0:12:09.70,BottomCenter,,0,0,0,,to say that the second argument is optional
Dialogue: 0,0:12:10.20,0:12:12.37,BottomCenter,,0,0,0,,so you can call some with just one argument
Dialogue: 0,0:12:12.37,0:12:14.37,BottomCenter,,0,0,0,,a list and it will sum the values
Dialogue: 0,0:12:14.39,0:12:16.73,BottomCenter,,0,0,0,,or you can call it with two arguments
Dialogue: 0,0:12:16.79,0:12:19.87,BottomCenter,,0,0,0,,a list of values and then some start value
Dialogue: 0,0:12:20.39,0:12:21.50,BottomCenter,,0,0,0,,and it will go through
Dialogue: 0,0:12:21.50,0:12:23.73,BottomCenter,,0,0,0,,all of the values in the iterable
Dialogue: 0,0:12:23.97,0:12:25.87,BottomCenter,,0,0,0,,and add them to the start
Dialogue: 0,0:12:25.97,0:12:27.10,BottomCenter,,0,0,0,,okay so here it says
Dialogue: 0,0:12:27.10,0:12:29.12,BottomCenter,,0,0,0,,return the sum of an iterable of numbers
Dialogue: 0,0:12:29.12,0:12:32.33,BottomCenter,,0,0,0,,not strings plus the value of parameter start
Dialogue: 0,0:12:32.37,0:12:33.97,BottomCenter,,0,0,0,,which defaults to zero
Dialogue: 0,0:12:34.29,0:12:36.89,BottomCenter,,0,0,0,,when the iterable is empty returns start
Dialogue: 0,0:12:38.57,0:12:40.87,BottomCenter,,0,0,0,,some 2 3 4
Dialogue: 0,0:12:41.92,0:12:42.89,BottomCenter,,0,0,0,,is nine
Dialogue: 0,0:12:43.79,0:12:47.47,BottomCenter,,0,0,0,,some 2 3 4
Dialogue: 0,0:12:48.76,0:12:50.57,BottomCenter,,0,0,0,,it doesn't work with strings
Dialogue: 0,0:12:50.92,0:12:53.20,BottomCenter,,0,0,0,,now what's this starting value about
Dialogue: 0,0:12:53.20,0:12:54.66,BottomCenter,,0,0,0,,well if I started with five
Dialogue: 0,0:12:54.66,0:12:57.70,BottomCenter,,0,0,0,,then it would add five and two and three and four
Dialogue: 0,0:12:58.70,0:13:00.26,BottomCenter,,0,0,0,,now why is that useful
Dialogue: 0,0:13:00.60,0:13:03.07,BottomCenter,,0,0,0,,well let's say you're adding together
Dialogue: 0,0:13:03.07,0:13:05.39,BottomCenter,,0,0,0,,values that aren't just numbers
Dialogue: 0,0:13:05.89,0:13:07.97,BottomCenter,,0,0,0,,you have to provide a value of that
Dialogue: 0,0:13:07.97,0:13:09.79,BottomCenter,,0,0,0,,type in order to get started
Dialogue: 0,0:13:10.70,0:13:13.37,BottomCenter,,0,0,0,,so remember that I can add two and three the list
Dialogue: 0,0:13:13.39,0:13:16.39,BottomCenter,,0,0,0,,to four the list and I get a longer list
Dialogue: 0,0:13:17.20,0:13:19.73,BottomCenter,,0,0,0,,well in the same way I can some
Dialogue: 0,0:13:19.92,0:13:22.39,BottomCenter,,0,0,0,,a list containing two and three
Dialogue: 0,0:13:22.70,0:13:23.97,BottomCenter,,0,0,0,,as well as four
Dialogue: 0,0:13:24.87,0:13:26.52,BottomCenter,,0,0,0,,as long as it's the case
Dialogue: 0,0:13:26.57,0:13:29.37,BottomCenter,,0,0,0,,that I start with a list in the first place
Dialogue: 0,0:13:30.60,0:13:32.50,BottomCenter,,0,0,0,,if I hadn't started with a list
Dialogue: 0,0:13:32.52,0:13:35.47,BottomCenter,,0,0,0,,I'd try to add this list to the No.0
Dialogue: 0,0:13:35.66,0:13:37.07,BottomCenter,,0,0,0,,and that's not possible
Dialogue: 0,0:13:39.76,0:13:41.33,BottomCenter,,0,0,0,,so that's what would have happened if I had
Dialogue: 0,0:13:41.33,0:13:42.29,BottomCenter,,0,0,0,,summed without
Dialogue: 0,0:13:42.29,0:13:43.57,BottomCenter,,0,0,0,,that starting value
Dialogue: 0,0:13:44.29,0:13:47.10,BottomCenter,,0,0,0,,but since I provided an empty list to begin with
Dialogue: 0,0:13:47.50,0:13:49.52,BottomCenter,,0,0,0,,and then I added in two and three
Dialogue: 0,0:13:49.70,0:13:53.47,BottomCenter,,0,0,0,,and then I added in four I ended up with a list 2 3 4
Dialogue: 0,0:13:55.70,0:13:57.76,BottomCenter,,0,0,0,,max takes two forms
Dialogue: 0,0:13:57.89,0:14:00.87,BottomCenter,,0,0,0,,you can pass it and iterable such as a list
Dialogue: 0,0:14:01.47,0:14:04.00,BottomCenter,,0,0,0,,as well as an optional key function
Dialogue: 0,0:14:04.57,0:14:06.70,BottomCenter,,0,0,0,,and it returns the maximum value
Dialogue: 0,0:14:07.47,0:14:10.37,BottomCenter,,0,0,0,,or you can pass it multiple different arguments
Dialogue: 0,0:14:10.37,0:14:12.10,BottomCenter,,0,0,0,,such as a bunch of numbers
Dialogue: 0,0:14:12.10,0:14:13.89,BottomCenter,,0,0,0,,along with a key function
Dialogue: 0,0:14:14.50,0:14:16.79,BottomCenter,,0,0,0,,and then it will take the max of the arguments
Dialogue: 0,0:14:17.12,0:14:18.87,BottomCenter,,0,0,0,,so it says with a single argument
Dialogue: 0,0:14:18.87,0:14:20.52,BottomCenter,,0,0,0,,return its largest item
Dialogue: 0,0:14:20.60,0:14:23.70,BottomCenter,,0,0,0,,that is an element of the list of the two pass in
Dialogue: 0,0:14:23.87,0:14:26.76,BottomCenter,,0,0,0,,with two or more arguments return the largest argument
Dialogue: 0,0:14:28.07,0:14:31.92,BottomCenter,,0,0,0,,so the max of a range going up to five is four
Dialogue: 0,0:14:32.73,0:14:35.60,BottomCenter,,0,0,0,,or I could have said max 1 2 3 4
Dialogue: 0,0:14:37.47,0:14:39.00,BottomCenter,,0,0,0,,with a zero at the beginning
Dialogue: 0,0:14:39.26,0:14:40.92,BottomCenter,,0,0,0,,and that would have done the same thing
Dialogue: 0,0:14:41.70,0:14:44.89,BottomCenter,,0,0,0,,now what's going on with this key function
Dialogue: 0,0:14:45.39,0:14:47.52,BottomCenter,,0,0,0,,well the documentation didn't tell me
Dialogue: 0,0:14:47.66,0:14:49.37,BottomCenter,,0,0,0,,but what happens is that it applies
Dialogue: 0,0:14:49.37,0:14:52.07,BottomCenter,,0,0,0,,a function to every element that you're considering
Dialogue: 0,0:14:52.33,0:14:52.97,BottomCenter,,0,0,0,,and actually
Dialogue: 0,0:14:52.97,0:14:55.92,BottomCenter,,0,0,0,,computes the maximum based on the return values
Dialogue: 0,0:14:55.92,0:14:57.60,BottomCenter,,0,0,0,,of calling those functions
Dialogue: 0,0:14:58.60,0:15:00.39,BottomCenter,,0,0,0,,so you can ask things like
Dialogue: 0,0:15:00.60,0:15:03.57,BottomCenter,,0,0,0,,what's the max value in the range
Dialogue: 0,0:15:03.57,0:15:05.37,BottomCenter,,0,0,0,,from zero through nine
Dialogue: 0,0:15:06.00,0:15:07.60,BottomCenter,,0,0,0,,if what I care about
Dialogue: 0,0:15:09.66,0:15:15.07,BottomCenter,,0,0,0,,is some algebraic expression like 7 x minus four
Dialogue: 0,0:15:15.33,0:15:17.33,BottomCenter,,0,0,0,,times x minus two
Dialogue: 0,0:15:18.97,0:15:20.52,BottomCenter,,0,0,0,,now that's some parabolo
Dialogue: 0,0:15:20.52,0:15:22.47,BottomCenter,,0,0,0,,where the maximum's right at three
Dialogue: 0,0:15:22.66,0:15:25.39,BottomCenter,,0,0,0,,if I designate this as my key function
Dialogue: 0,0:15:26.20,0:15:28.33,BottomCenter,,0,0,0,,then it's going to tell me the maximum value in this
Dialogue: 0,0:15:28.33,0:15:32.73,BottomCenter,,0,0,0,,range as an output of calling this function is three
Dialogue: 0,0:15:34.26,0:15:37.12,BottomCenter,,0,0,0,,so if I take this function and I apply it to the No.3
Dialogue: 0,0:15:37.50,0:15:38.70,BottomCenter,,0,0,0,,then I get eight
Dialogue: 0,0:15:38.87,0:15:41.10,BottomCenter,,0,0,0,,what if I applied it to two I get something less
Dialogue: 0,0:15:41.10,0:15:42.39,BottomCenter,,0,0,0,,if I applied it to four
Dialogue: 0,0:15:42.66,0:15:46.76,BottomCenter,,0,0,0,,or five or six or seven I'd get something less as well
Dialogue: 0,0:15:46.76,0:15:49.97,BottomCenter,,0,0,0,,so that's why it's giving me the return value of three
Dialogue: 0,0:15:51.73,0:15:53.52,BottomCenter,,0,0,0,,here's a third one called all
Dialogue: 0,0:15:54.57,0:15:57.20,BottomCenter,,0,0,0,,all takes an iterable and returns true
Dialogue: 0,0:15:57.89,0:16:00.12,BottomCenter,,0,0,0,,if you get a true value
Dialogue: 0,0:16:00.73,0:16:04.47,BottomCenter,,0,0,0,,when calling bull on every element in the iterable
Dialogue: 0,0:16:04.89,0:16:07.39,BottomCenter,,0,0,0,,if the iterable is empty return true
Dialogue: 0,0:16:07.87,0:16:09.39,BottomCenter,,0,0,0,,what's this bull function
Dialogue: 0,0:16:10.73,0:16:14.73,BottomCenter,,0,0,0,,well bull tells me whether a value is true or false
Dialogue: 0,0:16:14.87,0:16:16.70,BottomCenter,,0,0,0,,so five is a true value
Dialogue: 0,0:16:16.79,0:16:19.07,BottomCenter,,0,0,0,,true of course is a true value as well
Dialogue: 0,0:16:19.12,0:16:21.26,BottomCenter,,0,0,0,,even -1 is a true value
Dialogue: 0,0:16:21.29,0:16:24.20,BottomCenter,,0,0,0,,but zero is that not a true value it's a false value
Dialogue: 0,0:16:26.29,0:16:28.76,BottomCenter,,0,0,0,,likewise hello is a true value
Dialogue: 0,0:16:28.76,0:16:31.16,BottomCenter,,0,0,0,,and an empty string is a false value
Dialogue: 0,0:16:31.76,0:16:32.73,BottomCenter,,0,0,0,,we learned about these
Dialogue: 0,0:16:32.73,0:16:35.10,BottomCenter,,0,0,0,,when we talked about boolean contexts
Dialogue: 0,0:16:35.20,0:16:37.66,BottomCenter,,0,0,0,,back when we introduced conditional statements
Dialogue: 0,0:16:39.60,0:16:40.97,BottomCenter,,0,0,0,,so what about all
Dialogue: 0,0:16:41.47,0:16:45.66,BottomCenter,,0,0,0,,well let's say I have a range five
Dialogue: 0,0:16:45.73,0:16:48.16,BottomCenter,,0,0,0,,and I want to ask is it the case
Dialogue: 0,0:16:48.37,0:16:50.50,BottomCenter,,0,0,0,,that x is less than five
Dialogue: 0,0:16:51.33,0:16:53.20,BottomCenter,,0,0,0,,for x in range five
Dialogue: 0,0:16:53.47,0:16:55.60,BottomCenter,,0,0,0,,I'd get true true true true true
Dialogue: 0,0:16:55.79,0:16:58.57,BottomCenter,,0,0,0,,the goal of all is to aggregate those together
Dialogue: 0,0:16:58.79,0:17:00.97,BottomCenter,,0,0,0,,and tell me whether they're all true or not
Dialogue: 0,0:17:02.29,0:17:05.52,BottomCenter,,0,0,0,,I don't have to pass it a list of poolian values
Dialogue: 0,0:17:05.56,0:17:08.59,BottomCenter,,0,0,0,,I could pass it the list of numbers zero one
Dialogue: 0,0:17:08.59,0:17:09.97,BottomCenter,,0,0,0,,two three and four
Dialogue: 0,0:17:10.09,0:17:12.32,BottomCenter,,0,0,0,,and it would tell me that since zero is false
Dialogue: 0,0:17:12.32,0:17:14.09,BottomCenter,,0,0,0,,these are not all true values
Dialogue: 0,0:17:15.93,0:17:16.90,BottomCenter,,0,0,0,,so those are
Dialogue: 0,0:17:16.93,0:17:20.97,BottomCenter,,0,0,0,,three built in functions that operate on sequences
Dialogue: 0,0:17:20.97,0:17:23.56,BottomCenter,,0,0,0,,there's also min and there's any
Dialogue: 0,0:17:23.76,0:17:26.40,BottomCenter,,0,0,0,,which are complements to max and all
Dialogue: 0,0:17:29.73,0:17:33.32,BottomCenter,,0,0,0,,trees are an important data abstraction
Dialogue: 0,0:17:33.47,0:17:37.00,BottomCenter,,0,0,0,,for representing hierarchical relationships
Dialogue: 0,0:17:38.29,0:17:41.36,BottomCenter,,0,0,0,,we've drawn pictures of trees before
Dialogue: 0,0:17:42.06,0:17:44.26,BottomCenter,,0,0,0,,and discussed how in computer science
Dialogue: 0,0:17:44.26,0:17:46.06,BottomCenter,,0,0,0,,they grow upside out
Dialogue: 0,0:17:47.76,0:17:51.00,BottomCenter,,0,0,0,,now we'll talk about the common vocabulary
Dialogue: 0,0:17:51.00,0:17:53.17,BottomCenter,,0,0,0,,used to describe trees
Dialogue: 0,0:17:53.93,0:17:55.09,BottomCenter,,0,0,0,,there are in fact
Dialogue: 0,0:17:55.09,0:17:58.17,BottomCenter,,0,0,0,,two different metaphors used regularly
Dialogue: 0,0:17:58.50,0:18:02.17,BottomCenter,,0,0,0,,the first is the recursive description of trees
Dialogue: 0,0:18:02.29,0:18:05.79,BottomCenter,,0,0,0,,where a tree is like a wooden tree like an apple tree
Dialogue: 0,0:18:06.93,0:18:07.93,BottomCenter,,0,0,0,,in this description
Dialogue: 0,0:18:07.93,0:18:11.59,BottomCenter,,0,0,0,,a tree has a root label and a list of branches
Dialogue: 0,0:18:11.59,0:18:12.97,BottomCenter,,0,0,0,,there's the root label
Dialogue: 0,0:18:13.09,0:18:14.32,BottomCenter,,0,0,0,,there's a branch
Dialogue: 0,0:18:14.32,0:18:16.73,BottomCenter,,0,0,0,,there are only two branches to this tree
Dialogue: 0,0:18:16.76,0:18:18.93,BottomCenter,,0,0,0,,and the other branches here to the right
Dialogue: 0,0:18:20.17,0:18:23.17,BottomCenter,,0,0,0,,by the way each branch is a tree
Dialogue: 0,0:18:24.26,0:18:27.52,BottomCenter,,0,0,0,,that means the branch has a root label as well
Dialogue: 0,0:18:28.50,0:18:31.70,BottomCenter,,0,0,0,,a tree with zero branches is called a leaf
Dialogue: 0,0:18:32.06,0:18:34.00,BottomCenter,,0,0,0,,so there's a leaf with no branches
Dialogue: 0,0:18:34.00,0:18:36.26,BottomCenter,,0,0,0,,it does have a root label of its own
Dialogue: 0,0:18:38.47,0:18:41.73,BottomCenter,,0,0,0,,now once you've constructed a tree recursively
Dialogue: 0,0:18:41.73,0:18:43.47,BottomCenter,,0,0,0,,you might want to describe certain
Dialogue: 0,0:18:43.47,0:18:45.67,BottomCenter,,0,0,0,,locations within the tree
Dialogue: 0,0:18:46.29,0:18:49.20,BottomCenter,,0,0,0,,and so we say in the relative description
Dialogue: 0,0:18:49.32,0:18:50.93,BottomCenter,,0,0,0,,about family trees
Dialogue: 0,0:18:50.93,0:18:54.06,BottomCenter,,0,0,0,,that each location in a tree is called a node
Dialogue: 0,0:18:54.40,0:18:56.97,BottomCenter,,0,0,0,,so here are all the nodes I've circled them
Dialogue: 0,0:18:57.97,0:19:02.17,BottomCenter,,0,0,0,,and this is the root or the root node at the top
Dialogue: 0,0:19:03.56,0:19:06.76,BottomCenter,,0,0,0,,each node has a label that can be any value
Dialogue: 0,0:19:07.20,0:19:09.36,BottomCenter,,0,0,0,,so the data stored within the tree
Dialogue: 0,0:19:09.40,0:19:11.36,BottomCenter,,0,0,0,,are stored at the labels
Dialogue: 0,0:19:13.36,0:19:16.50,BottomCenter,,0,0,0,,now the reason I call this a family tree relative
Dialogue: 0,0:19:16.50,0:19:17.36,BottomCenter,,0,0,0,,description
Dialogue: 0,0:19:17.36,0:19:20.52,BottomCenter,,0,0,0,,is that one node can be the parent or child of another
Dialogue: 0,0:19:21.06,0:19:23.36,BottomCenter,,0,0,0,,so we can say that this node containing two
Dialogue: 0,0:19:23.36,0:19:26.36,BottomCenter,,0,0,0,,is the child of that root node containing three
Dialogue: 0,0:19:27.52,0:19:31.70,BottomCenter,,0,0,0,,and you can also describe other familial relationships
Dialogue: 0,0:19:31.79,0:19:35.70,BottomCenter,,0,0,0,,such as ancestors and descendants and siblings
Dialogue: 0,0:19:37.93,0:19:40.59,BottomCenter,,0,0,0,,by the way people often refer to the label
Dialogue: 0,0:19:40.59,0:19:43.29,BottomCenter,,0,0,0,,values themselves by their locations
Dialogue: 0,0:19:43.29,0:19:44.20,BottomCenter,,0,0,0,,so something like
Dialogue: 0,0:19:44.20,0:19:46.76,BottomCenter,,0,0,0,,each parent is the sum of its children
Dialogue: 0,0:19:46.90,0:19:49.59,BottomCenter,,0,0,0,,which is true of a fibonacci tree
Dialogue: 0,0:19:52.86,0:19:54.67,BottomCenter,,0,0,0,,now that we can talk about trees
Dialogue: 0,0:19:54.67,0:19:57.73,BottomCenter,,0,0,0,,we can talk about implementing the tree abstraction
Dialogue: 0,0:19:58.59,0:20:01.52,BottomCenter,,0,0,0,,a tree has a root label in a list of branches
Dialogue: 0,0:20:01.52,0:20:05.26,BottomCenter,,0,0,0,,and the constructor is going to take close to values
Dialogue: 0,0:20:05.67,0:20:07.73,BottomCenter,,0,0,0,,each branch must be a tree
Dialogue: 0,0:20:08.56,0:20:08.73,BottomCenter,,0,0,0,,so
Dialogue: 0,0:20:08.73,0:20:11.93,BottomCenter,,0,0,0,,if I want to construct a representation for this small
Dialogue: 0,0:20:11.93,0:20:14.90,BottomCenter,,0,0,0,,tree I would write the following code
Dialogue: 0,0:20:14.90,0:20:17.40,BottomCenter,,0,0,0,,it's a tree where the root label is three
Dialogue: 0,0:20:17.52,0:20:20.26,BottomCenter,,0,0,0,,and the branches are a tree with one
Dialogue: 0,0:20:20.26,0:20:22.40,BottomCenter,,0,0,0,,and a tree with a 2 1 1
Dialogue: 0,0:20:23.70,0:20:24.40,BottomCenter,,0,0,0,,in this case
Dialogue: 0,0:20:24.40,0:20:27.29,BottomCenter,,0,0,0,,I'm using the constructor as I've described it
Dialogue: 0,0:20:27.40,0:20:30.76,BottomCenter,,0,0,0,,so that I can change representations however I wish
Dialogue: 0,0:20:31.97,0:20:33.20,BottomCenter,,0,0,0,,now you might say
Dialogue: 0,0:20:33.70,0:20:36.00,BottomCenter,,0,0,0,,aren't I violating an abstraction barrier
Dialogue: 0,0:20:36.00,0:20:37.59,BottomCenter,,0,0,0,,because I'm using a list
Dialogue: 0,0:20:38.00,0:20:40.06,BottomCenter,,0,0,0,,no it's part of the abstraction
Dialogue: 0,0:20:40.06,0:20:42.90,BottomCenter,,0,0,0,,that a tree has a list of branches
Dialogue: 0,0:20:42.90,0:20:45.76,BottomCenter,,0,0,0,,so it's totally fine that I'm using a list here
Dialogue: 0,0:20:46.06,0:20:48.36,BottomCenter,,0,0,0,,because that's part of the abstraction
Dialogue: 0,0:20:48.40,0:20:50.59,BottomCenter,,0,0,0,,it's not part of the representation
Dialogue: 0,0:20:51.73,0:20:53.52,BottomCenter,,0,0,0,,now let's come up with a representation
Dialogue: 0,0:20:53.52,0:20:55.29,BottomCenter,,0,0,0,,I can come up with anything I want
Dialogue: 0,0:20:55.29,0:20:56.20,BottomCenter,,0,0,0,,and that will determine
Dialogue: 0,0:20:56.20,0:20:58.59,BottomCenter,,0,0,0,,what actually gets printed out by python
Dialogue: 0,0:20:58.76,0:21:03.17,BottomCenter,,0,0,0,,when I evaluate this constructor expression
Dialogue: 0,0:21:03.70,0:21:04.86,BottomCenter,,0,0,0,,here's what we'll get
Dialogue: 0,0:21:05.00,0:21:07.56,BottomCenter,,0,0,0,,it's just some lists within lists with the
Dialogue: 0,0:21:07.79,0:21:10.00,BottomCenter,,0,0,0,,label values emitted within them
Dialogue: 0,0:21:11.17,0:21:13.26,BottomCenter,,0,0,0,,the way we construct this is to define
Dialogue: 0,0:21:13.26,0:21:14.56,BottomCenter,,0,0,0,,a constructor tree
Dialogue: 0,0:21:14.56,0:21:17.00,BottomCenter,,0,0,0,,which takes the label in a list of branches
Dialogue: 0,0:21:17.00,0:21:19.09,BottomCenter,,0,0,0,,by default the list of branches
Dialogue: 0,0:21:19.47,0:21:22.09,BottomCenter,,0,0,0,,by default the list of branches is empty
Dialogue: 0,0:21:22.09,0:21:23.97,BottomCenter,,0,0,0,,so by default I'll get a leaf
Dialogue: 0,0:21:24.09,0:21:26.86,BottomCenter,,0,0,0,,which is why I'm able to call just tree on one
Dialogue: 0,0:21:26.93,0:21:30.47,BottomCenter,,0,0,0,,in order to construct this leaf node here
Dialogue: 0,0:21:30.90,0:21:32.56,BottomCenter,,0,0,0,,I put the label into a list
Dialogue: 0,0:21:32.56,0:21:35.73,BottomCenter,,0,0,0,,branches is already a list and so I sum them together
Dialogue: 0,0:21:36.29,0:21:38.76,BottomCenter,,0,0,0,,the label of a tree is a selector
Dialogue: 0,0:21:38.86,0:21:41.97,BottomCenter,,0,0,0,,that returns the elemented index zero
Dialogue: 0,0:21:42.06,0:21:44.50,BottomCenter,,0,0,0,,in the list representation of the tree
Dialogue: 0,0:21:44.97,0:21:47.40,BottomCenter,,0,0,0,,and the branches are the rest of the list
Dialogue: 0,0:21:47.40,0:21:49.09,BottomCenter,,0,0,0,,elements as a list
Dialogue: 0,0:21:49.76,0:21:51.40,BottomCenter,,0,0,0,,now in order to make sure that
Dialogue: 0,0:21:51.40,0:21:53.40,BottomCenter,,0,0,0,,while I'm using the tree constructor
Dialogue: 0,0:21:53.40,0:21:56.06,BottomCenter,,0,0,0,,I don't build something that's not a tree
Dialogue: 0,0:21:56.13,0:21:58.00,BottomCenter,,0,0,0,,I'm going to add some checks
Dialogue: 0,0:21:58.26,0:22:00.93,BottomCenter,,0,0,0,,the first check here says for branching branches
Dialogue: 0,0:22:00.93,0:22:03.73,BottomCenter,,0,0,0,,assert that the branch is a tree
Dialogue: 0,0:22:04.52,0:22:06.26,BottomCenter,,0,0,0,,as part of the abstraction
Dialogue: 0,0:22:06.47,0:22:09.26,BottomCenter,,0,0,0,,and my code is going to make sure that I obey that
Dialogue: 0,0:22:09.26,0:22:12.06,BottomCenter,,0,0,0,,abstraction as I construct the tree
Dialogue: 0,0:22:12.97,0:22:14.26,BottomCenter,,0,0,0,,I'm also going to call
Dialogue: 0,0:22:14.26,0:22:17.13,BottomCenter,,0,0,0,,list on branches instead of just saying
Dialogue: 0,0:22:17.20,0:22:19.59,BottomCenter,,0,0,0,,label in a list plus branches
Dialogue: 0,0:22:19.73,0:22:21.17,BottomCenter,,0,0,0,,in order to make sure
Dialogue: 0,0:22:21.26,0:22:24.32,BottomCenter,,0,0,0,,that if I pass in some other kind of sequence
Dialogue: 0,0:22:24.40,0:22:26.40,BottomCenter,,0,0,0,,it gets converted to a list
Dialogue: 0,0:22:26.59,0:22:29.20,BottomCenter,,0,0,0,,before adding to another list
Dialogue: 0,0:22:30.09,0:22:32.36,BottomCenter,,0,0,0,,so these two lines are really just there to verify
Dialogue: 0,0:22:32.36,0:22:34.93,BottomCenter,,0,0,0,,that the tree definition is being respected
Dialogue: 0,0:22:35.06,0:22:37.79,BottomCenter,,0,0,0,,within the body of whatever program I write
Dialogue: 0,0:22:38.93,0:22:41.20,BottomCenter,,0,0,0,,how do we know if a branch is a tree
Dialogue: 0,0:22:41.20,0:22:43.26,BottomCenter,,0,0,0,,well for anything to be a tree
Dialogue: 0,0:22:43.52,0:22:45.09,BottomCenter,,0,0,0,,it has to be a list
Dialogue: 0,0:22:45.17,0:22:48.06,BottomCenter,,0,0,0,,it has to have at least one element for the label
Dialogue: 0,0:22:48.76,0:22:51.26,BottomCenter,,0,0,0,,so if that's not true will return falls
Dialogue: 0,0:22:51.52,0:22:53.67,BottomCenter,,0,0,0,,and it has to be the case that all the branches are
Dialogue: 0,0:22:53.67,0:22:54.20,BottomCenter,,0,0,0,,trees
Dialogue: 0,0:22:54.20,0:22:58.47,BottomCenter,,0,0,0,,so in fact is tree is a tree recruited function itself
Dialogue: 0,0:22:58.56,0:23:01.06,BottomCenter,,0,0,0,,that goes through every branch in the branches of the
Dialogue: 0,0:23:01.06,0:23:03.09,BottomCenter,,0,0,0,,tree if it's not a
Dialogue: 0,0:23:03.56,0:23:04.79,BottomCenter,,0,0,0,,tree that branch
Dialogue: 0,0:23:04.79,0:23:07.47,BottomCenter,,0,0,0,,then the whole thing can't possibly be a tree
Dialogue: 0,0:23:07.76,0:23:10.90,BottomCenter,,0,0,0,,if these two techs pass then it must be a tree
Dialogue: 0,0:23:11.73,0:23:12.93,BottomCenter,,0,0,0,,because it has a label
Dialogue: 0,0:23:12.93,0:23:15.29,BottomCenter,,0,0,0,,and it has branches that are trees
Dialogue: 0,0:23:16.52,0:23:17.09,BottomCenter,,0,0,0,,finally
Dialogue: 0,0:23:17.09,0:23:19.56,BottomCenter,,0,0,0,,I'll add one more function to my tree abstraction
Dialogue: 0,0:23:19.56,0:23:21.47,BottomCenter,,0,0,0,,which is a check to see
Dialogue: 0,0:23:21.56,0:23:24.26,BottomCenter,,0,0,0,,if a tree is in fact just a leaf
Dialogue: 0,0:23:24.52,0:23:27.79,BottomCenter,,0,0,0,,which checks that the branches are empty
Dialogue: 0,0:23:28.06,0:23:30.79,BottomCenter,,0,0,0,,if I call branches on tree and get back on empty list
Dialogue: 0,0:23:30.79,0:23:32.06,BottomCenter,,0,0,0,,that's a false value
Dialogue: 0,0:23:32.06,0:23:34.73,BottomCenter,,0,0,0,,so not branches tree will be a true value
Dialogue: 0,0:23:34.79,0:23:37.56,BottomCenter,,0,0,0,,just as long as this tree has no branches
Dialogue: 0,0:23:38.32,0:23:41.00,BottomCenter,,0,0,0,,now that we have the code for our data abstraction
Dialogue: 0,0:23:41.00,0:23:42.13,BottomCenter,,0,0,0,,we can use it
Dialogue: 0,0:23:42.76,0:23:45.47,BottomCenter,,0,0,0,,we can create a tree that's just a leaf
Dialogue: 0,0:23:45.73,0:23:48.56,BottomCenter,,0,0,0,,is it a leaf oh yes it is
Dialogue: 0,0:23:49.56,0:23:52.93,BottomCenter,,0,0,0,,if I want to create a tree with branches
Dialogue: 0,0:23:53.13,0:23:55.90,BottomCenter,,0,0,0,,then I specify those branches in a list
Dialogue: 0,0:23:55.90,0:23:58.73,BottomCenter,,0,0,0,,because every tree should have a list of branches
Dialogue: 0,0:23:58.73,0:24:00.73,BottomCenter,,0,0,0,,which by default is empty
Dialogue: 0,0:24:01.56,0:24:04.13,BottomCenter,,0,0,0,,now if I just put a single value in here
Dialogue: 0,0:24:04.13,0:24:05.32,BottomCenter,,0,0,0,,I'm going to get an error
Dialogue: 0,0:24:05.32,0:24:07.67,BottomCenter,,0,0,0,,that say branches must be trees
Dialogue: 0,0:24:07.97,0:24:10.56,BottomCenter,,0,0,0,,it must be the case that when I construct this
Dialogue: 0,0:24:10.70,0:24:14.56,BottomCenter,,0,0,0,,everything I put in the branches list is itself a tree
Dialogue: 0,0:24:15.76,0:24:19.36,BottomCenter,,0,0,0,,if I want a tree with branches to be one of my branches
Dialogue: 0,0:24:19.36,0:24:21.47,BottomCenter,,0,0,0,,then I give branches to that tree
Dialogue: 0,0:24:22.17,0:24:24.20,BottomCenter,,0,0,0,,and in this case we'll just put a leaf
Dialogue: 0,0:24:25.00,0:24:27.56,BottomCenter,,0,0,0,,so I finished the tree rooted at five
Dialogue: 0,0:24:28.00,0:24:31.29,BottomCenter,,0,0,0,,I want another branch which is a single leaf
Dialogue: 0,0:24:31.32,0:24:32.97,BottomCenter,,0,0,0,,rooted by six
Dialogue: 0,0:24:33.26,0:24:35.97,BottomCenter,,0,0,0,,now I've listed all the branches for the tree
Dialogue: 0,0:24:36.13,0:24:37.36,BottomCenter,,0,0,0,,and there's the tree
Dialogue: 0,0:24:38.59,0:24:39.76,BottomCenter,,0,0,0,,notice that when I
Dialogue: 0,0:24:39.93,0:24:42.13,BottomCenter,,0,0,0,,evaluated this constructor expression
Dialogue: 0,0:24:42.13,0:24:43.40,BottomCenter,,0,0,0,,there were no errors
Dialogue: 0,0:24:43.40,0:24:45.47,BottomCenter,,0,0,0,,because I've built a well formed tree
Dialogue: 0,0:24:46.00,0:24:47.36,BottomCenter,,0,0,0,,now it happens to be
Dialogue: 0,0:24:47.47,0:24:51.09,BottomCenter,,0,0,0,,that it has this complicated nested representation
Dialogue: 0,0:24:51.40,0:24:53.59,BottomCenter,,0,0,0,,but that's not how I will access it
Dialogue: 0,0:24:53.67,0:24:56.67,BottomCenter,,0,0,0,,and said I'll just ask what's the label of t
Dialogue: 0,0:24:56.90,0:24:57.79,BottomCenter,,0,0,0,,it's one
Dialogue: 0,0:24:58.52,0:25:00.73,BottomCenter,,0,0,0,,what's the branches of t
Dialogue: 0,0:25:01.59,0:25:03.13,BottomCenter,,0,0,0,,while a bunch of trees
Dialogue: 0,0:25:03.13,0:25:04.97,BottomCenter,,0,0,0,,if I want to get the
Dialogue: 0,0:25:05.20,0:25:08.06,BottomCenter,,0,0,0,,branch of index zero then I just write that
Dialogue: 0,0:25:08.13,0:25:09.26,BottomCenter,,0,0,0,,that's a tree
Dialogue: 0,0:25:09.56,0:25:12.36,BottomCenter,,0,0,0,,and I can get the root label of that branch
Dialogue: 0,0:25:12.36,0:25:14.20,BottomCenter,,0,0,0,,just by asking for the label
Dialogue: 0,0:25:14.47,0:25:16.86,BottomCenter,,0,0,0,,of the index zero branch
Dialogue: 0,0:25:17.26,0:25:19.06,BottomCenter,,0,0,0,,by treating branches as a list
Dialogue: 0,0:25:19.06,0:25:21.76,BottomCenter,,0,0,0,,I'm not violating any abstraction barrier
Dialogue: 0,0:25:21.90,0:25:24.00,BottomCenter,,0,0,0,,because I said in my abstraction
Dialogue: 0,0:25:24.09,0:25:26.36,BottomCenter,,0,0,0,,that a tree has a list of branches
Dialogue: 0,0:25:28.79,0:25:32.06,BottomCenter,,0,0,0,,functions that take trees as input
Dialogue: 0,0:25:32.13,0:25:34.73,BottomCenter,,0,0,0,,or return trees as output
Dialogue: 0,0:25:35.06,0:25:38.36,BottomCenter,,0,0,0,,are often tree recursive themselves
Dialogue: 0,0:25:39.50,0:25:41.67,BottomCenter,,0,0,0,,let's look at some examples
Dialogue: 0,0:25:42.40,0:25:44.86,BottomCenter,,0,0,0,,in practice one does not often
Dialogue: 0,0:25:44.86,0:25:47.59,BottomCenter,,0,0,0,,create trees using the tree constructor
Dialogue: 0,0:25:47.59,0:25:49.76,BottomCenter,,0,0,0,,and a set of explicit labels
Dialogue: 0,0:25:49.93,0:25:53.17,BottomCenter,,0,0,0,,but instead generates the tree programmatically
Dialogue: 0,0:25:53.67,0:25:56.73,BottomCenter,,0,0,0,,for example if I want to create a function
Dialogue: 0,0:25:56.97,0:25:59.50,BottomCenter,,0,0,0,,that builds a fibonacci tree
Dialogue: 0,0:25:59.73,0:26:02.00,BottomCenter,,0,0,0,,then I would write it in the following way
Dialogue: 0,0:26:02.86,0:26:05.26,BottomCenter,,0,0,0,,if n is less than equal to one
Dialogue: 0,0:26:05.52,0:26:09.50,BottomCenter,,0,0,0,,that means the fib tree for that n is just a leaf
Dialogue: 0,0:26:10.26,0:26:13.06,BottomCenter,,0,0,0,,I create the leaf using my tree constructor
Dialogue: 0,0:26:14.52,0:26:15.32,BottomCenter,,0,0,0,,otherwise
Dialogue: 0,0:26:15.73,0:26:19.29,BottomCenter,,0,0,0,,I need to build the two branches of a fibonacci tree
Dialogue: 0,0:26:19.50,0:26:21.70,BottomCenter,,0,0,0,,the left branch and the right branch
Dialogue: 0,0:26:22.13,0:26:24.06,BottomCenter,,0,0,0,,are both going to be constructed
Dialogue: 0,0:26:24.13,0:26:26.56,BottomCenter,,0,0,0,,with recursive calls to fib tree
Dialogue: 0,0:26:31.59,0:26:33.76,BottomCenter,,0,0,0,,finally I want to return a tree
Dialogue: 0,0:26:34.90,0:26:37.06,BottomCenter,,0,0,0,,that means coloring the tree constructor
Dialogue: 0,0:26:37.29,0:26:38.86,BottomCenter,,0,0,0,,on some label value
Dialogue: 0,0:26:38.90,0:26:42.26,BottomCenter,,0,0,0,,and the branches the branches are placed into a list
Dialogue: 0,0:26:43.56,0:26:45.32,BottomCenter,,0,0,0,,and what about the label value
Dialogue: 0,0:26:45.52,0:26:48.73,BottomCenter,,0,0,0,,while here I apply the fibonacci recurrence
Dialogue: 0,0:26:49.09,0:26:51.17,BottomCenter,,0,0,0,,I get the label of the left tree
Dialogue: 0,0:26:51.17,0:26:53.56,BottomCenter,,0,0,0,,and add it to the label of the right tree
Dialogue: 0,0:26:55.52,0:26:58.67,BottomCenter,,0,0,0,,the base case of fibtree one or fibtree zero
Dialogue: 0,0:26:58.67,0:26:59.86,BottomCenter,,0,0,0,,is just a leaf
Dialogue: 0,0:27:00.36,0:27:03.56,BottomCenter,,0,0,0,,fibtree 2 has structure within it
Dialogue: 0,0:27:03.90,0:27:05.00,BottomCenter,,0,0,0,,it's the label
Dialogue: 0,0:27:05.13,0:27:08.40,BottomCenter,,0,0,0,,and has two branches which are both leaves
Dialogue: 0,0:27:09.13,0:27:10.29,BottomCenter,,0,0,0,,fib tree four
Dialogue: 0,0:27:10.59,0:27:12.09,BottomCenter,,0,0,0,,is the fibonacci tree
Dialogue: 0,0:27:12.09,0:27:14.86,BottomCenter,,0,0,0,,that we've been looking at in examples so far
Dialogue: 0,0:27:15.56,0:27:16.52,BottomCenter,,0,0,0,,so its label
Dialogue: 0,0:27:17.29,0:27:22.73,BottomCenter,,0,0,0,,is three and then it has how many leaves 1 2 3 4 5
Dialogue: 0,0:27:22.73,0:27:23.90,BottomCenter,,0,0,0,,different leaves
Dialogue: 0,0:27:25.36,0:27:28.13,BottomCenter,,0,0,0,,often times we'll write functions that take in
Dialogue: 0,0:27:28.13,0:27:30.17,BottomCenter,,0,0,0,,trees and do interesting things with them
Dialogue: 0,0:27:31.00,0:27:33.00,BottomCenter,,0,0,0,,here's a not so interesting thing
Dialogue: 0,0:27:33.06,0:27:34.52,BottomCenter,,0,0,0,,as a simple example
Dialogue: 0,0:27:34.90,0:27:37.59,BottomCenter,,0,0,0,,if I want to count the leaves in a tree t
Dialogue: 0,0:27:38.20,0:27:41.06,BottomCenter,,0,0,0,,I'm going to write a tree recursive function
Dialogue: 0,0:27:41.76,0:27:43.40,BottomCenter,,0,0,0,,processing a leaf of a tree
Dialogue: 0,0:27:43.40,0:27:46.59,BottomCenter,,0,0,0,,is off to the base case of a tree processing function
Dialogue: 0,0:27:47.09,0:27:50.90,BottomCenter,,0,0,0,,here if t is only a leaf and I count the leaves
Dialogue: 0,0:27:50.90,0:27:51.86,BottomCenter,,0,0,0,,there's one leaf
Dialogue: 0,0:27:52.93,0:27:55.70,BottomCenter,,0,0,0,,the recursive case typically makes a recursive call
Dialogue: 0,0:27:55.70,0:27:56.90,BottomCenter,,0,0,0,,on each branch
Dialogue: 0,0:27:57.09,0:27:59.40,BottomCenter,,0,0,0,,then aggregates the results
Dialogue: 0,0:28:00.67,0:28:02.20,BottomCenter,,0,0,0,,in this case what we're going to do
Dialogue: 0,0:28:02.20,0:28:05.40,BottomCenter,,0,0,0,,is take each branch in the branches of the tree
Dialogue: 0,0:28:05.40,0:28:07.59,BottomCenter,,0,0,0,,and count the leaves in each branch
Dialogue: 0,0:28:08.09,0:28:09.67,BottomCenter,,0,0,0,,the leaves in the total tree
Dialogue: 0,0:28:09.67,0:28:12.40,BottomCenter,,0,0,0,,are just all the leaves in the branches summed up
Dialogue: 0,0:28:14.32,0:28:16.56,BottomCenter,,0,0,0,,there's our first tree processing function
Dialogue: 0,0:28:19.29,0:28:21.00,BottomCenter,,0,0,0,,let's walk through it one more time
Dialogue: 0,0:28:21.00,0:28:22.09,BottomCenter,,0,0,0,,the t comes in
Dialogue: 0,0:28:22.09,0:28:25.06,BottomCenter,,0,0,0,,I don't know if it's a large tree or a small tree
Dialogue: 0,0:28:25.17,0:28:27.93,BottomCenter,,0,0,0,,if in the simplest case it's just a leaf
Dialogue: 0,0:28:28.13,0:28:31.13,BottomCenter,,0,0,0,,then I know it to do I just say there's one leaf
Dialogue: 0,0:28:31.67,0:28:32.47,BottomCenter,,0,0,0,,otherwise
Dialogue: 0,0:28:32.97,0:28:34.76,BottomCenter,,0,0,0,,I sum up all
Dialogue: 0,0:28:34.76,0:28:36.50,BottomCenter,,0,0,0,,of the results of making
Dialogue: 0,0:28:36.50,0:28:39.40,BottomCenter,,0,0,0,,recursive calls on each of the branches
Dialogue: 0,0:28:40.20,0:28:41.67,BottomCenter,,0,0,0,,count leaves
Dialogue: 0,0:28:42.32,0:28:46.32,BottomCenter,,0,0,0,,b for b in the branches of the tree
Dialogue: 0,0:28:47.76,0:28:50.56,BottomCenter,,0,0,0,,so what's particular about the count leaves function
Dialogue: 0,0:28:50.59,0:28:52.70,BottomCenter,,0,0,0,,is what it returns in the base case
Dialogue: 0,0:28:52.79,0:28:55.73,BottomCenter,,0,0,0,,and how it aggregates its recursive calls
Dialogue: 0,0:28:56.17,0:28:58.90,BottomCenter,,0,0,0,,and of course don't forget to return that result
Dialogue: 0,0:29:00.13,0:29:02.70,BottomCenter,,0,0,0,,we saw before that fib tree four
Dialogue: 0,0:29:03.26,0:29:04.76,BottomCenter,,0,0,0,,has five leaves
Dialogue: 0,0:29:04.86,0:29:07.06,BottomCenter,,0,0,0,,and let's make sure that our count leaves function
Dialogue: 0,0:29:07.06,0:29:08.32,BottomCenter,,0,0,0,,returns five
Dialogue: 0,0:29:08.32,0:29:09.32,BottomCenter,,0,0,0,,it does
Dialogue: 0,0:29:10.00,0:29:12.93,BottomCenter,,0,0,0,,now by the way fib trees get pretty large
Dialogue: 0,0:29:12.93,0:29:17.06,BottomCenter,,0,0,0,,fib tree 10 which has fibonacci No.10 at the top
Dialogue: 0,0:29:17.47,0:29:18.79,BottomCenter,,0,0,0,,has lots of leaves
Dialogue: 0,0:29:18.79,0:29:20.13,BottomCenter,,0,0,0,,how many leaves
Dialogue: 0,0:29:20.26,0:29:21.17,BottomCenter,,0,0,0,,let's count
Dialogue: 0,0:29:22.47,0:29:24.00,BottomCenter,,0,0,0,,89 leaves
Dialogue: 0,0:29:24.29,0:29:28.67,BottomCenter,,0,0,0,,an interesting fact is that 89 is fibonacci No.11
Dialogue: 0,0:29:30.97,0:29:32.59,BottomCenter,,0,0,0,,here's a discussion question
Dialogue: 0,0:29:33.26,0:29:34.52,BottomCenter,,0,0,0,,implement leaves
Dialogue: 0,0:29:34.52,0:29:38.00,BottomCenter,,0,0,0,,which returns a list of the leaf labels of a tree
Dialogue: 0,0:29:39.20,0:29:41.73,BottomCenter,,0,0,0,,so how does it work it takes in some tree
Dialogue: 0,0:29:42.56,0:29:44.36,BottomCenter,,0,0,0,,and you call leaves on it
Dialogue: 0,0:29:44.36,0:29:46.59,BottomCenter,,0,0,0,,and it gives you all the values of the leaves
Dialogue: 0,0:29:46.59,0:29:49.50,BottomCenter,,0,0,0,,so notice that the root label three is not in here
Dialogue: 0,0:29:49.56,0:29:51.17,BottomCenter,,0,0,0,,only the leaf labels
Dialogue: 0,0:29:52.09,0:29:54.26,BottomCenter,,0,0,0,,in order to implement this function
Dialogue: 0,0:29:54.50,0:29:57.32,BottomCenter,,0,0,0,,we're going to use effect about some
Dialogue: 0,0:29:57.70,0:30:01.26,BottomCenter,,0,0,0,,which is that if you some a list of lists
Dialogue: 0,0:30:01.26,0:30:02.52,BottomCenter,,0,0,0,,you get a list
Dialogue: 0,0:30:02.52,0:30:03.26,BottomCenter,,0,0,0,,containing the
Dialogue: 0,0:30:03.26,0:30:06.47,BottomCenter,,0,0,0,,elements of all of the lists in the input
Dialogue: 0,0:30:06.97,0:30:08.86,BottomCenter,,0,0,0,,let me show you some examples
Dialogue: 0,0:30:09.36,0:30:12.73,BottomCenter,,0,0,0,,if you sum the lists one two three and four
Dialogue: 0,0:30:13.13,0:30:16.17,BottomCenter,,0,0,0,,you get one list containing one two three and four
Dialogue: 0,0:30:17.09,0:30:18.56,BottomCenter,,0,0,0,,in order to call some
Dialogue: 0,0:30:18.56,0:30:19.93,BottomCenter,,0,0,0,,on a list of lists
Dialogue: 0,0:30:19.93,0:30:23.13,BottomCenter,,0,0,0,,and have it aggregate all of the values in those lists
Dialogue: 0,0:30:23.13,0:30:25.29,BottomCenter,,0,0,0,,you have to provide a starting value
Dialogue: 0,0:30:25.52,0:30:26.97,BottomCenter,,0,0,0,,of an empty list
Dialogue: 0,0:30:27.97,0:30:31.50,BottomCenter,,0,0,0,,if I sum a list with one I get a list with one
Dialogue: 0,0:30:31.97,0:30:34.20,BottomCenter,,0,0,0,,if I sum a list
Dialogue: 0,0:30:34.59,0:30:36.70,BottomCenter,,0,0,0,,that has two elements
Dialogue: 0,0:30:36.70,0:30:40.52,BottomCenter,,0,0,0,,and the first element is a list within a list
Dialogue: 0,0:30:41.06,0:30:41.32,BottomCenter,,0,0,0,,then
Dialogue: 0,0:30:41.32,0:30:44.00,BottomCenter,,0,0,0,,what I'm going to get is still a list within a list
Dialogue: 0,0:30:44.00,0:30:45.09,BottomCenter,,0,0,0,,in the output
Dialogue: 0,0:30:45.17,0:30:46.09,BottomCenter,,0,0,0,,notice the difference
Dialogue: 0,0:30:46.09,0:30:48.13,BottomCenter,,0,0,0,,between this structure and that structure
Dialogue: 0,0:30:48.32,0:30:50.59,BottomCenter,,0,0,0,,one was a value in the output
Dialogue: 0,0:30:50.59,0:30:54.40,BottomCenter,,0,0,0,,in this case a list containing one is a value here
Dialogue: 0,0:30:54.73,0:30:57.56,BottomCenter,,0,0,0,,so it's not enough just to sum the whole tree
Dialogue: 0,0:30:57.56,0:30:59.70,BottomCenter,,0,0,0,,and get all the labels within it
Dialogue: 0,0:30:59.76,0:31:00.52,BottomCenter,,0,0,0,,because
Dialogue: 0,0:31:00.52,0:31:03.36,BottomCenter,,0,0,0,,some doesn't remove all of the nested structure
Dialogue: 0,0:31:03.36,0:31:05.29,BottomCenter,,0,0,0,,it just gets rid of one level
Dialogue: 0,0:31:07.09,0:31:10.40,BottomCenter,,0,0,0,,okay here is the implementation of the tree processing
Dialogue: 0,0:31:10.40,0:31:13.06,BottomCenter,,0,0,0,,function that takes in some tree
Dialogue: 0,0:31:13.56,0:31:16.79,BottomCenter,,0,0,0,,and returns a list of the leaf labels
Dialogue: 0,0:31:17.86,0:31:19.00,BottomCenter,,0,0,0,,if it's a leaf
Dialogue: 0,0:31:19.29,0:31:20.50,BottomCenter,,0,0,0,,then we get the label
Dialogue: 0,0:31:20.86,0:31:22.59,BottomCenter,,0,0,0,,and put it in a list
Dialogue: 0,0:31:23.09,0:31:25.47,BottomCenter,,0,0,0,,otherwise we sum up something
Dialogue: 0,0:31:26.40,0:31:28.32,BottomCenter,,0,0,0,,here are eight alternatives
Dialogue: 0,0:31:28.76,0:31:31.76,BottomCenter,,0,0,0,,I recommend that you pause and think about it
Dialogue: 0,0:31:31.93,0:31:36.26,BottomCenter,,0,0,0,,I'm going to show you the answer in 321
Dialogue: 0,0:31:37.36,0:31:39.00,BottomCenter,,0,0,0,,our goal is to
Dialogue: 0,0:31:39.06,0:31:42.56,BottomCenter,,0,0,0,,get a list of leaf labels for each branch
Dialogue: 0,0:31:42.59,0:31:44.00,BottomCenter,,0,0,0,,and then put them all
Dialogue: 0,0:31:44.09,0:31:47.47,BottomCenter,,0,0,0,,into one long list of all the leaf labels
Dialogue: 0,0:31:48.00,0:31:50.70,BottomCenter,,0,0,0,,we get that by summing a recursive call
Dialogue: 0,0:31:50.70,0:31:52.06,BottomCenter,,0,0,0,,to the leaves of b
Dialogue: 0,0:31:52.06,0:31:54.73,BottomCenter,,0,0,0,,for every b in the branches of the tree
Dialogue: 0,0:31:56.09,0:31:59.40,BottomCenter,,0,0,0,,so this is almost identical to count leaves
Dialogue: 0,0:31:59.52,0:32:01.73,BottomCenter,,0,0,0,,except for we have a different base case
Dialogue: 0,0:32:01.86,0:32:03.52,BottomCenter,,0,0,0,,and a different use of some
Dialogue: 0,0:32:03.59,0:32:05.76,BottomCenter,,0,0,0,,meaning a different way of aggregating
Dialogue: 0,0:32:05.76,0:32:08.97,BottomCenter,,0,0,0,,the return values of the recursive calls
Dialogue: 0,0:32:09.90,0:32:12.56,BottomCenter,,0,0,0,,a function that creates a tree from another tree is
Dialogue: 0,0:32:12.56,0:32:14.56,BottomCenter,,0,0,0,,typically also recursive
Dialogue: 0,0:32:15.06,0:32:17.50,BottomCenter,,0,0,0,,so for example if I have a tree
Dialogue: 0,0:32:17.52,0:32:19.06,BottomCenter,,0,0,0,,maybe it's a fibonacci tree
Dialogue: 0,0:32:19.06,0:32:20.56,BottomCenter,,0,0,0,,maybe it's something different
Dialogue: 0,0:32:20.76,0:32:23.50,BottomCenter,,0,0,0,,and what I'd like to do is return a new tree that has
Dialogue: 0,0:32:23.50,0:32:25.56,BottomCenter,,0,0,0,,exactly the same structure
Dialogue: 0,0:32:25.86,0:32:28.70,BottomCenter,,0,0,0,,but the leaf labels have been incremented
Dialogue: 0,0:32:29.20,0:32:31.79,BottomCenter,,0,0,0,,then I'll write a tree recursive function
Dialogue: 0,0:32:31.79,0:32:33.67,BottomCenter,,0,0,0,,to build the new tree
Dialogue: 0,0:32:34.09,0:32:37.32,BottomCenter,,0,0,0,,if I'm building a tree that's only a leaf
Dialogue: 0,0:32:37.67,0:32:39.13,BottomCenter,,0,0,0,,I get the label
Dialogue: 0,0:32:39.97,0:32:41.50,BottomCenter,,0,0,0,,I add one to it
Dialogue: 0,0:32:41.86,0:32:43.67,BottomCenter,,0,0,0,,and then I need to return a tree
Dialogue: 0,0:32:43.67,0:32:46.09,BottomCenter,,0,0,0,,because that's what increment leaves does
Dialogue: 0,0:32:46.29,0:32:50.32,BottomCenter,,0,0,0,,so a quick check is that I do have the right range here
Dialogue: 0,0:32:50.32,0:32:52.70,BottomCenter,,0,0,0,,I'm returning trees just like I should
Dialogue: 0,0:32:53.67,0:32:56.79,BottomCenter,,0,0,0,,in this case we return a leaf because we got a leaf in
Dialogue: 0,0:32:57.40,0:33:01.06,BottomCenter,,0,0,0,,if I have been given a tree that is not a leaf
Dialogue: 0,0:33:01.17,0:33:01.97,BottomCenter,,0,0,0,,then I need to
Dialogue: 0,0:33:01.97,0:33:05.47,BottomCenter,,0,0,0,,increment the leaves in all the branches of that tree
Dialogue: 0,0:33:06.06,0:33:09.90,BottomCenter,,0,0,0,,and then build a new tree with those new branches
Dialogue: 0,0:33:10.26,0:33:12.73,BottomCenter,,0,0,0,,notice that I keep the label the same
Dialogue: 0,0:33:12.97,0:33:16.90,BottomCenter,,0,0,0,,and that's because this function doesn't do anything
Dialogue: 0,0:33:16.90,0:33:18.13,BottomCenter,,0,0,0,,with the labels
Dialogue: 0,0:33:18.17,0:33:20.47,BottomCenter,,0,0,0,,of the nodes that aren't leaves
Dialogue: 0,0:33:21.56,0:33:24.59,BottomCenter,,0,0,0,,here's another tree processing function increment t
Dialogue: 0,0:33:24.73,0:33:26.59,BottomCenter,,0,0,0,,which returns a tree like t
Dialogue: 0,0:33:26.73,0:33:29.40,BottomCenter,,0,0,0,,but with all labels incremented
Dialogue: 0,0:33:29.76,0:33:31.17,BottomCenter,,0,0,0,,I'll show you a trick
Dialogue: 0,0:33:31.40,0:33:32.59,BottomCenter,,0,0,0,,you don't always
Dialogue: 0,0:33:32.59,0:33:35.70,BottomCenter,,0,0,0,,need to have a separate base case for the leaves
Dialogue: 0,0:33:35.79,0:33:38.40,BottomCenter,,0,0,0,,if every tree is treated the same way
Dialogue: 0,0:33:38.97,0:33:41.76,BottomCenter,,0,0,0,,this is a one liner that says
Dialogue: 0,0:33:42.36,0:33:45.67,BottomCenter,,0,0,0,,return a tree where I've incremented the label
Dialogue: 0,0:33:46.00,0:33:47.40,BottomCenter,,0,0,0,,and I've incremented
Dialogue: 0,0:33:47.40,0:33:50.20,BottomCenter,,0,0,0,,all of the labels in all of the branches
Dialogue: 0,0:33:51.17,0:33:52.79,BottomCenter,,0,0,0,,this is tree recursive
Dialogue: 0,0:33:53.40,0:33:55.67,BottomCenter,,0,0,0,,how do we ever reach a base case
Dialogue: 0,0:33:55.93,0:33:59.26,BottomCenter,,0,0,0,,while when there are no branches such as in a leaf
Dialogue: 0,0:33:59.70,0:34:02.20,BottomCenter,,0,0,0,,this is an empty list and we're done
Dialogue: 0,0:34:02.20,0:34:05.26,BottomCenter,,0,0,0,,we don't make any recursive calls when we reach a leaf
Dialogue: 0,0:34:05.70,0:34:08.53,BottomCenter,,0,0,0,,we didn't need to use an if statement to say that
Dialogue: 0,0:34:08.67,0:34:11.26,BottomCenter,,0,0,0,,because that's built into list comprehensions
Dialogue: 0,0:34:11.26,0:34:13.13,BottomCenter,,0,0,0,,that if this list is empty
Dialogue: 0,0:34:13.13,0:34:15.32,BottomCenter,,0,0,0,,then the whole comprehension is empty
Dialogue: 0,0:34:15.32,0:34:18.19,BottomCenter,,0,0,0,,and doesn't require any work to construct
Dialogue: 0,0:34:20.80,0:34:24.17,BottomCenter,,0,0,0,,here's an example of one more tree processing function
Dialogue: 0,0:34:25.09,0:34:27.86,BottomCenter,,0,0,0,,I'll write a function that prints out a tree
Dialogue: 0,0:34:29.30,0:34:32.30,BottomCenter,,0,0,0,,it will first print the label of that tree
Dialogue: 0,0:34:33.19,0:34:37.32,BottomCenter,,0,0,0,,and then for every branch it will call print tree
Dialogue: 0,0:34:37.80,0:34:38.90,BottomCenter,,0,0,0,,on the branch
Dialogue: 0,0:34:39.26,0:34:40.67,BottomCenter,,0,0,0,,I don't return anything
Dialogue: 0,0:34:40.90,0:34:41.53,BottomCenter,,0,0,0,,instead
Dialogue: 0,0:34:41.53,0:34:45.50,BottomCenter,,0,0,0,,this function exists in order to display a tree value
Dialogue: 0,0:34:45.73,0:34:47.07,BottomCenter,,0,0,0,,so that we don't have to look at
Dialogue: 0,0:34:47.07,0:34:48.76,BottomCenter,,0,0,0,,nested lists all the time
Dialogue: 0,0:34:49.53,0:34:52.30,BottomCenter,,0,0,0,,if I call print tree on fib tree
Dialogue: 0,0:34:53.13,0:34:53.92,BottomCenter,,0,0,0,,four
Dialogue: 0,0:34:54.36,0:34:56.40,BottomCenter,,0,0,0,,I can see all the values
Dialogue: 0,0:34:56.96,0:34:58.90,BottomCenter,,0,0,0,,but I can't see this structure
Dialogue: 0,0:34:59.46,0:35:01.30,BottomCenter,,0,0,0,,let's write a better print tree
Dialogue: 0,0:35:01.57,0:35:05.53,BottomCenter,,0,0,0,,that uses indentation in order to show the structure
Dialogue: 0,0:35:06.69,0:35:08.96,BottomCenter,,0,0,0,,if I wanted to indent by
Dialogue: 0,0:35:09.53,0:35:13.96,BottomCenter,,0,0,0,,five pairs of spaces and then write
Dialogue: 0,0:35:14.50,0:35:16.76,BottomCenter,,0,0,0,,the No.5 after that
Dialogue: 0,0:35:17.09,0:35:17.96,BottomCenter,,0,0,0,,I would build
Dialogue: 0,0:35:17.96,0:35:20.92,BottomCenter,,0,0,0,,the string using multiplication and addition
Dialogue: 0,0:35:21.09,0:35:24.57,BottomCenter,,0,0,0,,and if I print that out then I get five indented
Dialogue: 0,0:35:25.90,0:35:26.80,BottomCenter,,0,0,0,,by default
Dialogue: 0,0:35:26.80,0:35:30.19,BottomCenter,,0,0,0,,I don't want the root label to be indented at all
Dialogue: 0,0:35:31.36,0:35:34.32,BottomCenter,,0,0,0,,but I want the possibility of indentation to happen
Dialogue: 0,0:35:34.32,0:35:37.57,BottomCenter,,0,0,0,,later where I'm going to take those two spaces
Dialogue: 0,0:35:37.57,0:35:39.96,BottomCenter,,0,0,0,,multiply them by the indentation level
Dialogue: 0,0:35:40.09,0:35:44.07,BottomCenter,,0,0,0,,and then add a string representation of the label of t
Dialogue: 0,0:35:45.69,0:35:46.53,BottomCenter,,0,0,0,,the way that
Dialogue: 0,0:35:46.53,0:35:49.32,BottomCenter,,0,0,0,,indentation occurs is that I'm going to indent
Dialogue: 0,0:35:49.32,0:35:50.59,BottomCenter,,0,0,0,,all the branches
Dialogue: 0,0:35:51.67,0:35:54.07,BottomCenter,,0,0,0,,and since this is defined in terms of indent
Dialogue: 0,0:35:54.07,0:35:55.53,BottomCenter,,0,0,0,,if I get a branch of a branch
Dialogue: 0,0:35:55.53,0:35:57.50,BottomCenter,,0,0,0,,it will be indented twice
Dialogue: 0,0:35:58.26,0:36:01.19,BottomCenter,,0,0,0,,so now when I print tree fib tree four
Dialogue: 0,0:36:01.19,0:36:03.32,BottomCenter,,0,0,0,,I can clearly see the structure
Dialogue: 0,0:36:03.59,0:36:05.30,BottomCenter,,0,0,0,,even for a larger tree
Dialogue: 0,0:36:05.40,0:36:08.00,BottomCenter,,0,0,0,,I can clearly see that there's fib tree four
Dialogue: 0,0:36:08.26,0:36:11.80,BottomCenter,,0,0,0,,there's fib tree four again as one of the branches
Dialogue: 0,0:36:11.80,0:36:14.46,BottomCenter,,0,0,0,,here's the other branch of fib tree five
Dialogue: 0,0:36:15.73,0:36:18.76,BottomCenter,,0,0,0,,the indentation level of a label
Dialogue: 0,0:36:18.96,0:36:22.19,BottomCenter,,0,0,0,,corresponds to its depth in the tree
Dialogue: 0,0:36:23.53,0:36:25.13,BottomCenter,,0,0,0,,let's work through one more example
Dialogue: 0,0:36:25.13,0:36:27.76,BottomCenter,,0,0,0,,about summing all the labels along a path
Dialogue: 0,0:36:27.76,0:36:29.96,BottomCenter,,0,0,0,,from the route to the leaf of a tree
Dialogue: 0,0:36:30.09,0:36:31.69,BottomCenter,,0,0,0,,and then printing out that sum
Dialogue: 0,0:36:32.53,0:36:35.40,BottomCenter,,0,0,0,,some recursive functions build up their result
Dialogue: 0,0:36:35.67,0:36:39.30,BottomCenter,,0,0,0,,by manipulating the return value of a recursive call
Dialogue: 0,0:36:39.53,0:36:41.80,BottomCenter,,0,0,0,,where other recursive functions
Dialogue: 0,0:36:41.86,0:36:44.76,BottomCenter,,0,0,0,,build up their result by passing information
Dialogue: 0,0:36:45.00,0:36:47.50,BottomCenter,,0,0,0,,into the recursive call as an argument
Dialogue: 0,0:36:47.90,0:36:50.00,BottomCenter,,0,0,0,,and both of these strategies are useful when
Dialogue: 0,0:36:50.00,0:36:51.26,BottomCenter,,0,0,0,,processing trees
Dialogue: 0,0:36:51.73,0:36:53.09,BottomCenter,,0,0,0,,so let's look at an example
Dialogue: 0,0:36:53.09,0:36:54.90,BottomCenter,,0,0,0,,of both ways of doing things
Dialogue: 0,0:36:57.13,0:36:58.76,BottomCenter,,0,0,0,,before working with trees
Dialogue: 0,0:36:58.76,0:37:01.53,BottomCenter,,0,0,0,,let's go back to our old friend factorial
Dialogue: 0,0:37:02.32,0:37:05.67,BottomCenter,,0,0,0,,one way to write it is if an equal zero
Dialogue: 0,0:37:06.90,0:37:08.00,BottomCenter,,0,0,0,,we return one
Dialogue: 0,0:37:08.17,0:37:10.26,BottomCenter,,0,0,0,,otherwise we return end times
Dialogue: 0,0:37:10.26,0:37:12.80,BottomCenter,,0,0,0,,the result of calling fact on n minus one
Dialogue: 0,0:37:13.30,0:37:15.92,BottomCenter,,0,0,0,,and if we run this example on say four
Dialogue: 0,0:37:15.96,0:37:17.13,BottomCenter,,0,0,0,,then we'll get four times three
Dialogue: 0,0:37:17.13,0:37:18.86,BottomCenter,,0,0,0,,times two times one is 24
Dialogue: 0,0:37:20.36,0:37:21.67,BottomCenter,,0,0,0,,and this is an example
Dialogue: 0,0:37:21.67,0:37:25.13,BottomCenter,,0,0,0,,of taking the return value of a recursive call
Dialogue: 0,0:37:25.36,0:37:29.13,BottomCenter,,0,0,0,,and manipulating it in this case for multiplying in it
Dialogue: 0,0:37:30.32,0:37:31.40,BottomCenter,,0,0,0,,but there's another way
Dialogue: 0,0:37:31.90,0:37:35.30,BottomCenter,,0,0,0,,instead I could define fact times
Dialogue: 0,0:37:35.50,0:37:37.59,BottomCenter,,0,0,0,,which takes in both n and k
Dialogue: 0,0:37:38.32,0:37:40.13,BottomCenter,,0,0,0,,and instead of returning
Dialogue: 0,0:37:40.26,0:37:44.32,BottomCenter,,0,0,0,,just end times end minus one times end minus two
Dialogue: 0,0:37:44.40,0:37:48.59,BottomCenter,,0,0,0,,this returns k times end times end minus one
Dialogue: 0,0:37:48.90,0:37:50.86,BottomCenter,,0,0,0,,times end minus two times end minus three
Dialogue: 0,0:37:50.86,0:37:52.67,BottomCenter,,0,0,0,,all the way down to one
Dialogue: 0,0:37:53.53,0:37:55.00,BottomCenter,,0,0,0,,and we'll do it as follows
Dialogue: 0,0:37:55.17,0:37:58.30,BottomCenter,,0,0,0,,if n is zero will return k
Dialogue: 0,0:37:58.53,0:38:00.86,BottomCenter,,0,0,0,,because n factorial is just one
Dialogue: 0,0:38:01.36,0:38:04.92,BottomCenter,,0,0,0,,otherwise we're going to return the result of calling
Dialogue: 0,0:38:04.92,0:38:08.09,BottomCenter,,0,0,0,,effect times on n minus one
Dialogue: 0,0:38:08.17,0:38:09.57,BottomCenter,,0,0,0,,and k times n
Dialogue: 0,0:38:11.19,0:38:13.50,BottomCenter,,0,0,0,,and I think what's interesting about this example
Dialogue: 0,0:38:13.59,0:38:16.32,BottomCenter,,0,0,0,,is that we're not manipulating the return value
Dialogue: 0,0:38:16.32,0:38:19.09,BottomCenter,,0,0,0,,of this recursive called effect times at all
Dialogue: 0,0:38:19.69,0:38:21.53,BottomCenter,,0,0,0,,instead we're just returning it
Dialogue: 0,0:38:22.46,0:38:25.46,BottomCenter,,0,0,0,,which means that the result of the recursive call
Dialogue: 0,0:38:25.73,0:38:27.96,BottomCenter,,0,0,0,,better be the result of the current call
Dialogue: 0,0:38:28.67,0:38:30.26,BottomCenter,,0,0,0,,in extending this reasoning
Dialogue: 0,0:38:30.30,0:38:32.96,BottomCenter,,0,0,0,,it means the result of the base case
Dialogue: 0,0:38:33.17,0:38:34.13,BottomCenter,,0,0,0,,needs to be
Dialogue: 0,0:38:34.32,0:38:37.57,BottomCenter,,0,0,0,,the same result as the original recursive call
Dialogue: 0,0:38:38.19,0:38:40.30,BottomCenter,,0,0,0,,and that turns out to be true in this case
Dialogue: 0,0:38:40.96,0:38:44.17,BottomCenter,,0,0,0,,so if we're trying to compute k times and factorial
Dialogue: 0,0:38:44.30,0:38:45.67,BottomCenter,,0,0,0,,here's the expression
Dialogue: 0,0:38:46.00,0:38:47.86,BottomCenter,,0,0,0,,it turns out that's identical
Dialogue: 0,0:38:48.00,0:38:52.13,BottomCenter,,0,0,0,,to k times n times and minus one factorial
Dialogue: 0,0:38:52.40,0:38:53.96,BottomCenter,,0,0,0,,here's the k times n
Dialogue: 0,0:38:54.50,0:38:56.76,BottomCenter,,0,0,0,,and here's the and minus one factorial
Dialogue: 0,0:38:57.40,0:38:59.96,BottomCenter,,0,0,0,,so here the result is being built up
Dialogue: 0,0:39:00.13,0:39:02.07,BottomCenter,,0,0,0,,and by the time you hit the base case
Dialogue: 0,0:39:02.07,0:39:04.07,BottomCenter,,0,0,0,,you're done with all of the multiply
Dialogue: 0,0:39:04.46,0:39:05.90,BottomCenter,,0,0,0,,whereas in this version
Dialogue: 0,0:39:06.07,0:39:07.86,BottomCenter,,0,0,0,,you haven't done any multiplying at all
Dialogue: 0,0:39:07.86,0:39:09.26,BottomCenter,,0,0,0,,when you hit the base case
Dialogue: 0,0:39:09.26,0:39:11.57,BottomCenter,,0,0,0,,that all happens after you return
Dialogue: 0,0:39:12.67,0:39:13.26,BottomCenter,,0,0,0,,and in fact
Dialogue: 0,0:39:13.26,0:39:16.86,BottomCenter,,0,0,0,,if we wanted to define fact in terms of fact times
Dialogue: 0,0:39:16.90,0:39:18.13,BottomCenter,,0,0,0,,that wouldn't be too hard
Dialogue: 0,0:39:19.07,0:39:20.59,BottomCenter,,0,0,0,,we just returned the result
Dialogue: 0,0:39:20.59,0:39:23.53,BottomCenter,,0,0,0,,of calling fact times on nn one
Dialogue: 0,0:39:25.13,0:39:27.09,BottomCenter,,0,0,0,,fact four is still 24
Dialogue: 0,0:39:29.30,0:39:32.09,BottomCenter,,0,0,0,,okay now let's work on an example with trees
Dialogue: 0,0:39:32.73,0:39:35.36,BottomCenter,,0,0,0,,so I have a file with all of the
Dialogue: 0,0:39:35.53,0:39:38.53,BottomCenter,,0,0,0,,tree constructor and selector functions in it already
Dialogue: 0,0:39:38.92,0:39:40.32,BottomCenter,,0,0,0,,called tree dot pi
Dialogue: 0,0:39:40.59,0:39:42.30,BottomCenter,,0,0,0,,so if I want to be able to use all those
Dialogue: 0,0:39:42.30,0:39:45.26,BottomCenter,,0,0,0,,I can write an import statement that imports them all
Dialogue: 0,0:39:46.17,0:39:47.67,BottomCenter,,0,0,0,,and now I could build a tree
Dialogue: 0,0:39:48.19,0:39:49.19,BottomCenter,,0,0,0,,a number tree
Dialogue: 0,0:39:49.92,0:39:51.07,BottomCenter,,0,0,0,,might look like
Dialogue: 0,0:39:51.90,0:39:53.19,BottomCenter,,0,0,0,,three's at the root
Dialogue: 0,0:39:53.36,0:39:57.57,BottomCenter,,0,0,0,,and then we have a branch that's a leaf with four
Dialogue: 0,0:39:57.80,0:40:00.53,BottomCenter,,0,0,0,,and we have another branch that's not a leaf
Dialogue: 0,0:40:00.69,0:40:02.53,BottomCenter,,0,0,0,,with five and six
Dialogue: 0,0:40:07.13,0:40:08.50,BottomCenter,,0,0,0,,and let's have another tree
Dialogue: 0,0:40:09.07,0:40:11.59,BottomCenter,,0,0,0,,one with letters in it instead
Dialogue: 0,0:40:12.67,0:40:14.92,BottomCenter,,0,0,0,,we'll put h at the root
Dialogue: 0,0:40:15.76,0:40:17.76,BottomCenter,,0,0,0,,which has a branch rooted at a
Dialogue: 0,0:40:18.26,0:40:19.90,BottomCenter,,0,0,0,,and this will have two leaves
Dialogue: 0,0:40:21.86,0:40:24.73,BottomCenter,,0,0,0,,the s leaf and the t leaf
Dialogue: 0,0:40:25.96,0:40:27.53,BottomCenter,,0,0,0,,and then we'll also have
Dialogue: 0,0:40:28.19,0:40:29.07,BottomCenter,,0,0,0,,an e
Dialogue: 0,0:40:30.19,0:40:33.36,BottomCenter,,0,0,0,,which is its own leaf under the h route
Dialogue: 0,0:40:34.90,0:40:36.50,BottomCenter,,0,0,0,,so haste is a tree
Dialogue: 0,0:40:36.96,0:40:37.57,BottomCenter,,0,0,0,,that has the
Dialogue: 0,0:40:37.57,0:40:40.50,BottomCenter,,0,0,0,,underlying representation of a bunch of lists within
Dialogue: 0,0:40:40.50,0:40:41.80,BottomCenter,,0,0,0,,lists within lists
Dialogue: 0,0:40:42.67,0:40:44.86,BottomCenter,,0,0,0,,but I can get its label and that will be h
Dialogue: 0,0:40:45.32,0:40:46.86,BottomCenter,,0,0,0,,and I can get its branches
Dialogue: 0,0:40:50.46,0:40:53.80,BottomCenter,,0,0,0,,all right let's say we want to write a function
Dialogue: 0,0:40:54.09,0:40:55.90,BottomCenter,,0,0,0,,that takes in a tree
Dialogue: 0,0:40:56.40,0:40:59.17,BottomCenter,,0,0,0,,finds all the leaves and for each leaf
Dialogue: 0,0:40:59.36,0:41:01.69,BottomCenter,,0,0,0,,prints out the sum of all the labels
Dialogue: 0,0:41:01.69,0:41:03.36,BottomCenter,,0,0,0,,from the route to that leaf
Dialogue: 0,0:41:07.59,0:41:10.17,BottomCenter,,0,0,0,,much like the fact times function
Dialogue: 0,0:41:10.32,0:41:12.96,BottomCenter,,0,0,0,,I'm going to add a second argument
Dialogue: 0,0:41:13.76,0:41:15.40,BottomCenter,,0,0,0,,the sum so far
Dialogue: 0,0:41:18.26,0:41:20.53,BottomCenter,,0,0,0,,so that I can build up this sum as I go
Dialogue: 0,0:41:20.59,0:41:23.13,BottomCenter,,0,0,0,,and then when I get to the leaf I just print it out
Dialogue: 0,0:41:24.09,0:41:25.92,BottomCenter,,0,0,0,,so whether this is a leaf or not
Dialogue: 0,0:41:25.96,0:41:27.30,BottomCenter,,0,0,0,,there's going to be a label
Dialogue: 0,0:41:27.30,0:41:29.09,BottomCenter,,0,0,0,,and we should add that to so far
Dialogue: 0,0:41:34.00,0:41:34.80,BottomCenter,,0,0,0,,but then
Dialogue: 0,0:41:35.59,0:41:37.80,BottomCenter,,0,0,0,,we'll figure out if we're at a leaf or not
Dialogue: 0,0:41:39.86,0:41:42.96,BottomCenter,,0,0,0,,if we are then we print out the sum so far
Dialogue: 0,0:41:42.96,0:41:46.73,BottomCenter,,0,0,0,,which includes the leaf label and everything above it
Dialogue: 0,0:41:47.19,0:41:49.96,BottomCenter,,0,0,0,,otherwise we go through all the branches
Dialogue: 0,0:41:52.07,0:41:54.26,BottomCenter,,0,0,0,,t is a tree so I can call branches on it
Dialogue: 0,0:41:54.32,0:41:57.96,BottomCenter,,0,0,0,,I get a list of trees so each b is a tree
Dialogue: 0,0:41:58.67,0:42:01.80,BottomCenter,,0,0,0,,and print sums is a function that I can call on trees
Dialogue: 0,0:42:02.13,0:42:06.80,BottomCenter,,0,0,0,,so if I call print sums on numbers starting with zero
Dialogue: 0,0:42:06.92,0:42:08.19,BottomCenter,,0,0,0,,I'll see seven
Dialogue: 0,0:42:08.69,0:42:10.50,BottomCenter,,0,0,0,,and the seven came from
Dialogue: 0,0:42:10.90,0:42:12.57,BottomCenter,,0,0,0,,the three of the route
Dialogue: 0,0:42:12.90,0:42:15.00,BottomCenter,,0,0,0,,followed by the four
Dialogue: 0,0:42:15.40,0:42:18.53,BottomCenter,,0,0,0,,which is directly below the route and is a leaf
Dialogue: 0,0:42:18.86,0:42:21.00,BottomCenter,,0,0,0,,the other thing that should be printed out is
Dialogue: 0,0:42:21.00,0:42:23.09,BottomCenter,,0,0,0,,the sum along the path from three
Dialogue: 0,0:42:23.59,0:42:24.69,BottomCenter,,0,0,0,,to five
Dialogue: 0,0:42:24.69,0:42:28.32,BottomCenter,,0,0,0,,oh but five is not a leaf so we don't print yet to six
Dialogue: 0,0:42:28.73,0:42:30.86,BottomCenter,,0,0,0,,three plus five plus six is 14
Dialogue: 0,0:42:31.00,0:42:32.76,BottomCenter,,0,0,0,,which is the 14 we got down here
Dialogue: 0,0:42:33.96,0:42:37.36,BottomCenter,,0,0,0,,and what happens when we call print sums on the haste
Dialogue: 0,0:42:37.36,0:42:41.07,BottomCenter,,0,0,0,,tree instead is that I think we should start with
Dialogue: 0,0:42:41.17,0:42:44.59,BottomCenter,,0,0,0,,an empty string so that we can add more strings to it
Dialogue: 0,0:42:44.92,0:42:48.09,BottomCenter,,0,0,0,,at which point we print out has
Dialogue: 0,0:42:48.76,0:42:54.32,BottomCenter,,0,0,0,,that came from HAS and we reached a leaf
Dialogue: 0,0:42:54.76,0:42:56.59,BottomCenter,,0,0,0,,or hat h
Dialogue: 0,0:42:57.19,0:42:58.00,BottomCenter,,0,0,0,,a
Dialogue: 0,0:42:58.53,0:43:01.19,BottomCenter,,0,0,0,,t we reached a leaf or heat
Dialogue: 0,0:43:01.59,0:43:04.57,BottomCenter,,0,0,0,,which is this leaf below this route
Dialogue: 0,0:43:05.80,0:43:07.73,BottomCenter,,0,0,0,,and the structure of this function
Dialogue: 0,0:43:07.92,0:43:08.90,BottomCenter,,0,0,0,,is that we're
Dialogue: 0,0:43:09.00,0:43:10.92,BottomCenter,,0,0,0,,building up the sum as we go
Dialogue: 0,0:43:10.92,0:43:13.80,BottomCenter,,0,0,0,,always passing a new value into so far
Dialogue: 0,0:43:14.13,0:43:16.67,BottomCenter,,0,0,0,,I could have written so far plus labelty here
Dialogue: 0,0:43:16.67,0:43:18.53,BottomCenter,,0,0,0,,instead of this assignment statement
Dialogue: 0,0:43:19.13,0:43:20.67,BottomCenter,,0,0,0,,and that would have been fine too
Dialogue: 0,0:43:21.00,0:43:23.13,BottomCenter,,0,0,0,,or we could just update so far
Dialogue: 0,0:43:23.30,0:43:25.92,BottomCenter,,0,0,0,,and then use the new value either to print
Dialogue: 0,0:43:26.07,0:43:29.40,BottomCenter,,0,0,0,,or to pass in to all of the recursive calls