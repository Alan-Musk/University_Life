[Script Info]
Title: Lecture 36. Macros_哔哩哔哩_bilibili
ScriptType: v4.00+
Collisions: Reverse
PlayResX: 1280
PlayResY: 720
WrapStyle: 3
ScaledBorderAndShadow: yes
; ----------------------
; 本字幕由CC字幕助手自动转换
; 字幕来源https://www.bilibili.com/video/BV1s3411G7yM?p=86&vd_source=6ffca0aa1006734a4fba52f389036611
; 脚本地址https://greasyfork.org/scripts/378513
; 设置了字幕过长自动换行，但若字幕中没有空格换行将无效
; 字体大小依据720p 48号字体等比缩放
; 如显示不正常请尝试使用SRT格式

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Segoe UI,48,&H00FFFFFF,&HF0000000,&H00000000,&HF0000000,1,0,0,0,100,100,0,0.00,1,1,3,2,30,30,20,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.47,0:00:02.50,*Default,NTP,0000,0000,0000,,61 第 36 号选举
Dialogue: 0,0:00:02.87,0:00:03.77,*Default,NTP,0000,0000,0000,,公告
Dialogue: 0,0:00:04.13,0:00:06.13,*Default,NTP,0000,0000,0000,,可选计划
Dialogue: 0,0:00:06.13,0:00:09.10,*Default,NTP,0000,0000,0000,,艺术作品竞赛的参赛作品应于周一
Dialogue: 0,0:00:09.10,0:00:10.27,*Default,NTP,0000,0000,0000,,也就是明天
Dialogue: 0,0:00:10.87,0:00:14.00,*Default,NTP,0000,0000,0000,,本周我们将有一次实验，周二可以照常进行
Dialogue: 0,0:00:14.30,0:00:15.97,*Default,NTP,0000,0000,0000,,本次实验的重点是
Dialogue: 0,0:00:16.07,0:00:17.80,*Default,NTP,0000,0000,0000,,准备期末考试
Dialogue: 0,0:00:17.80,0:00:19.70,*Default,NTP,0000,0000,0000,,所以这是开始准备的好方法
Dialogue: 0,0:00:19.90,0:00:21.00,*Default,NTP,0000,0000,0000,,开始复习
Dialogue: 0,0:00:21.00,0:00:22.73,*Default,NTP,0000,0000,0000,,本课程的一些材料
Dialogue: 0,0:00:23.00,0:00:25.67,*Default,NTP,0000,0000,0000,,我们在周一下午三点和晚上七点有实验聚会
Dialogue: 0,0:00:25.67,0:00:26.80,*Default,NTP,0000,0000,0000,,和下午七点
Dialogue: 0,0:00:27.33,0:00:30.73,*Default,NTP,0000,0000,0000,,关于续集的第九次家庭作业早已发布
Dialogue: 0,0:00:31.10,0:00:32.57,*Default,NTP,0000,0000,0000,,感恩节前
Dialogue: 0,0:00:33.20,0:00:34.60,*Default,NTP,0000,0000,0000,,我们周四来做吧
Dialogue: 0,0:00:34.70,0:00:36.77,*Default,NTP,0000,0000,0000,,周二有作业派对
Dialogue: 0,0:00:37.37,0:00:40.60,*Default,NTP,0000,0000,0000,,如果你在蚂蚁项目上丢了作文分
Dialogue: 0,0:00:40.60,0:00:41.97,*Default,NTP,0000,0000,0000,,而你想通过修改
Dialogue: 0,0:00:41.97,0:00:44.17,*Default,NTP,0000,0000,0000,,如果你想通过修改
Dialogue: 0,0:00:44.17,0:00:47.13,*Default,NTP,0000,0000,0000,,你需要在周日之前完成
Dialogue: 0,0:00:48.73,0:00:50.40,*Default,NTP,0000,0000,0000,,本周我们将尝试一些新方法
Dialogue: 0,0:00:50.70,0:00:53.97,*Default,NTP,0000,0000,0000,,讨论讲义将以复习为主题
Dialogue: 0,0:00:54.33,0:00:56.20,*Default,NTP,0000,0000,0000,,我们将像往常一样进行辅导
Dialogue: 0,0:00:56.30,0:00:58.90,*Default,NTP,0000,0000,0000,,但我们也会开放一些更长的辅导课
Dialogue: 0,0:00:58.90,0:01:00.53,*Default,NTP,0000,0000,0000,,通常是 25 分钟
Dialogue: 0,0:01:00.53,0:01:02.60,*Default,NTP,0000,0000,0000,,我们将尝试一些 45 分钟的教程
Dialogue: 0,0:01:02.60,0:01:04.07,*Default,NTP,0000,0000,0000,,如果您对此感兴趣
Dialogue: 0,0:01:04.07,0:01:05.97,*Default,NTP,0000,0000,0000,,那就去注册和切换
Dialogue: 0,0:01:06.30,0:01:06.87,*Default,NTP,0000,0000,0000,,或者你知道
Dialogue: 0,0:01:06.87,0:01:08.67,*Default,NTP,0000,0000,0000,,如果你只想参加常规课程
Dialogue: 0,0:01:08.67,0:01:09.50,*Default,NTP,0000,0000,0000,,很好
Dialogue: 0,0:01:10.13,0:01:11.10,*Default,NTP,0000,0000,0000,,即使你想
Dialogue: 0,0:01:11.10,0:01:12.53,*Default,NTP,0000,0000,0000,,参加你的常规教程
Dialogue: 0,0:01:12.53,0:01:14.90,*Default,NTP,0000,0000,0000,,并参加其中的 45 分钟课程
Dialogue: 0,0:01:14.90,0:01:15.93,*Default,NTP,0000,0000,0000,,您可以同时参加
Dialogue: 0,0:01:16.27,0:01:18.77,*Default,NTP,0000,0000,0000,,系统一次只允许您注册一个课程
Dialogue: 0,0:01:18.77,0:01:21.77,*Default,NTP,0000,0000,0000,,但我敢打赌，如果您与您的辅导员取得联系
Dialogue: 0,0:01:21.87,0:01:23.97,*Default,NTP,0000,0000,0000,,你一定能想出办法同时参加两个课程
Dialogue: 0,0:01:24.50,0:01:25.10,*Default,NTP,0000,0000,0000,,现在
Dialogue: 0,0:01:25.10,0:01:27.90,*Default,NTP,0000,0000,0000,,现在有几个45分钟的
Dialogue: 0,0:01:27.93,0:01:28.90,*Default,NTP,0000,0000,0000,,复习辅导
Dialogue: 0,0:01:28.90,0:01:30.67,*Default,NTP,0000,0000,0000,,所以，如果您想要更长时间的复习
Dialogue: 0,0:01:30.73,0:01:31.90,*Default,NTP,0000,0000,0000,,本周三
Dialogue: 0,0:01:31.97,0:01:33.57,*Default,NTP,0000,0000,0000,,那么可以报名参加
Dialogue: 0,0:01:34.73,0:01:37.00,*Default,NTP,0000,0000,0000,,周五的最后一堂课
Dialogue: 0,0:01:37.17,0:01:38.80,*Default,NTP,0000,0000,0000,,将不提供讲座视频
Dialogue: 0,0:01:38.80,0:01:42.90,*Default,NTP,0000,0000,0000,,相反，我们将在下午 2 点举行同步变焦网络研讨会
Dialogue: 0,0:01:43.07,0:01:45.60,*Default,NTP,0000,0000,0000,,将进行录制并发布录制内容
Dialogue: 0,0:01:45.60,0:01:46.60,*Default,NTP,0000,0000,0000,,如果你不想来
Dialogue: 0,0:01:46.87,0:01:49.60,*Default,NTP,0000,0000,0000,,但这应该是结束课程的好方法
Dialogue: 0,0:01:49.80,0:01:50.40,*Default,NTP,0000,0000,0000,,实际上
Dialogue: 0,0:01:50.40,0:01:52.90,*Default,NTP,0000,0000,0000,,有一些现场问题，我们会回答。
Dialogue: 0,0:01:53.70,0:01:56.47,*Default,NTP,0000,0000,0000,,以下是重要链接 周一的实验室指导
Dialogue: 0,0:01:56.47,0:01:58.53,*Default,NTP,0000,0000,0000,,周三的讨论指导
Dialogue: 0,0:01:58.67,0:02:01.60,*Default,NTP,0000,0000,0000,,周三和周五的例行额外问答
Dialogue: 0,0:02:02.27,0:02:03.37,*Default,NTP,0000,0000,0000,,我们不会在本周五
Dialogue: 0,0:02:03.37,0:02:05.17,*Default,NTP,0000,0000,0000,,视频
Dialogue: 0,0:02:05.27,0:02:07.13,*Default,NTP,0000,0000,0000,,但我认为我们还是会举行 Q amp a
Dialogue: 0,0:02:07.17,0:02:09.67,*Default,NTP,0000,0000,0000,,如果有人想复习过去的问题
Dialogue: 0,0:02:10.30,0:02:12.37,*Default,NTP,0000,0000,0000,,本周我们还有概念办公时间
Dialogue: 0,0:02:12.50,0:02:14.20,*Default,NTP,0000,0000,0000,,周四下午一点
Dialogue: 0,0:02:15.73,0:02:17.60,*Default,NTP,0000,0000,0000,,今天的讲座很简短
Dialogue: 0,0:02:17.93,0:02:19.33,*Default,NTP,0000,0000,0000,,是关于计划的
Dialogue: 0,0:02:19.73,0:02:20.93,*Default,NTP,0000,0000,0000,,它回答了一个问题
Dialogue: 0,0:02:20.93,0:02:23.47,*Default,NTP,0000,0000,0000,,为什么有人会使用 scheme 而不是 python？
Dialogue: 0,0:02:23.73,0:02:26.47,*Default,NTP,0000,0000,0000,,的问题。
Dialogue: 0,0:02:26.53,0:02:29.20,*Default,NTP,0000,0000,0000,,它允许你通过添加新的特殊形式
Dialogue: 0,0:02:29.27,0:02:31.40,*Default,NTP,0000,0000,0000,,通过添加新的特殊形式
Dialogue: 0,0:02:31.77,0:02:33.70,*Default,NTP,0000,0000,0000,,这样，你就可以自定义方案
Dialogue: 0,0:02:33.70,0:02:34.87,*Default,NTP,0000,0000,0000,,你希望它如何工作
Dialogue: 0,0:02:35.53,0:02:38.10,*Default,NTP,0000,0000,0000,,这是一个可选的主题，但它确实是一个很好的练习
Dialogue: 0,0:02:38.10,0:02:40.13,*Default,NTP,0000,0000,0000,,因为很多方案问题都涉及到
Dialogue: 0,0:02:40.13,0:02:42.93,*Default,NTP,0000,0000,0000,,把方案表达式当作列表来处理
Dialogue: 0,0:02:42.93,0:02:45.37,*Default,NTP,0000,0000,0000,,这也是编写宏的关键。
Dialogue: 0,0:02:45.77,0:02:48.37,*Default,NTP,0000,0000,0000,,因此，尽管它是可选材料
Dialogue: 0,0:02:48.37,0:02:50.40,*Default,NTP,0000,0000,0000,,我建议您观看视频
Dialogue: 0,0:02:50.53,0:02:52.57,*Default,NTP,0000,0000,0000,,视频只有三段，非常简短
Dialogue: 0,0:02:52.90,0:02:54.33,*Default,NTP,0000,0000,0000,,你会学到很酷的东西
Dialogue: 0,0:02:54.60,0:02:55.70,*Default,NTP,0000,0000,0000,,好了，我们开始吧
Dialogue: 0,0:02:57.10,0:02:59.87,*Default,NTP,0000,0000,0000,,宏是方案的一项功能
Dialogue: 0,0:03:00.13,0:03:01.77,*Default,NTP,0000,0000,0000,,允许你在语言中定义
Dialogue: 0,0:03:01.80,0:03:04.30,*Default,NTP,0000,0000,0000,,在语言中定义新的特殊形式
Dialogue: 0,0:03:05.57,0:03:09.77,*Default,NTP,0000,0000,0000,,在 Python 中，我们有一定数量的表达式
Dialogue: 0,0:03:09.93,0:03:11.90,*Default,NTP,0000,0000,0000,,和语句类型
Dialogue: 0,0:03:12.00,0:03:14.00,*Default,NTP,0000,0000,0000,,在 scheme 中也是如此
Dialogue: 0,0:03:14.07,0:03:15.27,*Default,NTP,0000,0000,0000,,我们定义了
Dialogue: 0,0:03:15.60,0:03:20.37,*Default,NTP,0000,0000,0000,,lambda if cond 和 or 等
Dialogue: 0,0:03:21.00,0:03:23.00,*Default,NTP,0000,0000,0000,,其他都是存储过程
Dialogue: 0,0:03:24.00,0:03:27.67,*Default,NTP,0000,0000,0000,,现在，宏允许你通过发明新的特殊形式来扩展程序库
Dialogue: 0,0:03:27.77,0:03:30.97,*Default,NTP,0000,0000,0000,,通过发明新的特殊形式
Dialogue: 0,0:03:31.67,0:03:32.87,*Default,NTP,0000,0000,0000,,这意味着我们可以
Dialogue: 0,0:03:32.87,0:03:34.97,*Default,NTP,0000,0000,0000,,改变语言的工作方式
Dialogue: 0,0:03:35.10,0:03:39.70,*Default,NTP,0000,0000,0000,,发明新的评估方式
Dialogue: 0,0:03:39.70,0:03:41.67,*Default,NTP,0000,0000,0000,,的新方法
Dialogue: 0,0:03:42.10,0:03:44.30,*Default,NTP,0000,0000,0000,,听起来很花哨，确实如此
Dialogue: 0,0:03:44.67,0:03:45.80,*Default,NTP,0000,0000,0000,,这种功能
Dialogue: 0,0:03:45.80,0:03:48.80,*Default,NTP,0000,0000,0000,,让人们爱上了 lisp 编程
Dialogue: 0,0:03:49.87,0:03:52.13,*Default,NTP,0000,0000,0000,,并在 lisp
Dialogue: 0,0:03:52.13,0:03:53.87,*Default,NTP,0000,0000,0000,,语言（如 scheme
Dialogue: 0,0:03:54.27,0:03:58.20,*Default,NTP,0000,0000,0000,,是因为很容易将代码视为数据
Dialogue: 0,0:03:58.57,0:04:00.70,*Default,NTP,0000,0000,0000,,程序只是列表
Dialogue: 0,0:04:02.17,0:04:05.40,*Default,NTP,0000,0000,0000,,宏执行代码转换
Dialogue: 0,0:04:05.53,0:04:08.37,*Default,NTP,0000,0000,0000,,因此，发明新的特殊形式的方法
Dialogue: 0,0:04:08.60,0:04:12.77,*Default,NTP,0000,0000,0000,,就是描述如何将特殊形式的各个部分
Dialogue: 0,0:04:13.00,0:04:14.10,*Default,NTP,0000,0000,0000,,并构建
Dialogue: 0,0:04:14.10,0:04:16.47,*Default,NTP,0000,0000,0000,,并从中构建出一段常规的方案代码
Dialogue: 0,0:04:16.60,0:04:18.77,*Default,NTP,0000,0000,0000,,然后对方案代码进行评估
Dialogue: 0,0:04:20.13,0:04:21.97,*Default,NTP,0000,0000,0000,,所以宏是对程序源代码
Dialogue: 0,0:04:21.97,0:04:24.20,*Default,NTP,0000,0000,0000,,宏是对程序源代码进行的操作
Dialogue: 0,0:04:24.40,0:04:27.07,*Default,NTP,0000,0000,0000,,所以宏是在源代码被评估之前对程序源代码进行的操作
Dialogue: 0,0:04:28.57,0:04:32.20,*Default,NTP,0000,0000,0000,,宏确实存在于许多不同的编程语言中
Dialogue: 0,0:04:32.27,0:04:35.17,*Default,NTP,0000,0000,0000,,但迄今为止，宏最容易正确定义
Dialogue: 0,0:04:35.20,0:04:37.00,*Default,NTP,0000,0000,0000,,在像 lisp 这样的语言中
Dialogue: 0,0:04:37.10,0:04:39.10,*Default,NTP,0000,0000,0000,,在这种语言中，代码只是数据
Dialogue: 0,0:04:39.67,0:04:42.87,*Default,NTP,0000,0000,0000,,在 scheme 中，有一种特殊的形式叫做定义宏
Dialogue: 0,0:04:43.17,0:04:46.13,*Default,NTP,0000,0000,0000,,的特殊形式，它允许您定义一个
Dialogue: 0,0:04:46.13,0:04:47.47,*Default,NTP,0000,0000,0000,,在源代码上
Dialogue: 0,0:04:47.70,0:04:50.50,*Default,NTP,0000,0000,0000,,为你要发明的特殊形式定义转换
Dialogue: 0,0:04:51.33,0:04:54.77,*Default,NTP,0000,0000,0000,,下面是一个名为 twice 的宏的示例
Dialogue: 0,0:04:55.13,0:04:58.00,*Default,NTP,0000,0000,0000,,你可以看到它看起来很像存储过程定义
Dialogue: 0,0:04:58.27,0:04:59.77,*Default,NTP,0000,0000,0000,,但
Dialogue: 0,0:04:59.87,0:05:03.13,*Default,NTP,0000,0000,0000,,但计算 twice 表达式的方式却截然不同
Dialogue: 0,0:05:03.77,0:05:06.40,*Default,NTP,0000,0000,0000,,内容规定，当你对一个表达式进行两次运算时
Dialogue: 0,0:05:06.47,0:05:08.73,*Default,NTP,0000,0000,0000,,就会建立一个以 begin 开头的列表
Dialogue: 0,0:05:08.90,0:05:11.30,*Default,NTP,0000,0000,0000,,开头的列表，然后将该表达式赋值两次
Dialogue: 0,0:05:11.77,0:05:15.53,*Default,NTP,0000,0000,0000,,一旦定义了这个宏，就可以对任何表达式进行两次运算
Dialogue: 0,0:05:15.73,0:05:19.60,*Default,NTP,0000,0000,0000,,在这里，我们将表达式打印两次
Dialogue: 0,0:05:20.67,0:05:24.20,*Default,NTP,0000,0000,0000,,由于 twice 是一个宏，所以在幕后会发生什么？
Dialogue: 0,0:05:24.60,0:05:28.37,*Default,NTP,0000,0000,0000,,因为 twice 是一个宏，所以在幕后会发生什么呢？
Dialogue: 0,0:05:28.67,0:05:31.20,*Default,NTP,0000,0000,0000,,你在这里输入的表达式
Dialogue: 0,0:05:31.37,0:05:34.30,*Default,NTP,0000,0000,0000,,在表达式被评估之前
Dialogue: 0,0:05:34.93,0:05:38.57,*Default,NTP,0000,0000,0000,,因此，我们构建了一个新的表达式 print two
Dialogue: 0,0:05:38.57,0:05:42.37,*Default,NTP,0000,0000,0000,,打印二，然后对这个表达式进行求值
Dialogue: 0,0:05:42.47,0:05:45.27,*Default,NTP,0000,0000,0000,,这意味着它将打印两个选择
Dialogue: 0,0:05:46.90,0:05:49.27,*Default,NTP,0000,0000,0000,,这里发生了一件有趣的事情
Dialogue: 0,0:05:49.67,0:05:53.07,*Default,NTP,0000,0000,0000,,如果 twice 只是一个存储过程，不管它的定义是什么
Dialogue: 0,0:05:53.20,0:05:55.33,*Default,NTP,0000,0000,0000,,打印 ii 会在调用
Dialogue: 0,0:05:55.37,0:05:57.40,*Default,NTP,0000,0000,0000,,在调用两次之前
Dialogue: 0,0:05:57.67,0:06:00.27,*Default,NTP,0000,0000,0000,,这就意味着 2 会被显示一次
Dialogue: 0,0:06:00.30,0:06:02.13,*Default,NTP,0000,0000,0000,,值 ii 就会消失
Dialogue: 0,0:06:02.13,0:06:04.67,*Default,NTP,0000,0000,0000,,因为一旦打印，就无法取回值了
Dialogue: 0,0:06:05.50,0:06:07.60,*Default,NTP,0000,0000,0000,,所以 twice 能做的事情
Dialogue: 0,0:06:08.07,0:06:10.93,*Default,NTP,0000,0000,0000,,能做的事情，而正则表达式却做不到
Dialogue: 0,0:06:11.00,0:06:13.53,*Default,NTP,0000,0000,0000,,那就是将这个表达式
Dialogue: 0,0:06:13.53,0:06:16.30,*Default,NTP,0000,0000,0000,,并在计算之前复制它
Dialogue: 0,0:06:16.33,0:06:18.47,*Default,NTP,0000,0000,0000,,然后进行两次求值
Dialogue: 0,0:06:19.70,0:06:21.17,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:06:21.17,0:06:23.57,*Default,NTP,0000,0000,0000,,一般来说，宏调用表达式的
Dialogue: 0,0:06:23.57,0:06:24.50,*Default,NTP,0000,0000,0000,,像这样
Dialogue: 0,0:06:25.53,0:06:28.37,*Default,NTP,0000,0000,0000,,的操作符子表达式
Dialogue: 0,0:06:28.70,0:06:30.20,*Default,NTP,0000,0000,0000,,如果计算出两个
Dialogue: 0,0:06:30.20,0:06:33.93,*Default,NTP,0000,0000,0000,,定义的宏的特殊形式
Dialogue: 0,0:06:34.33,0:06:36.87,*Default,NTP,0000,0000,0000,,那么我们的处理方式就与常规的
Dialogue: 0,0:06:36.87,0:06:37.80,*Default,NTP,0000,0000,0000,,程序
Dialogue: 0,0:06:38.57,0:06:41.77,*Default,NTP,0000,0000,0000,,我们在操作数表达式上调用宏过程
Dialogue: 0,0:06:41.77,0:06:43.67,*Default,NTP,0000,0000,0000,,而不先求值
Dialogue: 0,0:06:44.73,0:06:47.93,*Default,NTP,0000,0000,0000,,然后对宏存储过程返回的表达式进行运算
Dialogue: 0,0:06:47.93,0:06:48.73,*Default,NTP,0000,0000,0000,,过程
Dialogue: 0,0:06:49.33,0:06:52.50,*Default,NTP,0000,0000,0000,,因此，宏存储过程接收表达式并返回表达式
Dialogue: 0,0:06:52.50,0:06:55.67,*Default,NTP,0000,0000,0000,,而不是输入值返回值
Dialogue: 0,0:06:56.73,0:06:58.57,*Default,NTP,0000,0000,0000,,下面我们来谈谈打印
Dialogue: 0,0:06:59.10,0:07:01.77,*Default,NTP,0000,0000,0000,,当我打印 2 时，屏幕上显示的是 2
Dialogue: 0,0:07:01.77,0:07:04.17,*Default,NTP,0000,0000,0000,,但如果我将 x 定义为 print two
Dialogue: 0,0:07:04.17,0:07:06.87,*Default,NTP,0000,0000,0000,,然后再看 x，就会发现 x 什么都不是了
Dialogue: 0,0:07:07.40,0:07:09.70,*Default,NTP,0000,0000,0000,,一旦你打印了 2，它就消失了
Dialogue: 0,0:07:10.73,0:07:12.60,*Default,NTP,0000,0000,0000,,如果我想打印两次
Dialogue: 0,0:07:12.60,0:07:14.50,*Default,NTP,0000,0000,0000,,那么我可以把打印二
Dialogue: 0,0:07:14.60,0:07:15.93,*Default,NTP,0000,0000,0000,,和打印二
Dialogue: 0,0:07:16.20,0:07:18.73,*Default,NTP,0000,0000,0000,,但为了将其合并为一个表达式
Dialogue: 0,0:07:18.73,0:07:21.07,*Default,NTP,0000,0000,0000,,我需要使用 begin 特殊形式
Dialogue: 0,0:07:21.30,0:07:24.27,*Default,NTP,0000,0000,0000,,begin 特殊表单只是说做所有这些事情
Dialogue: 0,0:07:25.47,0:07:28.00,*Default,NTP,0000,0000,0000,,比方说，我只能使用存储过程
Dialogue: 0,0:07:28.50,0:07:30.53,*Default,NTP,0000,0000,0000,,我想定义两次
Dialogue: 0,0:07:31.10,0:07:33.40,*Default,NTP,0000,0000,0000,,我将写出与幻灯片上相同的正文
Dialogue: 0,0:07:33.53,0:07:34.57,*Default,NTP,0000,0000,0000,,在幻灯片上
Dialogue: 0,0:07:34.87,0:07:38.40,*Default,NTP,0000,0000,0000,,开始表达式，然后再次表达式
Dialogue: 0,0:07:43.77,0:07:46.00,*Default,NTP,0000,0000,0000,,现在两次打印 ii 不起作用
Dialogue: 0,0:07:46.93,0:07:49.27,*Default,NTP,0000,0000,0000,,显示两次
Dialogue: 0,0:07:49.30,0:07:51.77,*Default,NTP,0000,0000,0000,,然后我构造了一个表达式，上面写着 begin none
Dialogue: 0,0:07:51.77,0:07:54.27,*Default,NTP,0000,0000,0000,,无 print ii 的值
Dialogue: 0,0:07:55.10,0:07:56.70,*Default,NTP,0000,0000,0000,,如果我想构造
Dialogue: 0,0:07:57.13,0:08:00.40,*Default,NTP,0000,0000,0000,,开始 print ii print ii，我就必须引用这句话。
Dialogue: 0,0:08:01.40,0:08:03.33,*Default,NTP,0000,0000,0000,,所以也不是不可能做到这一点
Dialogue: 0,0:08:03.33,0:08:04.30,*Default,NTP,0000,0000,0000,,程序
Dialogue: 0,0:08:04.33,0:08:06.60,*Default,NTP,0000,0000,0000,,我只是需要考虑引用
Dialogue: 0,0:08:06.77,0:08:08.67,*Default,NTP,0000,0000,0000,,以确保它不会被
Dialogue: 0,0:08:08.67,0:08:10.30,*Default,NTP,0000,0000,0000,,提前评估
Dialogue: 0,0:08:11.07,0:08:14.07,*Default,NTP,0000,0000,0000,,但即使是这个版本也还没有打印出任何东西
Dialogue: 0,0:08:14.40,0:08:15.10,*Default,NTP,0000,0000,0000,,打印的唯一方法
Dialogue: 0,0:08:15.10,0:08:18.67,*Default,NTP,0000,0000,0000,,打印的唯一办法是，如果我对调用
Dialogue: 0,0:08:18.67,0:08:20.90,*Default,NTP,0000,0000,0000,,的结果。
Dialogue: 0,0:08:23.57,0:08:24.60,*Default,NTP,0000,0000,0000,,宏背后的
Dialogue: 0,0:08:24.60,0:08:28.33,*Default,NTP,0000,0000,0000,,宏的理念是，这个引用和评估过程
Dialogue: 0,0:08:28.50,0:08:30.17,*Default,NTP,0000,0000,0000,,是由宏代劳的
Dialogue: 0,0:08:30.97,0:08:33.87,*Default,NTP,0000,0000,0000,,因此，如果不将其定义为存储过程
Dialogue: 0,0:08:33.90,0:08:35.90,*Default,NTP,0000,0000,0000,,而是定义为宏
Dialogue: 0,0:08:36.73,0:08:40.00,*Default,NTP,0000,0000,0000,,那么输入两次 quote print 2
Dialogue: 0,0:08:40.13,0:08:41.80,*Default,NTP,0000,0000,0000,,并计算结果
Dialogue: 0,0:08:41.93,0:08:43.67,*Default,NTP,0000,0000,0000,,我只需两次打印 2
Dialogue: 0,0:08:44.00,0:08:46.13,*Default,NTP,0000,0000,0000,,我就能看到两次显示
Dialogue: 0,0:08:47.50,0:08:49.00,*Default,NTP,0000,0000,0000,,这样，简单的事情和深刻的事情
Dialogue: 0,0:08:49.00,0:08:51.27,*Default,NTP,0000,0000,0000,,同时发生了
Dialogue: 0,0:08:51.53,0:08:53.80,*Default,NTP,0000,0000,0000,,简单的部分是，它所做的只是确保
Dialogue: 0,0:08:53.80,0:08:55.73,*Default,NTP,0000,0000,0000,,双胞胎 2 不会被求值
Dialogue: 0,0:08:55.73,0:08:57.27,*Default,NTP,0000,0000,0000,,例如引用它
Dialogue: 0,0:08:57.40,0:08:59.37,*Default,NTP,0000,0000,0000,,将表达式传递给 twice
Dialogue: 0,0:08:59.37,0:09:01.20,*Default,NTP,0000,0000,0000,,的表达式，然后对结果进行求值
Dialogue: 0,0:09:01.90,0:09:03.87,*Default,NTP,0000,0000,0000,,深奥之处在于，我们
Dialogue: 0,0:09:03.90,0:09:06.27,*Default,NTP,0000,0000,0000,,改变了语言的工作方式
Dialogue: 0,0:09:06.50,0:09:09.50,*Default,NTP,0000,0000,0000,,twice 现在是一种特殊形式
Dialogue: 0,0:09:09.60,0:09:13.17,*Default,NTP,0000,0000,0000,,的特殊形式，它不需要先评估参数
Dialogue: 0,0:09:13.40,0:09:15.60,*Default,NTP,0000,0000,0000,,这意味着我们可以完全控制
Dialogue: 0,0:09:15.70,0:09:17.13,*Default,NTP,0000,0000,0000,,这意味着我们可以完全控制
Dialogue: 0,0:09:17.13,0:09:19.73,*Default,NTP,0000,0000,0000,,这意味着我们可以完全控制在宏内部何时以及如何评估
Dialogue: 0,0:09:21.13,0:09:23.07,*Default,NTP,0000,0000,0000,,让我们看看这有什么用处
Dialogue: 0,0:09:24.00,0:09:25.40,*Default,NTP,0000,0000,0000,,假设我想定义
Dialogue: 0,0:09:25.40,0:09:28.17,*Default,NTP,0000,0000,0000,,一个存储过程，用于检查某些内容是真还是
Dialogue: 0,0:09:28.17,0:09:28.97,*Default,NTP,0000,0000,0000,,假
Dialogue: 0,0:09:29.93,0:09:34.37,*Default,NTP,0000,0000,0000,,如果我传入一个值，我就可以写 if the value is true
Dialogue: 0,0:09:34.57,0:09:36.67,*Default,NTP,0000,0000,0000,,则我通过了检查
Dialogue: 0,0:09:36.77,0:09:38.67,*Default,NTP,0000,0000,0000,,否则检查失败
Dialogue: 0,0:09:39.60,0:09:40.97,*Default,NTP,0000,0000,0000,,例如
Dialogue: 0,0:09:41.47,0:09:44.50,*Default,NTP,0000,0000,0000,,我有一个 x -2，我想检查
Dialogue: 0,0:09:44.87,0:09:46.77,*Default,NTP,0000,0000,0000,,x 大于零
Dialogue: 0,0:09:47.40,0:09:49.07,*Default,NTP,0000,0000,0000,,我的检查就会失败
Dialogue: 0,0:09:50.30,0:09:51.97,*Default,NTP,0000,0000,0000,,所以这是一个合理的方法
Dialogue: 0,0:09:51.97,0:09:55.27,*Default,NTP,0000,0000,0000,,在方案程序中添加小测试
Dialogue: 0,0:09:55.57,0:09:59.87,*Default,NTP,0000,0000,0000,,但遗憾的是，它不会告诉你失败的原因
Dialogue: 0,0:09:59.87,0:10:02.77,*Default,NTP,0000,0000,0000,,当有东西失败时，它的头部会很好看
Dialogue: 0,0:10:02.77,0:10:04.30,*Default,NTP,0000,0000,0000,,失败原因
Dialogue: 0,0:10:05.13,0:10:06.60,*Default,NTP,0000,0000,0000,,但要做到这一点
Dialogue: 0,0:10:06.60,0:10:10.17,*Default,NTP,0000,0000,0000,,我们需要访问被求值的表达式
Dialogue: 0,0:10:10.30,0:10:12.80,*Default,NTP,0000,0000,0000,,而不只是值本身
Dialogue: 0,0:10:14.20,0:10:15.87,*Default,NTP,0000,0000,0000,,因此，让我们定义一个宏
Dialogue: 0,0:10:17.77,0:10:18.57,*Default,NTP,0000,0000,0000,,首先
Dialogue: 0,0:10:18.80,0:10:21.30,*Default,NTP,0000,0000,0000,,为了保持一致，我们将其命名为 check
Dialogue: 0,0:10:21.30,0:10:23.07,*Default,NTP,0000,0000,0000,,但它并不接收一个值
Dialogue: 0,0:10:23.07,0:10:25.00,*Default,NTP,0000,0000,0000,,而是一个表达式
Dialogue: 0,0:10:25.80,0:10:29.70,*Default,NTP,0000,0000,0000,,而不是仅仅写下被评估的内容
Dialogue: 0,0:10:29.70,0:10:33.53,*Default,NTP,0000,0000,0000,,我必须一块一块地构建这个表达式
Dialogue: 0,0:10:34.53,0:10:37.53,*Default,NTP,0000,0000,0000,,检查表达式的方法是建立一个列表
Dialogue: 0,0:10:37.60,0:10:39.27,*Default,NTP,0000,0000,0000,,包含如果
Dialogue: 0,0:10:39.53,0:10:42.70,*Default,NTP,0000,0000,0000,,的表达式。
Dialogue: 0,0:10:43.73,0:10:46.60,*Default,NTP,0000,0000,0000,,然后显示通过或失败
Dialogue: 0,0:10:48.10,0:10:49.37,*Default,NTP,0000,0000,0000,,这里我用双引号
Dialogue: 0,0:10:49.37,0:10:52.17,*Default,NTP,0000,0000,0000,,表示我希望计算这个
Dialogue: 0,0:10:52.20,0:10:54.60,*Default,NTP,0000,0000,0000,,的结果是这个引号过去
Dialogue: 0,0:10:55.07,0:10:56.70,*Default,NTP,0000,0000,0000,,现在我创建了一个宏
Dialogue: 0,0:10:56.80,0:10:59.70,*Default,NTP,0000,0000,0000,,现在我创建了一个宏，它的行为就像我之前创建的存储过程一样
Dialogue: 0,0:11:01.27,0:11:05.47,*Default,NTP,0000,0000,0000,,因此，如果我启动程序并加载这个文件，定义
Dialogue: 0,0:11:05.90,0:11:08.97,*Default,NTP,0000,0000,0000,,x 为-2，然后检查 c
Dialogue: 0,0:11:09.07,0:11:11.70,*Default,NTP,0000,0000,0000,,x 是否大于零
Dialogue: 0,0:11:11.87,0:11:13.13,*Default,NTP,0000,0000,0000,,结果会显示失败
Dialogue: 0,0:11:14.57,0:11:17.00,*Default,NTP,0000,0000,0000,,所以我做了这么多工作来定义一个宏
Dialogue: 0,0:11:17.00,0:11:19.80,*Default,NTP,0000,0000,0000,,它比他们的程序稍微复杂一些
Dialogue: 0,0:11:20.27,0:11:22.57,*Default,NTP,0000,0000,0000,,而且它还没有做任何新的事情
Dialogue: 0,0:11:23.27,0:11:25.17,*Default,NTP,0000,0000,0000,,但我们可以让它做一些新的事情
Dialogue: 0,0:11:25.40,0:11:26.20,*Default,NTP,0000,0000,0000,,通过
Dialogue: 0,0:11:26.93,0:11:29.13,*Default,NTP,0000,0000,0000,,不仅说失败了
Dialogue: 0,0:11:29.17,0:11:31.70,*Default,NTP,0000,0000,0000,,还可以说什么表达式失败了
Dialogue: 0,0:11:32.47,0:11:34.70,*Default,NTP,0000,0000,0000,,所以，在这个失败的情况下
Dialogue: 0,0:11:34.80,0:11:36.53,*Default,NTP,0000,0000,0000,,我会新建一个列表
Dialogue: 0,0:11:36.87,0:11:39.50,*Default,NTP,0000,0000,0000,,它仍然会显示失败了
Dialogue: 0,0:11:39.77,0:11:42.27,*Default,NTP,0000,0000,0000,,但也会显示表达式
Dialogue: 0,0:11:51.90,0:11:53.33,*Default,NTP,0000,0000,0000,,现在我们运行整个过程
Dialogue: 0,0:11:53.73,0:11:55.00,*Default,NTP,0000,0000,0000,,和之前一样
Dialogue: 0,0:11:55.33,0:11:57.37,*Default,NTP,0000,0000,0000,,将 x 设为负数
Dialogue: 0,0:11:57.57,0:12:00.00,*Default,NTP,0000,0000,0000,,写下一个看似过程调用
Dialogue: 0,0:12:00.00,0:12:02.33,*Default,NTP,0000,0000,0000,,但实际上它不是一个过程调用
Dialogue: 0,0:12:02.53,0:12:06.73,*Default,NTP,0000,0000,0000,,因为当它失败时，它会告诉你它失败了
Dialogue: 0,0:12:07.07,0:12:08.67,*Default,NTP,0000,0000,0000,,这是一个假值
Dialogue: 0,0:12:09.10,0:12:12.53,*Default,NTP,0000,0000,0000,,同时也会告诉你导致失败的表达式
Dialogue: 0,0:12:12.93,0:12:14.00,*Default,NTP,0000,0000,0000,,而这是
Dialogue: 0,0:12:14.00,0:12:16.27,*Default,NTP,0000,0000,0000,,这一点是普通存储过程所不具备的。
Dialogue: 0,0:12:17.40,0:12:18.37,*Default,NTP,0000,0000,0000,,在结束之前
Dialogue: 0,0:12:18.37,0:12:19.40,*Default,NTP,0000,0000,0000,,让我们快速查看
Dialogue: 0,0:12:19.40,0:12:22.50,*Default,NTP,0000,0000,0000,,这个宏构造的表达式
Dialogue: 0,0:12:23.50,0:12:26.93,*Default,NTP,0000,0000,0000,,您可以通过删除破折号宏来做到这一点
Dialogue: 0,0:12:27.40,0:12:29.47,*Default,NTP,0000,0000,0000,,现在我们只有一个常规程序
Dialogue: 0,0:12:30.70,0:12:32.10,*Default,NTP,0000,0000,0000,,这个常规过程
Dialogue: 0,0:12:32.97,0:12:36.37,*Default,NTP,0000,0000,0000,,可以将 x 取为 -2，但当它被调用时
Dialogue: 0,0:12:36.53,0:12:40.40,*Default,NTP,0000,0000,0000,,时，我们必须明确引用表达式
Dialogue: 0,0:12:40.67,0:12:43.00,*Default,NTP,0000,0000,0000,,就像调用宏一样
Dialogue: 0,0:12:43.90,0:12:45.67,*Default,NTP,0000,0000,0000,,x 是否大于零
Dialogue: 0,0:12:45.90,0:12:48.47,*Default,NTP,0000,0000,0000,,构造以下表达式
Dialogue: 0,0:12:49.07,0:12:52.37,*Default,NTP,0000,0000,0000,,如果 x 大于零，则只表示过去
Dialogue: 0,0:12:52.50,0:12:53.40,*Default,NTP,0000,0000,0000,,否则
Dialogue: 0,0:12:53.67,0:12:57.60,*Default,NTP,0000,0000,0000,,它建立的列表失败，然后表达式
Dialogue: 0,0:12:58.77,0:13:00.57,*Default,NTP,0000,0000,0000,,如果我对
Dialogue: 0,0:13:00.57,0:13:02.67,*Default,NTP,0000,0000,0000,,就会得到失败的事实
Dialogue: 0,0:13:03.40,0:13:04.30,*Default,NTP,0000,0000,0000,,当然
Dialogue: 0,0:13:04.33,0:13:08.10,*Default,NTP,0000,0000,0000,,如果换成专家二，我评估同样的内容
Dialogue: 0,0:13:08.37,0:13:10.50,*Default,NTP,0000,0000,0000,,我就会看到它通过了
Dialogue: 0,0:13:11.13,0:13:12.93,*Default,NTP,0000,0000,0000,,所以我们从零开始
Dialogue: 0,0:13:12.97,0:13:15.87,*Default,NTP,0000,0000,0000,,一个宏，一个名为 check
Dialogue: 0,0:13:16.20,0:13:17.93,*Default,NTP,0000,0000,0000,,的宏，它可以检查
Dialogue: 0,0:13:17.93,0:13:20.20,*Default,NTP,0000,0000,0000,,表达式是真还是假。
Dialogue: 0,0:13:20.20,0:13:23.13,*Default,NTP,0000,0000,0000,,如果是假的，它就会向你显示
Dialogue: 0,0:13:23.13,0:13:24.00,*Default,NTP,0000,0000,0000,,表达式
Dialogue: 0,0:13:26.50,0:13:29.17,*Default,NTP,0000,0000,0000,,方案中没有四语句
Dialogue: 0,0:13:29.87,0:13:33.97,*Default,NTP,0000,0000,0000,,现在有了，我们将创建一个四元微语句
Dialogue: 0,0:13:35.53,0:13:36.40,*Default,NTP,0000,0000,0000,,我们要定义
Dialogue: 0,0:13:36.40,0:13:38.80,*Default,NTP,0000,0000,0000,,对表达式进行求值的宏
Dialogue: 0,0:13:38.90,0:13:40.87,*Default,NTP,0000,0000,0000,,的表达式
Dialogue: 0,0:13:42.13,0:13:47.47,*Default,NTP,0000,0000,0000,,例如，如果我说 2345 平方 x 中的 4 x
Dialogue: 0,0:13:47.53,0:13:50.70,*Default,NTP,0000,0000,0000,,我应该得到 2、3、4 和 5 的平方值
Dialogue: 0,0:13:51.10,0:13:52.10,*Default,NTP,0000,0000,0000,,多方便啊
Dialogue: 0,0:13:53.73,0:13:55.93,*Default,NTP,0000,0000,0000,,我们将分两步构建这个宏
Dialogue: 0,0:13:56.33,0:13:57.50,*Default,NTP,0000,0000,0000,,首先，我们定义
Dialogue: 0,0:13:57.50,0:14:00.47,*Default,NTP,0000,0000,0000,,函数映射值的含义
Dialogue: 0,0:14:01.13,0:14:04.67,*Default,NTP,0000,0000,0000,,如果 values 为空，则映射列表中什么都没有
Dialogue: 0,0:14:04.87,0:14:07.67,*Default,NTP,0000,0000,0000,,否则，我们就将 fun
Dialogue: 0,0:14:07.80,0:14:09.33,*Default,NTP,0000,0000,0000,,的车
Dialogue: 0,0:14:09.37,0:14:11.40,*Default,NTP,0000,0000,0000,,时得到的任何结果
Dialogue: 0,0:14:11.40,0:14:13.07,*Default,NTP,0000,0000,0000,,时得到的结果
Dialogue: 0,0:14:13.87,0:14:14.93,*Default,NTP,0000,0000,0000,,在这种情况下
Dialogue: 0,0:14:15.00,0:14:18.30,*Default,NTP,0000,0000,0000,,在这种情况下，我们只需使用
Dialogue: 0,0:14:18.30,0:14:20.67,*Default,NTP,0000,0000,0000,,语句。
Dialogue: 0,0:14:20.80,0:14:22.97,*Default,NTP,0000,0000,0000,,但这需要更多的工作
Dialogue: 0,0:14:23.00,0:14:24.30,*Default,NTP,0000,0000,0000,,我必须说 map
Dialogue: 0,0:14:24.33,0:14:27.17,*Default,NTP,0000,0000,0000,,然后我必须给出一个 lambda 表达式
Dialogue: 0,0:14:27.57,0:14:30.90,*Default,NTP,0000,0000,0000,,以捕获这个主体
Dialogue: 0,0:14:31.37,0:14:33.67,*Default,NTP,0000,0000,0000,,然后我还得说我想把它应用到什么地方
Dialogue: 0,0:14:35.97,0:14:38.73,*Default,NTP,0000,0000,0000,,因此，在语言中使用四表达式
Dialogue: 0,0:14:38.77,0:14:40.60,*Default,NTP,0000,0000,0000,,并不意味着我可以做新的事情
Dialogue: 0,0:14:40.60,0:14:41.87,*Default,NTP,0000,0000,0000,,它只是意味着
Dialogue: 0,0:14:42.07,0:14:44.50,*Default,NTP,0000,0000,0000,,更直接地说明我想要什么
Dialogue: 0,0:14:44.50,0:14:46.87,*Default,NTP,0000,0000,0000,,因为我不必明确写出
Dialogue: 0,0:14:46.87,0:14:48.27,*Default,NTP,0000,0000,0000,,单词
Dialogue: 0,0:14:50.30,0:14:52.30,*Default,NTP,0000,0000,0000,,定义宏
Dialogue: 0,0:14:52.50,0:14:56.20,*Default,NTP,0000,0000,0000,,就是说当你有四个
Dialogue: 0,0:14:56.20,0:14:58.27,*Default,NTP,0000,0000,0000,,然后是一个符号和一些值
Dialogue: 0,0:14:58.27,0:15:00.27,*Default,NTP,0000,0000,0000,,和一个表达式
Dialogue: 0,0:15:00.30,0:15:02.07,*Default,NTP,0000,0000,0000,,对每个值
Dialogue: 0,0:15:02.50,0:15:05.57,*Default,NTP,0000,0000,0000,,我们要做的就是构建这个表达式
Dialogue: 0,0:15:06.13,0:15:08.13,*Default,NTP,0000,0000,0000,,这是一个包含 map 的列表
Dialogue: 0,0:15:08.50,0:15:11.97,*Default,NTP,0000,0000,0000,,然后包含 lambda x 和表达式
Dialogue: 0,0:15:12.37,0:15:15.27,*Default,NTP,0000,0000,0000,,最后包含值
Dialogue: 0,0:15:16.00,0:15:18.37,*Default,NTP,0000,0000,0000,,花点时间，看看能否写出
Dialogue: 0,0:15:18.67,0:15:21.70,*Default,NTP,0000,0000,0000,,的一般宏定义
Dialogue: 0,0:15:21.87,0:15:25.57,*Default,NTP,0000,0000,0000,,的一般宏定义，让我们把这三个表达式
Dialogue: 0,0:15:25.70,0:15:27.90,*Default,NTP,0000,0000,0000,,变成这个长的映射表达式
Dialogue: 0,0:15:28.27,0:15:31.70,*Default,NTP,0000,0000,0000,,我将在 321 中向你展示答案
Dialogue: 0,0:15:33.60,0:15:38.30,*Default,NTP,0000,0000,0000,,在这里，我们建立了一个以 lambda 开头的列表
Dialogue: 0,0:15:38.70,0:15:42.33,*Default,NTP,0000,0000,0000,,开头的列表，然后将我用作占位符的符号
Dialogue: 0,0:15:42.33,0:15:43.50,*Default,NTP,0000,0000,0000,,的每一个值
Dialogue: 0,0:15:44.60,0:15:46.07,*Default,NTP,0000,0000,0000,,值的占位符
Dialogue: 0,0:15:46.07,0:15:48.33,*Default,NTP,0000,0000,0000,,因为这就是 lambda 表达式的工作原理
Dialogue: 0,0:15:49.13,0:15:52.73,*Default,NTP,0000,0000,0000,,现在，experor 将被绑定到这个整体的 xx 次上。
Dialogue: 0,0:15:52.87,0:15:54.30,*Default,NTP,0000,0000,0000,,所以我把这个
Dialogue: 0,0:15:54.30,0:15:56.70,*Default,NTP,0000,0000,0000,,放到我正在构建的 lamda 表达式中
Dialogue: 0,0:15:56.70,0:15:57.73,*Default,NTP,0000,0000,0000,,作为一个列表
Dialogue: 0,0:15:58.40,0:16:00.73,*Default,NTP,0000,0000,0000,,最后我写下值
Dialogue: 0,0:16:00.87,0:16:03.10,*Default,NTP,0000,0000,0000,,然后当我在这里运行
Dialogue: 0,0:16:03.20,0:16:04.93,*Default,NTP,0000,0000,0000,,这三个表达式时
Dialogue: 0,0:16:04.93,0:16:08.27,*Default,NTP,0000,0000,0000,,我将构建这个 map 表达式，然后对其进行评估
Dialogue: 0,0:16:08.30,0:16:11.20,*Default,NTP,0000,0000,0000,,我将得到 9 16 25 的结果
Dialogue: 0,0:16:12.17,0:16:13.77,*Default,NTP,0000,0000,0000,,所以还有另一种方法可以
Dialogue: 0,0:16:13.77,0:16:15.10,*Default,NTP,0000,0000,0000,,扩展语法
Dialogue: 0,0:16:15.10,0:16:16.10,*Default,NTP,0000,0000,0000,,的另一种方式
Dialogue: 0,0:16:16.27,0:16:19.07,*Default,NTP,0000,0000,0000,,将被求值的内容混合在一起
Dialogue: 0,0:16:19.30,0:16:21.10,*Default,NTP,0000,0000,0000,,永远不会被求值的东西
Dialogue: 0,0:16:21.10,0:16:23.90,*Default,NTP,0000,0000,0000,,只是作为占位符使用的符号
Dialogue: 0,0:16:24.27,0:16:27.10,*Default,NTP,0000,0000,0000,,和一个会被求值的表达式
Dialogue: 0,0:16:27.10,0:16:29.50,*Default,NTP,0000,0000,0000,,的表达式
Dialogue: 0,0:16:31.20,0:16:33.30,*Default,NTP,0000,0000,0000,,现在我们发现
Dialogue: 0,0:16:33.30,0:16:35.27,*Default,NTP,0000,0000,0000,,有四条语句
Dialogue: 0,0:16:37.93,0:16:39.50,*Default,NTP,0000,0000,0000,,现在我们已经讨论了
Dialogue: 0,0:16:39.70,0:16:43.20,*Default,NTP,0000,0000,0000,,什么是宏以及如何定义宏 如何使用宏
Dialogue: 0,0:16:43.33,0:16:45.20,*Default,NTP,0000,0000,0000,,让我们来讨论一下
Dialogue: 0,0:16:45.20,0:16:47.20,*Default,NTP,0000,0000,0000,,为了支持宏
Dialogue: 0,0:16:47.20,0:16:49.10,*Default,NTP,0000,0000,0000,,为了支持宏
Dialogue: 0,0:16:49.70,0:16:52.73,*Default,NTP,0000,0000,0000,,事实上，在项目四中有一个关于宏的选做题
Dialogue: 0,0:16:53.30,0:16:56.40,*Default,NTP,0000,0000,0000,,所以如果你已经完成了项目四
Dialogue: 0,0:16:56.40,0:16:58.10,*Default,NTP,0000,0000,0000,,并想找点别的事情做
Dialogue: 0,0:16:58.13,0:16:59.70,*Default,NTP,0000,0000,0000,,扩展你的解释器
Dialogue: 0,0:16:59.93,0:17:01.17,*Default,NTP,0000,0000,0000,,这里可以添加
Dialogue: 0,0:17:01.20,0:17:02.97,*Default,NTP,0000,0000,0000,,因为它不需要很多代码
Dialogue: 0,0:17:03.07,0:17:05.97,*Default,NTP,0000,0000,0000,,但却能教会你宏如何工作
Dialogue: 0,0:17:06.70,0:17:08.60,*Default,NTP,0000,0000,0000,,解决这个问题其实有两个部分
Dialogue: 0,0:17:08.73,0:17:09.97,*Default,NTP,0000,0000,0000,,一是
Dialogue: 0,0:17:10.00,0:17:13.07,*Default,NTP,0000,0000,0000,,实现已定义宏的特殊形式如何工作
Dialogue: 0,0:17:13.17,0:17:14.70,*Default,NTP,0000,0000,0000,,这其实是最简单的部分
Dialogue: 0,0:17:14.70,0:17:16.97,*Default,NTP,0000,0000,0000,,就像定义过程一样
Dialogue: 0,0:17:17.70,0:17:19.33,*Default,NTP,0000,0000,0000,,稍微复杂的部分是
Dialogue: 0,0:17:19.33,0:17:21.70,*Default,NTP,0000,0000,0000,,当你有一个调用表达式时
Dialogue: 0,0:17:21.97,0:17:24.53,*Default,NTP,0000,0000,0000,,其中第一个表达式的运算符
Dialogue: 0,0:17:24.80,0:17:26.67,*Default,NTP,0000,0000,0000,,评估为一个宏
Dialogue: 0,0:17:27.60,0:17:31.37,*Default,NTP,0000,0000,0000,,对宏的调用有不同的评估过程
Dialogue: 0,0:17:31.57,0:17:33.67,*Default,NTP,0000,0000,0000,,与调用正则表达式不同
Dialogue: 0,0:17:34.37,0:17:37.87,*Default,NTP,0000,0000,0000,,因此，如果你看一下这里，就会发现这里说的是执行定义的宏
Dialogue: 0,0:17:37.97,0:17:40.10,*Default,NTP,0000,0000,0000,,通过执行已定义的宏
Dialogue: 0,0:17:40.10,0:17:41.47,*Default,NTP,0000,0000,0000,,这是什么意思？
Dialogue: 0,0:17:41.50,0:17:43.67,*Default,NTP,0000,0000,0000,,请记住，模式值
Dialogue: 0,0:17:43.80,0:17:44.70,*Default,NTP,0000,0000,0000,,会检查
Dialogue: 0,0:17:44.70,0:17:47.20,*Default,NTP,0000,0000,0000,,第一个符号是否属于特殊形式
Dialogue: 0,0:17:47.37,0:17:49.53,*Default,NTP,0000,0000,0000,,定义宏就是特殊形式之一
Dialogue: 0,0:17:49.60,0:17:52.50,*Default,NTP,0000,0000,0000,,所以它会调用定义宏函数
Dialogue: 0,0:17:52.50,0:17:53.93,*Default,NTP,0000,0000,0000,,函数
Dialogue: 0,0:17:54.07,0:17:56.90,*Default,NTP,0000,0000,0000,,这样就可以创建一个新的宏，就像创建一个新的 lambda 过程一样。
Dialogue: 0,0:17:57.17,0:17:59.70,*Default,NTP,0000,0000,0000,,就像创建一个新的 lambda 过程一样
Dialogue: 0,0:17:59.90,0:18:02.30,*Default,NTP,0000,0000,0000,,并将其与定义表达式中给出的名称绑定
Dialogue: 0,0:18:02.50,0:18:04.57,*Default,NTP,0000,0000,0000,,定义表达式中给出的名称
Dialogue: 0,0:18:05.60,0:18:06.47,*Default,NTP,0000,0000,0000,,关于宏
Dialogue: 0,0:18:06.47,0:18:09.33,*Default,NTP,0000,0000,0000,,宏的有趣之处在于，当你调用宏时，会发生什么？
Dialogue: 0,0:18:09.37,0:18:11.20,*Default,NTP,0000,0000,0000,,使用宏时
Dialogue: 0,0:18:11.20,0:18:12.87,*Default,NTP,0000,0000,0000,,就是编写一个调用表达式
Dialogue: 0,0:18:13.13,0:18:16.33,*Default,NTP,0000,0000,0000,,其中的运算符求值为某个宏
Dialogue: 0,0:18:16.47,0:18:19.73,*Default,NTP,0000,0000,0000,,例如
Dialogue: 0,0:18:20.40,0:18:22.20,*Default,NTP,0000,0000,0000,,绑定到一个宏过程
Dialogue: 0,0:18:22.20,0:18:23.90,*Default,NTP,0000,0000,0000,,在刚才的示例中
Dialogue: 0,0:18:24.27,0:18:26.17,*Default,NTP,0000,0000,0000,,因此，在这里我们会遇到 else 情况
Dialogue: 0,0:18:26.17,0:18:28.70,*Default,NTP,0000,0000,0000,,在这种情况下，我们试图求值一个调用表达式
Dialogue: 0,0:18:29.40,0:18:32.37,*Default,NTP,0000,0000,0000,,我们会计算构成调用表达式的
Dialogue: 0,0:18:32.60,0:18:35.20,*Default,NTP,0000,0000,0000,,表达式列表中的第一个表达式
Dialogue: 0,0:18:35.27,0:18:36.93,*Default,NTP,0000,0000,0000,,也许是符号 flr
Dialogue: 0,0:18:37.00,0:18:39.80,*Default,NTP,0000,0000,0000,,当这个符号被求值时，你会得到一个宏
Dialogue: 0,0:18:39.80,0:18:41.70,*Default,NTP,0000,0000,0000,,这是一个特例
Dialogue: 0,0:18:41.97,0:18:44.07,*Default,NTP,0000,0000,0000,,通常，在调用表达式中要做的是
Dialogue: 0,0:18:44.07,0:18:45.87,*Default,NTP,0000,0000,0000,,先评估所有操作数
Dialogue: 0,0:18:45.87,0:18:48.10,*Default,NTP,0000,0000,0000,,然后在参数上调用存储过程
Dialogue: 0,0:18:48.10,0:18:50.10,*Default,NTP,0000,0000,0000,,即操作数的值
Dialogue: 0,0:18:50.13,0:18:51.70,*Default,NTP,0000,0000,0000,,但宏不同
Dialogue: 0,0:18:52.40,0:18:55.13,*Default,NTP,0000,0000,0000,,而不是将宏
Dialogue: 0,0:18:55.13,0:18:58.73,*Default,NTP,0000,0000,0000,,的表达式。
Dialogue: 0,0:18:58.87,0:19:00.67,*Default,NTP,0000,0000,0000,,的表达式。
Dialogue: 0,0:19:00.90,0:19:04.00,*Default,NTP,0000,0000,0000,,这些表达式可能是符号，也可能是列表
Dialogue: 0,0:19:04.07,0:19:05.27,*Default,NTP,0000,0000,0000,,什么都可以
Dialogue: 0,0:19:05.27,0:19:07.60,*Default,NTP,0000,0000,0000,,但它们是方案代码的片段
Dialogue: 0,0:19:07.67,0:19:10.07,*Default,NTP,0000,0000,0000,,作为宏的参数
Dialogue: 0,0:19:10.53,0:19:12.17,*Default,NTP,0000,0000,0000,,然后宏返回
Dialogue: 0,0:19:12.17,0:19:13.90,*Default,NTP,0000,0000,0000,,这是一个方案表达式
Dialogue: 0,0:19:13.90,0:19:16.20,*Default,NTP,0000,0000,0000,,也必须进行评估
Dialogue: 0,0:19:16.80,0:19:18.80,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:19:18.80,0:19:20.10,*Default,NTP,0000,0000,0000,,评估操作符
Dialogue: 0,0:19:20.10,0:19:21.37,*Default,NTP,0000,0000,0000,,评估操作数
Dialogue: 0,0:19:21.37,0:19:23.33,*Default,NTP,0000,0000,0000,,调用参数上的存储过程
Dialogue: 0,0:19:23.37,0:19:26.07,*Default,NTP,0000,0000,0000,,取而代之的是
Dialogue: 0,0:19:26.50,0:19:28.87,*Default,NTP,0000,0000,0000,,对操作数进行运算
Dialogue: 0,0:19:28.87,0:19:31.67,*Default,NTP,0000,0000,0000,,返回一个表达式
Dialogue: 0,0:19:32.47,0:19:35.13,*Default,NTP,0000,0000,0000,,所有这些都可以用方案 apply
Dialogue: 0,0:19:35.13,0:19:36.17,*Default,NTP,0000,0000,0000,,和模式值
Dialogue: 0,0:19:36.53,0:19:38.90,*Default,NTP,0000,0000,0000,,就像使用正则表达式一样
Dialogue: 0,0:19:38.90,0:19:40.97,*Default,NTP,0000,0000,0000,,但在
Dialogue: 0,0:19:40.97,0:19:42.17,*Default,NTP,0000,0000,0000,,中发生的特定顺序有点不同
Dialogue: 0,0:19:42.40,0:19:44.70,*Default,NTP,0000,0000,0000,,这就是在方案解释器中补充宏
Dialogue: 0,0:19:44.70,0:19:46.07,*Default,NTP,0000,0000,0000,,的宏
