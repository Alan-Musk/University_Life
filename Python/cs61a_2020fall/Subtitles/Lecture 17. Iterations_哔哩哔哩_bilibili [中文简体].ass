[Script Info]
Title: Lecture 17. Iterations_哔哩哔哩_bilibili
ScriptType: v4.00+
Collisions: Reverse
PlayResX: 1280
PlayResY: 720
WrapStyle: 3
ScaledBorderAndShadow: yes
; ----------------------
; 本字幕由CC字幕助手自动转换
; 字幕来源https://www.bilibili.com/video/BV1s3411G7yM?p=41&vd_source=6ffca0aa1006734a4fba52f389036611
; 脚本地址https://greasyfork.org/scripts/378513
; 设置了字幕过长自动换行，但若字幕中没有空格换行将无效
; 字体大小依据720p 48号字体等比缩放
; 如显示不正常请尝试使用SRT格式

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Segoe UI,48,&H00FFFFFF,&HF0000000,&H00000000,&HF0000000,1,0,0,0,100,100,0,0.00,1,1,3,2,30,30,20,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.70,0:00:02.97,*Default,NTP,0000,0000,0000,,61第17讲
Dialogue: 0,0:00:03.40,0:00:04.37,*Default,NTP,0000,0000,0000,,公告
Dialogue: 0,0:00:05.20,0:00:07.47,*Default,NTP,0000,0000,0000,,作业三周四交
Dialogue: 0,0:00:07.80,0:00:08.97,*Default,NTP,0000,0000,0000,,你可以修改你的
Dialogue: 0,0:00:08.97,0:00:10.57,*Default,NTP,0000,0000,0000,,养猪项目赚钱
Dialogue: 0,0:00:10.57,0:00:13.37,*Default,NTP,0000,0000,0000,,在周五之前补回所有丢失的作文分数
Dialogue: 0,0:00:13.53,0:00:15.10,*Default,NTP,0000,0000,0000,,这是广场帖子的链接
Dialogue: 0,0:00:15.10,0:00:16.60,*Default,NTP,0000,0000,0000,,关于具体如何做到这一点
Dialogue: 0,0:00:17.60,0:00:19.70,*Default,NTP,0000,0000,0000,,关键部分是你提交
Dialogue: 0,0:00:19.73,0:00:20.97,*Default,NTP,0000,0000,0000,,通过输入 python 3
Dialogue: 0,0:00:20.97,0:00:24.77,*Default,NTP,0000,0000,0000,,好的，从你的 hog 目录中修改 dash dash
Dialogue: 0,0:00:24.80,0:00:27.00,*Default,NTP,0000,0000,0000,,当你做了任何你想要的改变之后
Dialogue: 0,0:00:28.10,0:00:30.30,*Default,NTP,0000,0000,0000,,请参加讨论指导
Dialogue: 0,0:00:30.33,0:00:32.47,*Default,NTP,0000,0000,0000,,在你的教程之前
Dialogue: 0,0:00:32.70,0:00:34.57,*Default,NTP,0000,0000,0000,,我明白很多人都已经
Dialogue: 0,0:00:34.57,0:00:35.97,*Default,NTP,0000,0000,0000,,即将进入教程
Dialogue: 0,0:00:36.30,0:00:39.40,*Default,NTP,0000,0000,0000,,无需先进行讨论指导
Dialogue: 0,0:00:39.77,0:00:42.87,*Default,NTP,0000,0000,0000,,教程旨在跟进
Dialogue: 0,0:00:42.93,0:00:45.90,*Default,NTP,0000,0000,0000,,关于讨论导向中发生的事情
Dialogue: 0,0:00:46.53,0:00:48.50,*Default,NTP,0000,0000,0000,,所以如果你不去参加培训
Dialogue: 0,0:00:48.53,0:00:51.27,*Default,NTP,0000,0000,0000,,您将无法真正参与教程
Dialogue: 0,0:00:51.30,0:00:53.73,*Default,NTP,0000,0000,0000,,你就会失去学习经验
Dialogue: 0,0:00:54.57,0:00:56.27,*Default,NTP,0000,0000,0000,,如果你看看核心时间表
Dialogue: 0,0:00:56.73,0:00:59.47,*Default,NTP,0000,0000,0000,,几周后我们就要期中考试了
Dialogue: 0,0:00:59.57,0:01:02.57,*Default,NTP,0000,0000,0000,,期中考试第二期定于 28 日星期三举行
Dialogue: 0,0:01:03.00,0:01:05.17,*Default,NTP,0000,0000,0000,,距离明天还有三周
Dialogue: 0,0:01:05.40,0:01:08.80,*Default,NTP,0000,0000,0000,,核心人员整理了一份学习指南
Dialogue: 0,0:01:09.40,0:01:11.77,*Default,NTP,0000,0000,0000,,这为您提供了一些有关如何准备的建议
Dialogue: 0,0:01:12.00,0:01:14.47,*Default,NTP,0000,0000,0000,,不仅仅是前一天或当天
Dialogue: 0,0:01:14.73,0:01:17.77,*Default,NTP,0000,0000,0000,,但在考试前几周
Dialogue: 0,0:01:18.13,0:01:19.57,*Default,NTP,0000,0000,0000,,本学习指南主要是
Dialogue: 0,0:01:19.57,0:01:21.40,*Default,NTP,0000,0000,0000,,关于如何掌握材料
Dialogue: 0,0:01:24.27,0:01:25.60,*Default,NTP,0000,0000,0000,,并注意到
Dialogue: 0,0:01:25.60,0:01:28.10,*Default,NTP,0000,0000,0000,,重要的组成部分是实际观看讲座
Dialogue: 0,0:01:28.10,0:01:29.37,*Default,NTP,0000,0000,0000,,所以你做的是正确的事
Dialogue: 0,0:01:29.37,0:01:31.10,*Default,NTP,0000,0000,0000,,现在结束这个讲座
Dialogue: 0,0:01:31.10,0:01:32.87,*Default,NTP,0000,0000,0000,,然后看看学习指南
Dialogue: 0,0:01:32.97,0:01:34.47,*Default,NTP,0000,0000,0000,,我希望它能帮助你
Dialogue: 0,0:01:35.33,0:01:37.87,*Default,NTP,0000,0000,0000,,最后我们将担任顾问办公室
Dialogue: 0,0:01:37.87,0:01:39.37,*Default,NTP,0000,0000,0000,,周五的时间
Dialogue: 0,0:01:39.67,0:01:41.50,*Default,NTP,0000,0000,0000,,除了正常的办公时间
Dialogue: 0,0:01:41.50,0:01:43.50,*Default,NTP,0000,0000,0000,,帮助你完成实验室和家庭作业
Dialogue: 0,0:01:43.90,0:01:45.70,*Default,NTP,0000,0000,0000,,因为星期五没什么可做的
Dialogue: 0,0:01:45.87,0:01:48.60,*Default,NTP,0000,0000,0000,,我们将在正常办公时间举行这些活动
Dialogue: 0,0:01:48.60,0:01:49.40,*Default,NTP,0000,0000,0000,,q
Dialogue: 0,0:01:50.10,0:01:53.10,*Default,NTP,0000,0000,0000,,所以如果您想与经验丰富的工作人员交谈
Dialogue: 0,0:01:53.27,0:01:53.93,*Default,NTP,0000,0000,0000,,关于任何事情
Dialogue: 0,0:01:53.93,0:01:56.53,*Default,NTP,0000,0000,0000,,与课程或伯克利总体相关
Dialogue: 0,0:01:56.90,0:01:58.53,*Default,NTP,0000,0000,0000,,周五过来
Dialogue: 0,0:01:58.73,0:02:00.57,*Default,NTP,0000,0000,0000,,然后他们会很乐意与你交谈
Dialogue: 0,0:02:02.10,0:02:03.33,*Default,NTP,0000,0000,0000,,顺序数据
Dialogue: 0,0:02:03.60,0:02:08.27,*Default,NTP,0000,0000,0000,,可以使用迭代器隐式表示
Dialogue: 0,0:02:09.37,0:02:11.73,*Default,NTP,0000,0000,0000,,迭代器是通用接口
Dialogue: 0,0:02:11.73,0:02:13.67,*Default,NTP,0000,0000,0000,,在许多编程语言中
Dialogue: 0,0:02:13.90,0:02:15.77,*Default,NTP,0000,0000,0000,,它们被用在 python 中
Dialogue: 0,0:02:16.10,0:02:16.93,*Default,NTP,0000,0000,0000,,作为一种方法
Dialogue: 0,0:02:16.93,0:02:20.70,*Default,NTP,0000,0000,0000,,访问许多不同容器的元素
Dialogue: 0,0:02:21.93,0:02:24.13,*Default,NTP,0000,0000,0000,,容器可以提供迭代器
Dialogue: 0,0:02:24.57,0:02:25.33,*Default,NTP,0000,0000,0000,,反过来
Dialogue: 0,0:02:25.33,0:02:28.20,*Default,NTP,0000,0000,0000,,以某种顺序提供对其元素的访问
Dialogue: 0,0:02:29.77,0:02:33.30,*Default,NTP,0000,0000,0000,,内置函数 iter 和 next create
Dialogue: 0,0:02:33.30,0:02:36.07,*Default,NTP,0000,0000,0000,,分别是高级迭代器
Dialogue: 0,0:02:36.77,0:02:38.57,*Default,NTP,0000,0000,0000,,所以 itter 接受任何 itter 的东西
Dialogue: 0,0:02:38.57,0:02:39.97,*Default,NTP,0000,0000,0000,,这可能是一个容器
Dialogue: 0,0:02:40.00,0:02:41.80,*Default,NTP,0000,0000,0000,,或者你自己创造的东西
Dialogue: 0,0:02:42.33,0:02:44.90,*Default,NTP,0000,0000,0000,,它在元素上的迭代器中返回
Dialogue: 0,0:02:45.00,0:02:46.50,*Default,NTP,0000,0000,0000,,具有可迭代的值
Dialogue: 0,0:02:46.87,0:02:48.93,*Default,NTP,0000,0000,0000,,next 是一个内置函数
Dialogue: 0,0:02:49.07,0:02:51.77,*Default,NTP,0000,0000,0000,,返回迭代器中的下一个元素
Dialogue: 0,0:02:52.67,0:02:54.20,*Default,NTP,0000,0000,0000,,假设我有一个容器
Dialogue: 0,0:02:54.20,0:02:56.87,*Default,NTP,0000,0000,0000,,包含三、四和五的列表
Dialogue: 0,0:02:57.30,0:03:01.40,*Default,NTP,0000,0000,0000,,如果我在该列表 s 上调用 iter，我会得到一个迭代器 t
Dialogue: 0,0:03:02.27,0:03:03.47,*Default,NTP,0000,0000,0000,,那个迭代器
Dialogue: 0,0:03:03.77,0:03:06.17,*Default,NTP,0000,0000,0000,,知道列表的内容
Dialogue: 0,0:03:06.30,0:03:09.60,*Default,NTP,0000,0000,0000,,它还有一个标记来指示下一步
Dialogue: 0,0:03:09.90,0:03:12.80,*Default,NTP,0000,0000,0000,,所以你可以将迭代器视为一个位置
Dialogue: 0,0:03:12.80,0:03:14.10,*Default,NTP,0000,0000,0000,,按某种顺序
Dialogue: 0,0:03:14.60,0:03:17.70,*Default,NTP,0000,0000,0000,,它使您可以访问该位置的元素
Dialogue: 0,0:03:17.87,0:03:19.73,*Default,NTP,0000,0000,0000,,以及之后的一切
Dialogue: 0,0:03:20.90,0:03:23.73,*Default,NTP,0000,0000,0000,,如果我接下来打电话，我会得到 3 号
Dialogue: 0,0:03:24.37,0:03:26.87,*Default,NTP,0000,0000,0000,,作为调用下一个的结果
Dialogue: 0,0:03:27.00,0:03:29.60,*Default,NTP,0000,0000,0000,,这里的标记将会前进
Dialogue: 0,0:03:30.10,0:03:32.53,*Default,NTP,0000,0000,0000,,这意味着下次我打电话下一次
Dialogue: 0,0:03:32.57,0:03:34.87,*Default,NTP,0000,0000,0000,,我会得到四个而不是三个
Dialogue: 0,0:03:35.17,0:03:38.30,*Default,NTP,0000,0000,0000,,自从我打了两次 next 电话以来，我已经进步了两次
Dialogue: 0,0:03:38.30,0:03:40.20,*Default,NTP,0000,0000,0000,,现在标记设置为 5
Dialogue: 0,0:03:41.87,0:03:45.17,*Default,NTP,0000,0000,0000,,如果我为同一个容器创建第二个迭代器
Dialogue: 0,0:03:45.67,0:03:49.07,*Default,NTP,0000,0000,0000,,这意味着我在同一个列表中有第二个标记
Dialogue: 0,0:03:49.77,0:03:54.10,*Default,NTP,0000,0000,0000,,所以你是一个根本没有高级的迭代器
Dialogue: 0,0:03:54.47,0:03:57.37,*Default,NTP,0000,0000,0000,,如果我接下来打电话给你，我会得到 3 号
Dialogue: 0,0:03:58.33,0:04:00.80,*Default,NTP,0000,0000,0000,,现在他不会忘记它在哪里
Dialogue: 0,0:04:00.80,0:04:02.57,*Default,NTP,0000,0000,0000,,只因为我创造了你
Dialogue: 0,0:04:03.13,0:04:07.20,*Default,NTP,0000,0000,0000,,所以如果我问接下来会发生什么，我会得到第五名
Dialogue: 0,0:04:07.50,0:04:10.80,*Default,NTP,0000,0000,0000,,并且迭代器将前进到最后一个元素
Dialogue: 0,0:04:10.93,0:04:13.70,*Default,NTP,0000,0000,0000,,说它在这个列表的末尾
Dialogue: 0,0:04:14.10,0:04:16.90,*Default,NTP,0000,0000,0000,,依然是我可以向你索要元素
Dialogue: 0,0:04:16.90,0:04:19.67,*Default,NTP,0000,0000,0000,,所以如果我问你接下来会做什么，它会说
Dialogue: 0,0:04:20.60,0:04:23.70,*Default,NTP,0000,0000,0000,,所以 t 和你正在迭代相同的值
Dialogue: 0,0:04:23.70,0:04:26.27,*Default,NTP,0000,0000,0000,,但他们在这个职位上是独立的
Dialogue: 0,0:04:26.37,0:04:28.90,*Default,NTP,0000,0000,0000,,他们接下来会给你
Dialogue: 0,0:04:30.20,0:04:32.27,*Default,NTP,0000,0000,0000,,好吧，让我们自己建立一个清单
Dialogue: 0,0:04:32.27,0:04:34.13,*Default,NTP,0000,0000,0000,,这比以前稍微复杂一点
Dialogue: 0,0:04:34.13,0:04:35.60,*Default,NTP,0000,0000,0000,,你之前看到的那个
Dialogue: 0,0:04:35.90,0:04:37.57,*Default,NTP,0000,0000,0000,,这是一个嵌套列表
Dialogue: 0,0:04:37.60,0:04:41.97,*Default,NTP,0000,0000,0000,,如果我询问列表中的下一个值，我会收到错误
Dialogue: 0,0:04:41.97,0:04:43.67,*Default,NTP,0000,0000,0000,,那不是下一步要做的
Dialogue: 0,0:04:43.80,0:04:46.87,*Default,NTP,0000,0000,0000,,next 首先期望您创建一个迭代器
Dialogue: 0,0:04:46.87,0:04:49.37,*Default,NTP,0000,0000,0000,,超过某些容器的内容
Dialogue: 0,0:04:49.97,0:04:53.47,*Default,NTP,0000,0000,0000,,此时我可以询问 t 的下一个值
Dialogue: 0,0:04:53.60,0:04:55.90,*Default,NTP,0000,0000,0000,,这会给我子列表一二
Dialogue: 0,0:04:56.40,0:04:57.80,*Default,NTP,0000,0000,0000,,所以它所做的就是给我
Dialogue: 0,0:04:57.87,0:04:59.73,*Default,NTP,0000,0000,0000,,元素和索引零
Dialogue: 0,0:04:59.73,0:05:01.90,*Default,NTP,0000,0000,0000,,我正在迭代的列表的
Dialogue: 0,0:05:02.20,0:05:03.97,*Default,NTP,0000,0000,0000,,如果我再次要求下一次
Dialogue: 0,0:05:03.97,0:05:05.47,*Default,NTP,0000,0000,0000,,我会得到不同的值
Dialogue: 0,0:05:06.30,0:05:09.67,*Default,NTP,0000,0000,0000,,如果您想要迭代器中的所有值
Dialogue: 0,0:05:10.33,0:05:12.07,*Default,NTP,0000,0000,0000,,你可以把它们列出来
Dialogue: 0,0:05:12.93,0:05:14.13,*Default,NTP,0000,0000,0000,,现在你看到了
Dialogue: 0,0:05:14.13,0:05:16.57,*Default,NTP,0000,0000,0000,,我们只得到剩下的值
Dialogue: 0,0:05:16.57,0:05:20.90,*Default,NTP,0000,0000,0000,,我们已经用完了名单一二和三号
Dialogue: 0,0:05:21.13,0:05:22.37,*Default,NTP,0000,0000,0000,,所以当我建立一个列表时
Dialogue: 0,0:05:22.37,0:05:24.60,*Default,NTP,0000,0000,0000,,迭代器中剩余内容的
Dialogue: 0,0:05:24.60,0:05:26.70,*Default,NTP,0000,0000,0000,,我只得到数字四和五
Dialogue: 0,0:05:27.80,0:05:30.93,*Default,NTP,0000,0000,0000,,现在如果我此时请求 t 中的下一个元素
Dialogue: 0,0:05:30.93,0:05:32.00,*Default,NTP,0000,0000,0000,,我收到一个错误
Dialogue: 0,0:05:32.33,0:05:35.07,*Default,NTP,0000,0000,0000,,一种称为停止迭代的特殊错误
Dialogue: 0,0:05:35.37,0:05:37.13,*Default,NTP,0000,0000,0000,,这就是你最后告诉你的
Dialogue: 0,0:05:37.20,0:05:40.57,*Default,NTP,0000,0000,0000,,python 会引发停止迭代异常
Dialogue: 0,0:05:41.97,0:05:44.53,*Default,NTP,0000,0000,0000,,我们来谈谈字典迭代
Dialogue: 0,0:05:45.07,0:05:45.70,*Default,NTP,0000,0000,0000,,你可以得到
Dialogue: 0,0:05:45.70,0:05:48.93,*Default,NTP,0000,0000,0000,,字典内容的多种视图
Dialogue: 0,0:05:49.20,0:05:52.33,*Default,NTP,0000,0000,0000,,哪些是不同的对象，都是可迭代的
Dialogue: 0,0:05:53.30,0:05:56.27,*Default,NTP,0000,0000,0000,,可迭代值是任何可能的值
Dialogue: 0,0:05:56.27,0:05:57.37,*Default,NTP,0000,0000,0000,,传递给 itter
Dialogue: 0,0:05:57.57,0:06:00.73,*Default,NTP,0000,0000,0000,,用于生成迭代器的内置函数
Dialogue: 0,0:06:01.50,0:06:04.00,*Default,NTP,0000,0000,0000,,并且从 iter 返回一个迭代器
Dialogue: 0,0:06:04.10,0:06:07.33,*Default,NTP,0000,0000,0000,,并且可以传递给内置的下一个函数
Dialogue: 0,0:06:07.87,0:06:10.60,*Default,NTP,0000,0000,0000,,所有迭代器都是可变对象
Dialogue: 0,0:06:10.90,0:06:12.80,*Default,NTP,0000,0000,0000,,当你下次打电话给他们时
Dialogue: 0,0:06:12.90,0:06:15.67,*Default,NTP,0000,0000,0000,,它们变异为指向下一个元素
Dialogue: 0,0:06:16.87,0:06:21.57,*Default,NTP,0000,0000,0000,,字典及其键、值和项目
Dialogue: 0,0:06:21.57,0:06:23.70,*Default,NTP,0000,0000,0000,,都是可迭代的值
Dialogue: 0,0:06:23.73,0:06:25.40,*Default,NTP,0000,0000,0000,,全部都可以传入itter
Dialogue: 0,0:06:25.60,0:06:29.20,*Default,NTP,0000,0000,0000,,生成的迭代器可以传递到 next
Dialogue: 0,0:06:30.20,0:06:32.93,*Default,NTP,0000,0000,0000,,字典中项目的顺序是 order
Dialogue: 0,0:06:32.93,0:06:34.33,*Default,NTP,0000,0000,0000,,其中添加了它们
Dialogue: 0,0:06:34.87,0:06:37.97,*Default,NTP,0000,0000,0000,,最新版本的 python 也是如此
Dialogue: 0,0:06:38.10,0:06:40.27,*Default,NTP,0000,0000,0000,,从 python 3.6 开始
Dialogue: 0,0:06:40.87,0:06:44.07,*Default,NTP,0000,0000,0000,,但是旧版本的 python
Dialogue: 0,0:06:44.33,0:06:47.90,*Default,NTP,0000,0000,0000,,字典中的项目以任意顺序出现
Dialogue: 0,0:06:47.97,0:06:49.33,*Default,NTP,0000,0000,0000,,字典被称为
Dialogue: 0,0:06:49.33,0:06:51.47,*Default,NTP,0000,0000,0000,,键值的无序集合
Dialogue: 0,0:06:51.47,0:06:52.80,*Default,NTP,0000,0000,0000,,结果成对
Dialogue: 0,0:06:53.40,0:06:54.80,*Default,NTP,0000,0000,0000,,但现在他们被订购了
Dialogue: 0,0:06:55.10,0:06:56.80,*Default,NTP,0000,0000,0000,,虽然当你编写Python代码时
Dialogue: 0,0:06:56.80,0:06:58.70,*Default,NTP,0000,0000,0000,,是一个值得记住的好主意
Dialogue: 0,0:06:58.80,0:06:59.77,*Default,NTP,0000,0000,0000,,这取决于
Dialogue: 0,0:06:59.77,0:07:03.10,*Default,NTP,0000,0000,0000,,人们用来运行你的程序的 python 版本
Dialogue: 0,0:07:03.27,0:07:06.20,*Default,NTP,0000,0000,0000,,字典的排序可能不可靠
Dialogue: 0,0:07:06.87,0:07:08.93,*Default,NTP,0000,0000,0000,,但我会在我的例子中假设
Dialogue: 0,0:07:08.93,0:07:11.40,*Default,NTP,0000,0000,0000,,我们正在使用最新版本的 python
Dialogue: 0,0:07:11.53,0:07:12.40,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:07:12.57,0:07:14.47,*Default,NTP,0000,0000,0000,,字典最终将被排序
Dialogue: 0,0:07:14.60,0:07:16.70,*Default,NTP,0000,0000,0000,,根据它们的构造方式
Dialogue: 0,0:07:17.80,0:07:20.37,*Default,NTP,0000,0000,0000,,所以如果我有一本带有三个键和三个键的字典
Dialogue: 0,0:07:20.37,0:07:23.80,*Default,NTP,0000,0000,0000,,值一绑定到一二到二三到三
Dialogue: 0,0:07:24.13,0:07:28.00,*Default,NTP,0000,0000,0000,,然后我添加第四个值零必然为零
Dialogue: 0,0:07:28.93,0:07:30.40,*Default,NTP,0000,0000,0000,,那么我会期望
Dialogue: 0,0:07:30.40,0:07:32.33,*Default,NTP,0000,0000,0000,,迭代键会给我
Dialogue: 0,0:07:32.33,0:07:34.07,*Default,NTP,0000,0000,0000,,1 2 3 然后为零
Dialogue: 0,0:07:34.07,0:07:36.13,*Default,NTP,0000,0000,0000,,因为最后添加了零
Dialogue: 0,0:07:37.30,0:07:40.20,*Default,NTP,0000,0000,0000,,这是我迭代键的方法
Dialogue: 0,0:07:40.60,0:07:44.60,*Default,NTP,0000,0000,0000,,我说我想要一个迭代器，通过调用 iter 函数
Dialogue: 0,0:07:45.33,0:07:46.73,*Default,NTP,0000,0000,0000,,在按键上
Dialogue: 0,0:07:47.13,0:07:49.93,*Default,NTP,0000,0000,0000,,如果你不说 d 点键而只说 d
Dialogue: 0,0:07:49.93,0:07:51.20,*Default,NTP,0000,0000,0000,,你会得到同样的效果
Dialogue: 0,0:07:51.20,0:07:52.87,*Default,NTP,0000,0000,0000,,你迭代键
Dialogue: 0,0:07:53.80,0:07:56.20,*Default,NTP,0000,0000,0000,,这个 k 是键的迭代器
Dialogue: 0,0:07:56.20,0:07:58.67,*Default,NTP,0000,0000,0000,,这意味着如果我要下一份，我会得到一份
Dialogue: 0,0:07:58.67,0:08:00.07,*Default,NTP,0000,0000,0000,,然后两个然后三个
Dialogue: 0,0:08:00.30,0:08:03.97,*Default,NTP,0000,0000,0000,,如果我想迭代则为零
Dialogue: 0,0:08:03.97,0:08:06.00,*Default,NTP,0000,0000,0000,,字典中的值
Dialogue: 0,0:08:06.30,0:08:08.30,*Default,NTP,0000,0000,0000,,我会询问价值观
Dialogue: 0,0:08:08.97,0:08:11.47,*Default,NTP,0000,0000,0000,,该对象是一个可迭代对象
Dialogue: 0,0:08:11.67,0:08:15.17,*Default,NTP,0000,0000,0000,,提供对订单中所有值的访问
Dialogue: 0,0:08:15.33,0:08:17.37,*Default,NTP,0000,0000,0000,,词典的构建
Dialogue: 0,0:08:17.67,0:08:20.93,*Default,NTP,0000,0000,0000,,所以下一个值是一然后二然后三然后零
Dialogue: 0,0:08:21.60,0:08:24.87,*Default,NTP,0000,0000,0000,,最后我可以查询字典中的项目
Dialogue: 0,0:08:25.07,0:08:28.47,*Default,NTP,0000,0000,0000,,这些是表示为元组的键值对
Dialogue: 0,0:08:28.93,0:08:30.57,*Default,NTP,0000,0000,0000,,所以第一个是一个
Dialogue: 0,0:08:30.67,0:08:32.93,*Default,NTP,0000,0000,0000,,我们同时获得键和值
Dialogue: 0,0:08:32.93,0:08:34.47,*Default,NTP,0000,0000,0000,,在二元素元组中
Dialogue: 0,0:08:34.67,0:08:36.50,*Default,NTP,0000,0000,0000,,然后二然后三然后零
Dialogue: 0,0:08:37.33,0:08:38.10,*Default,NTP,0000,0000,0000,,所以有很多
Dialogue: 0,0:08:38.10,0:08:40.80,*Default,NTP,0000,0000,0000,,迭代字典内容的方法
Dialogue: 0,0:08:40.80,0:08:42.80,*Default,NTP,0000,0000,0000,,以及 python 的设计方式
Dialogue: 0,0:08:42.90,0:08:44.73,*Default,NTP,0000,0000,0000,,只有一本字典 d
Dialogue: 0,0:08:45.13,0:08:47.53,*Default,NTP,0000,0000,0000,,我可以访问它的不同视图
Dialogue: 0,0:08:47.53,0:08:48.67,*Default,NTP,0000,0000,0000,,索要钥匙
Dialogue: 0,0:08:48.67,0:08:50.07,*Default,NTP,0000,0000,0000,,值或项目
Dialogue: 0,0:08:50.20,0:08:53.10,*Default,NTP,0000,0000,0000,,我可以获得其中任何一个的迭代器
Dialogue: 0,0:08:54.10,0:08:56.50,*Default,NTP,0000,0000,0000,,现在需要注意的一件有趣的事情是，如果我
Dialogue: 0,0:08:56.50,0:08:57.80,*Default,NTP,0000,0000,0000,,有一本字典
Dialogue: 0,0:08:58.67,0:09:02.70,*Default,NTP,0000,0000,0000,,我已经在键上构建了一个迭代器
Dialogue: 0,0:09:03.10,0:09:06.33,*Default,NTP,0000,0000,0000,,我正在迭代这些键
Dialogue: 0,0:09:06.50,0:09:09.90,*Default,NTP,0000,0000,0000,,我改变了字典
Dialogue: 0,0:09:10.53,0:09:14.33,*Default,NTP,0000,0000,0000,,现在的情况是迭代器无效
Dialogue: 0,0:09:14.67,0:09:16.20,*Default,NTP,0000,0000,0000,,所以我看到这个错误
Dialogue: 0,0:09:16.47,0:09:19.80,*Default,NTP,0000,0000,0000,,字典在迭代期间改变了大小
Dialogue: 0,0:09:20.27,0:09:23.57,*Default,NTP,0000,0000,0000,,这说明我不能再使用 k
Dialogue: 0,0:09:23.73,0:09:26.20,*Default,NTP,0000,0000,0000,,因为字典已经被修改了
Dialogue: 0,0:09:26.40,0:09:28.20,*Default,NTP,0000,0000,0000,,当我使用 k 时
Dialogue: 0,0:09:28.73,0:09:31.33,*Default,NTP,0000,0000,0000,,所以我们的字典现在看起来像这样
Dialogue: 0,0:09:32.27,0:09:35.87,*Default,NTP,0000,0000,0000,,如果我只是更改其中一个键的值
Dialogue: 0,0:09:35.90,0:09:38.67,*Default,NTP,0000,0000,0000,,当我遍历键时
Dialogue: 0,0:09:38.67,0:09:44.57,*Default,NTP,0000,0000,0000,,所以这是一二然后我改变 0 2 5
Dialogue: 0,0:09:45.13,0:09:46.93,*Default,NTP,0000,0000,0000,,我可以继续迭代
Dialogue: 0,0:09:47.10,0:09:48.67,*Default,NTP,0000,0000,0000,,因为我没有改变
Dialogue: 0,0:09:48.67,0:09:50.93,*Default,NTP,0000,0000,0000,,字典的形状或结构
Dialogue: 0,0:09:50.93,0:09:53.40,*Default,NTP,0000,0000,0000,,我刚刚更改了键的值之一
Dialogue: 0,0:09:53.60,0:09:55.67,*Default,NTP,0000,0000,0000,,但如果字典改变大小
Dialogue: 0,0:09:55.70,0:09:58.47,*Default,NTP,0000,0000,0000,,那么我无法使用我构建的任何迭代器
Dialogue: 0,0:09:58.50,0:10:00.57,*Default,NTP,0000,0000,0000,,相反，我需要制作新的
Dialogue: 0,0:10:00.57,0:10:03.53,*Default,NTP,0000,0000,0000,,对于键值或项目也是如此
Dialogue: 0,0:10:06.20,0:10:09.50,*Default,NTP,0000,0000,0000,,四个语句迭代可迭代值
Dialogue: 0,0:10:09.73,0:10:14.17,*Default,NTP,0000,0000,0000,,也可以迭代迭代器本身
Dialogue: 0,0:10:15.27,0:10:18.57,*Default,NTP,0000,0000,0000,,假设我的范围是三到六
Dialogue: 0,0:10:18.90,0:10:21.30,*Default,NTP,0000,0000,0000,,该范围的内容是数字三
Dialogue: 0,0:10:21.30,0:10:22.57,*Default,NTP,0000,0000,0000,,四和五
Dialogue: 0,0:10:23.40,0:10:26.10,*Default,NTP,0000,0000,0000,,如果我迭代该范围
Dialogue: 0,0:10:26.40,0:10:28.20,*Default,NTP,0000,0000,0000,,我看到了所有的元素
Dialogue: 0,0:10:28.27,0:10:29.57,*Default,NTP,0000,0000,0000,,如果我再做一次
Dialogue: 0,0:10:29.57,0:10:31.20,*Default,NTP,0000,0000,0000,,我再次看到了所有的元素
Dialogue: 0,0:10:31.20,0:10:33.60,*Default,NTP,0000,0000,0000,,因为我没有改变范围
Dialogue: 0,0:10:34.60,0:10:36.80,*Default,NTP,0000,0000,0000,,迭代器有点不同
Dialogue: 0,0:10:36.93,0:10:40.87,*Default,NTP,0000,0000,0000,,所以如果我从我的范围中得到一个范围迭代器
Dialogue: 0,0:10:41.90,0:10:44.10,*Default,NTP,0000,0000,0000,,这在
Dialogue: 0,0:10:44.10,0:10:45.80,*Default,NTP,0000,0000,0000,,与其相关的范围
Dialogue: 0,0:10:45.90,0:10:49.37,*Default,NTP,0000,0000,0000,,每次我下次打电话都会改变
Dialogue: 0,0:10:50.47,0:10:51.67,*Default,NTP,0000,0000,0000,,所以我可以问
Dialogue: 0,0:10:51.67,0:10:54.80,*Default,NTP,0000,0000,0000,,对于迭代器其余部分中的每个元素
Dialogue: 0,0:10:56.37,0:10:59.77,*Default,NTP,0000,0000,0000,,但它不会打印出三，因为三已经过去了
Dialogue: 0,0:11:00.00,0:11:02.70,*Default,NTP,0000,0000,0000,,相反，它只会打印出四和五
Dialogue: 0,0:11:05.07,0:11:06.57,*Default,NTP,0000,0000,0000,,现在还有四个声明
Dialogue: 0,0:11:06.57,0:11:09.07,*Default,NTP,0000,0000,0000,,在迭代器内移动标记
Dialogue: 0,0:11:09.27,0:11:13.30,*Default,NTP,0000,0000,0000,,将其一直推进到序列的末尾
Dialogue: 0,0:11:14.00,0:11:15.77,*Default,NTP,0000,0000,0000,,所以我还有我的范围
Dialogue: 0,0:11:15.87,0:11:18.33,*Default,NTP,0000,0000,0000,,我将构建一个新的范围迭代器
Dialogue: 0,0:11:18.67,0:11:20.67,*Default,NTP,0000,0000,0000,,从头开始
Dialogue: 0,0:11:20.90,0:11:23.77,*Default,NTP,0000,0000,0000,,对于我们眼中的每一个元素
Dialogue: 0,0:11:23.77,0:11:25.50,*Default,NTP,0000,0000,0000,,我要打印出眼睛
Dialogue: 0,0:11:25.93,0:11:28.00,*Default,NTP,0000,0000,0000,,所以我传递了一个范围迭代器
Dialogue: 0,0:11:28.17,0:11:30.87,*Default,NTP,0000,0000,0000,,到要处理的四个语句
Dialogue: 0,0:11:31.33,0:11:34.37,*Default,NTP,0000,0000,0000,,现在范围迭代器中已经没有任何内容了
Dialogue: 0,0:11:34.67,0:11:36.67,*Default,NTP,0000,0000,0000,,如果我再次迭代它
Dialogue: 0,0:11:36.70,0:11:41.30,*Default,NTP,0000,0000,0000,,我什么也没看到，因为我已经到了 roi 的尽头
Dialogue: 0,0:11:41.53,0:11:44.17,*Default,NTP,0000,0000,0000,,这是使用迭代器的另一个结果
Dialogue: 0,0:11:44.30,0:11:45.67,*Default,NTP,0000,0000,0000,,在四个声明中
Dialogue: 0,0:11:46.57,0:11:47.90,*Default,NTP,0000,0000,0000,,所以总结一下
Dialogue: 0,0:11:48.17,0:11:51.10,*Default,NTP,0000,0000,0000,,如果我在四个语句中使用迭代器
Dialogue: 0,0:11:51.20,0:11:51.93,*Default,NTP,0000,0000,0000,,我还可以
Dialogue: 0,0:11:51.93,0:11:54.80,*Default,NTP,0000,0000,0000,,遍历所有元素直到到达终点
Dialogue: 0,0:11:55.33,0:11:57.67,*Default,NTP,0000,0000,0000,,但这将使迭代器前进
Dialogue: 0,0:11:57.67,0:11:59.53,*Default,NTP,0000,0000,0000,,这样我就不能再使用它了
Dialogue: 0,0:12:00.13,0:12:01.33,*Default,NTP,0000,0000,0000,,另一方面
Dialogue: 0,0:12:01.50,0:12:04.17,*Default,NTP,0000,0000,0000,,如果我正在使用可迭代对象
Dialogue: 0,0:12:04.17,0:12:06.10,*Default,NTP,0000,0000,0000,,就像范围本身一样
Dialogue: 0,0:12:07.00,0:12:09.93,*Default,NTP,0000,0000,0000,,每次我在森林声明中使用它时
Dialogue: 0,0:12:10.00,0:12:12.70,*Default,NTP,0000,0000,0000,,我能够浏览全部内容
Dialogue: 0,0:12:12.70,0:12:14.37,*Default,NTP,0000,0000,0000,,从开始到结束
Dialogue: 0,0:12:14.50,0:12:18.10,*Default,NTP,0000,0000,0000,,不用担心任何改变
Dialogue: 0,0:12:21.40,0:12:22.50,*Default,NTP,0000,0000,0000,,大量的
Dialogue: 0,0:12:22.50,0:12:25.97,*Default,NTP,0000,0000,0000,,序列和其他可迭代值的处理
Dialogue: 0,0:12:26.27,0:12:28.47,*Default,NTP,0000,0000,0000,,使用内置函数
Dialogue: 0,0:12:28.87,0:12:30.90,*Default,NTP,0000,0000,0000,,但接受一个可迭代的值
Dialogue: 0,0:12:30.97,0:12:32.67,*Default,NTP,0000,0000,0000,,并返回一个迭代器
Dialogue: 0,0:12:33.77,0:12:36.37,*Default,NTP,0000,0000,0000,,这么多内置的Python序列操作返回
Dialogue: 0,0:12:36.37,0:12:40.00,*Default,NTP,0000,0000,0000,,延迟计算结果的迭代器
Dialogue: 0,0:12:40.70,0:12:43.07,*Default,NTP,0000,0000,0000,,惰性计算是什么意思
Dialogue: 0,0:12:43.07,0:12:45.53,*Default,NTP,0000,0000,0000,,是只计算结果
Dialogue: 0,0:12:45.67,0:12:47.70,*Default,NTP,0000,0000,0000,,当被要求时
Dialogue: 0,0:12:48.37,0:12:49.40,*Default,NTP,0000,0000,0000,,所以翻译员
Dialogue: 0,0:12:49.40,0:12:52.50,*Default,NTP,0000,0000,0000,,准备好计算所需的任何内容
Dialogue: 0,0:12:52.77,0:12:54.53,*Default,NTP,0000,0000,0000,,但实际上并没有计算它
Dialogue: 0,0:12:54.53,0:12:57.17,*Default,NTP,0000,0000,0000,,除非要使用该值
Dialogue: 0,0:12:58.13,0:12:59.97,*Default,NTP,0000,0000,0000,,让我给你看一些例子
Dialogue: 0,0:13:00.53,0:13:02.17,*Default,NTP,0000,0000,0000,,有一个函数叫做map
Dialogue: 0,0:13:02.50,0:13:05.40,*Default,NTP,0000,0000,0000,,接受另一个函数和可迭代的
Dialogue: 0,0:13:05.57,0:13:06.53,*Default,NTP,0000,0000,0000,,它适用
Dialogue: 0,0:13:06.53,0:13:09.00,*Default,NTP,0000,0000,0000,,该函数作用于可迭代中的每个元素
Dialogue: 0,0:13:09.57,0:13:11.73,*Default,NTP,0000,0000,0000,,但不是立即应用
Dialogue: 0,0:13:11.73,0:13:13.47,*Default,NTP,0000,0000,0000,,它在迭代器中返回
Dialogue: 0,0:13:13.77,0:13:17.53,*Default,NTP,0000,0000,0000,,在迭代器中迭代值 funk x
Dialogue: 0,0:13:17.73,0:13:19.93,*Default,NTP,0000,0000,0000,,对于可迭代中的每个 x
Dialogue: 0,0:13:20.80,0:13:22.67,*Default,NTP,0000,0000,0000,,还有另一个内置函数过滤器
Dialogue: 0,0:13:22.67,0:13:25.00,*Default,NTP,0000,0000,0000,,它在可迭代中接受谓词函数
Dialogue: 0,0:13:25.00,0:13:27.07,*Default,NTP,0000,0000,0000,,它迭代 x 和 iterable
Dialogue: 0,0:13:27.07,0:13:30.47,*Default,NTP,0000,0000,0000,,如果 funk x 返回真值
Dialogue: 0,0:13:31.50,0:13:33.37,*Default,NTP,0000,0000,0000,,zip 需要两个可迭代对象
Dialogue: 0,0:13:33.37,0:13:36.80,*Default,NTP,0000,0000,0000,,它迭代共同索引的 xy 对
Dialogue: 0,0:13:38.07,0:13:42.17,*Default,NTP,0000,0000,0000,,reversed 以相反的顺序迭代序列中的 x
Dialogue: 0,0:13:42.97,0:13:45.13,*Default,NTP,0000,0000,0000,,所有这些返回迭代器
Dialogue: 0,0:13:45.57,0:13:48.27,*Default,NTP,0000,0000,0000,,这些迭代器产生这些值
Dialogue: 0,0:13:48.37,0:13:50.40,*Default,NTP,0000,0000,0000,,每次你打电话给他们
Dialogue: 0,0:13:52.00,0:13:52.77,*Default,NTP,0000,0000,0000,,如果你想
Dialogue: 0,0:13:52.77,0:13:55.67,*Default,NTP,0000,0000,0000,,查看迭代器的完整内容
Dialogue: 0,0:13:55.70,0:13:57.53,*Default,NTP,0000,0000,0000,,您可以放置​​结果元素
Dialogue: 0,0:13:57.53,0:13:58.70,*Default,NTP,0000,0000,0000,,放入一个新容器中
Dialogue: 0,0:13:58.93,0:14:01.10,*Default,NTP,0000,0000,0000,,通过调用列表或元组
Dialogue: 0,0:14:01.53,0:14:03.20,*Default,NTP,0000,0000,0000,,或排序排序
Dialogue: 0,0:14:03.20,0:14:04.80,*Default,NTP,0000,0000,0000,,创建一个排序列表，其中包含
Dialogue: 0,0:14:04.80,0:14:06.70,*Default,NTP,0000,0000,0000,,可迭代中的所有元素
Dialogue: 0,0:14:07.77,0:14:09.20,*Default,NTP,0000,0000,0000,,让我们做一些演示
Dialogue: 0,0:14:10.47,0:14:13.47,*Default,NTP,0000,0000,0000,,所以如果我创建一个列表 bcd
Dialogue: 0,0:14:14.93,0:14:17.80,*Default,NTP,0000,0000,0000,,我可以将所有这些元素大写
Dialogue: 0,0:14:17.93,0:14:21.70,*Default,NTP,0000,0000,0000,,通过对 bcd 中的 x 调用上面的方法
Dialogue: 0,0:14:23.33,0:14:26.50,*Default,NTP,0000,0000,0000,,我可以通过调用地图获得类似的效果
Dialogue: 0,0:14:26.70,0:14:28.20,*Default,NTP,0000,0000,0000,,在 lambda 函数上
Dialogue: 0,0:14:28.47,0:14:31.53,*Default,NTP,0000,0000,0000,,计算大写版本
Dialogue: 0,0:14:31.67,0:14:33.80,*Default,NTP,0000,0000,0000,,bcd 中的每个元素
Dialogue: 0,0:14:34.77,0:14:37.20,*Default,NTP,0000,0000,0000,,但我得到的不是列表
Dialogue: 0,0:14:37.37,0:14:39.67,*Default,NTP,0000,0000,0000,,大写b 大写c 大写d
Dialogue: 0,0:14:39.87,0:14:43.33,*Default,NTP,0000,0000,0000,,而是一个作为迭代器的地图对象
Dialogue: 0,0:14:43.90,0:14:45.87,*Default,NTP,0000,0000,0000,,所以如果我给它起个名字 m
Dialogue: 0,0:14:46.37,0:14:49.07,*Default,NTP,0000,0000,0000,,然后我可以要求下一个大写字母
Dialogue: 0,0:14:49.07,0:14:50.73,*Default,NTP,0000,0000,0000,,这是 b 然后是 c
Dialogue: 0,0:14:50.73,0:14:52.67,*Default,NTP,0000,0000,0000,,然后 d 然后我们就完成了
Dialogue: 0,0:14:53.73,0:14:56.73,*Default,NTP,0000,0000,0000,,现在这些结果的计算方式非常有趣
Dialogue: 0,0:14:57.40,0:14:59.17,*Default,NTP,0000,0000,0000,,less 找到一个函数 double
Dialogue: 0,0:14:59.37,0:15:01.67,*Default,NTP,0000,0000,0000,,它接受一个 x 并打印出来
Dialogue: 0,0:15:01.77,0:15:04.07,*Default,NTP,0000,0000,0000,,恰好当 x 加倍时
Dialogue: 0,0:15:04.70,0:15:08.30,*Default,NTP,0000,0000,0000,,x 被加倍为
Dialogue: 0,0:15:09.17,0:15:10.70,*Default,NTP,0000,0000,0000,,两次x
Dialogue: 0,0:15:11.47,0:15:13.60,*Default,NTP,0000,0000,0000,,现在两次 x
Dialogue: 0,0:15:15.33,0:15:20.60,*Default,NTP,0000,0000,0000,,如果我在列表 3 5 7 上映射两次
Dialogue: 0,0:15:21.73,0:15:25.17,*Default,NTP,0000,0000,0000,,我得到一个地图对象，但你注意到没有打印任何内容
Dialogue: 0,0:15:26.37,0:15:28.20,*Default,NTP,0000,0000,0000,,所以我给这个东西起个名字 m
Dialogue: 0,0:15:28.20,0:15:30.73,*Default,NTP,0000,0000,0000,,然后我会询问 m 中的下一个元素
Dialogue: 0,0:15:30.97,0:15:33.73,*Default,NTP,0000,0000,0000,,就在那一刻，它翻了三倍
Dialogue: 0,0:15:33.77,0:15:35.17,*Default,NTP,0000,0000,0000,,获得第6名
Dialogue: 0,0:15:35.50,0:15:38.07,*Default,NTP,0000,0000,0000,,直到我要求下一个元素它才会加倍
Dialogue: 0,0:15:38.07,0:15:39.50,*Default,NTP,0000,0000,0000,,五人获得第10名
Dialogue: 0,0:15:39.60,0:15:40.50,*Default,NTP,0000,0000,0000,,然后最后
Dialogue: 0,0:15:40.50,0:15:42.60,*Default,NTP,0000,0000,0000,,如果我要求之后的下一个元素
Dialogue: 0,0:15:42.60,0:15:44.50,*Default,NTP,0000,0000,0000,,它计算 14 号
Dialogue: 0,0:15:46.13,0:15:47.40,*Default,NTP,0000,0000,0000,,所以重点在这里
Dialogue: 0,0:15:47.53,0:15:50.07,*Default,NTP,0000,0000,0000,,是 double 不应用于三然后
Dialogue: 0,0:15:50.07,0:15:51.77,*Default,NTP,0000,0000,0000,,立即五个然后七个
Dialogue: 0,0:15:51.87,0:15:53.90,*Default,NTP,0000,0000,0000,,而是悠闲地运用
Dialogue: 0,0:15:54.17,0:15:56.80,*Default,NTP,0000,0000,0000,,仅当我们请求下一个元素时
Dialogue: 0,0:15:56.80,0:15:59.53,*Default,NTP,0000,0000,0000,,是应用的函数和计算的结果
Dialogue: 0,0:16:00.50,0:16:03.07,*Default,NTP,0000,0000,0000,,当我调用map时返回的map对象
Dialogue: 0,0:16:03.07,0:16:04.70,*Default,NTP,0000,0000,0000,,可以传递到另一个
Dialogue: 0,0:16:04.70,0:16:06.53,*Default,NTP,0000,0000,0000,,序列处理功能
Dialogue: 0,0:16:07.87,0:16:08.90,*Default,NTP,0000,0000,0000,,例如
Dialogue: 0,0:16:08.90,0:16:11.87,*Default,NTP,0000,0000,0000,,假设我的范围是三到七
Dialogue: 0,0:16:12.57,0:16:14.87,*Default,NTP,0000,0000,0000,,我在该范围内绘制了两倍
Dialogue: 0,0:16:15.17,0:16:16.57,*Default,NTP,0000,0000,0000,,我称之为 m
Dialogue: 0,0:16:17.60,0:16:19.50,*Default,NTP,0000,0000,0000,,然后我创建一个过滤函数
Dialogue: 0,0:16:19.93,0:16:21.50,*Default,NTP,0000,0000,0000,,接受值 y
Dialogue: 0,0:16:21.93,0:16:23.93,*Default,NTP,0000,0000,0000,,只要 y 就返回 true
Dialogue: 0,0:16:24.07,0:16:25.93,*Default,NTP,0000,0000,0000,,大于或等于锡
Dialogue: 0,0:16:27.00,0:16:28.17,*Default,NTP,0000,0000,0000,,我可以过滤
Dialogue: 0,0:16:28.70,0:16:31.40,*Default,NTP,0000,0000,0000,,使用 f 地图对象
Dialogue: 0,0:16:32.17,0:16:35.13,*Default,NTP,0000,0000,0000,,并根据结果构建一个新的迭代器
Dialogue: 0,0:16:35.90,0:16:38.57,*Default,NTP,0000,0000,0000,,请注意，我仍然没有将任何东西加倍
Dialogue: 0,0:16:40.13,0:16:42.67,*Default,NTP,0000,0000,0000,,如果我问下一个翻倍是多少
Dialogue: 0,0:16:42.67,0:16:45.10,*Default,NTP,0000,0000,0000,,元素范围为三到七
Dialogue: 0,0:16:45.10,0:16:46.53,*Default,NTP,0000,0000,0000,,至少有 10 个
Dialogue: 0,0:16:47.07,0:16:49.47,*Default,NTP,0000,0000,0000,,然后将三倍加倍，发现结果是
Dialogue: 0,0:16:49.47,0:16:52.80,*Default,NTP,0000,0000,0000,,根据我们的过滤函数，六个是错误的
Dialogue: 0,0:16:52.97,0:16:56.20,*Default,NTP,0000,0000,0000,,所以将四加倍得到八，这也是错误的
Dialogue: 0,0:16:56.27,0:16:58.33,*Default,NTP,0000,0000,0000,,然后将五加倍得到十
Dialogue: 0,0:16:58.33,0:17:00.50,*Default,NTP,0000,0000,0000,,十大于等于 10
Dialogue: 0,0:17:00.50,0:17:01.90,*Default,NTP,0000,0000,0000,,这样就可以得到返回
Dialogue: 0,0:17:02.47,0:17:04.90,*Default,NTP,0000,0000,0000,,所以你可以看到它做了同样多的工作
Dialogue: 0,0:17:04.90,0:17:05.90,*Default,NTP,0000,0000,0000,,因为它需要做
Dialogue: 0,0:17:05.90,0:17:07.87,*Default,NTP,0000,0000,0000,,为了返回下一个元素
Dialogue: 0,0:17:08.00,0:17:09.27,*Default,NTP,0000,0000,0000,,序列的
Dialogue: 0,0:17:09.33,0:17:10.57,*Default,NTP,0000,0000,0000,,价值加倍
Dialogue: 0,0:17:10.57,0:17:12.37,*Default,NTP,0000,0000,0000,,大于等于 10
Dialogue: 0,0:17:12.60,0:17:14.80,*Default,NTP,0000,0000,0000,,但它没有做更多的工作
Dialogue: 0,0:17:15.00,0:17:16.67,*Default,NTP,0000,0000,0000,,如果我要求下一个元素
Dialogue: 0,0:17:16.67,0:17:18.30,*Default,NTP,0000,0000,0000,,那么它只会将其中一个加倍
Dialogue: 0,0:17:18.33,0:17:21.13,*Default,NTP,0000,0000,0000,,找出大于等于10并返回
Dialogue: 0,0:17:22.20,0:17:24.13,*Default,NTP,0000,0000,0000,,如果我列出茶的内容
Dialogue: 0,0:17:24.20,0:17:25.93,*Default,NTP,0000,0000,0000,,当它发现什么都没有剩下的时候
Dialogue: 0,0:17:25.93,0:17:28.37,*Default,NTP,0000,0000,0000,,因为这个范围只有 3 4 5 6 6
Dialogue: 0,0:17:28.37,0:17:29.20,*Default,NTP,0000,0000,0000,,翻倍为 12
Dialogue: 0,0:17:29.20,0:17:30.10,*Default,NTP,0000,0000,0000,,然后我们就完成了
Dialogue: 0,0:17:30.90,0:17:32.30,*Default,NTP,0000,0000,0000,,所以从头开始
Dialogue: 0,0:17:32.30,0:17:33.70,*Default,NTP,0000,0000,0000,,如果我想过滤
Dialogue: 0,0:17:33.80,0:17:36.37,*Default,NTP,0000,0000,0000,,结果的所有元素
Dialogue: 0,0:17:36.37,0:17:39.57,*Default,NTP,0000,0000,0000,,在三到七的范围内映射双倍
Dialogue: 0,0:17:40.60,0:17:43.73,*Default,NTP,0000,0000,0000,,我将获得值 10 和 12 的迭代器
Dialogue: 0,0:17:44.30,0:17:46.70,*Default,NTP,0000,0000,0000,,我可以将其放入列表中
Dialogue: 0,0:17:47.00,0:17:49.70,*Default,NTP,0000,0000,0000,,将它们放在列表中意味着它将运行
Dialogue: 0,0:17:49.70,0:17:52.27,*Default,NTP,0000,0000,0000,,这个过程到精疲力竭
Dialogue: 0,0:17:52.27,0:17:54.50,*Default,NTP,0000,0000,0000,,直到最后到达一个空迭代器
Dialogue: 0,0:17:54.77,0:17:56.67,*Default,NTP,0000,0000,0000,,返回值 10 和 12
Dialogue: 0,0:17:57.00,0:17:59.40,*Default,NTP,0000,0000,0000,,它必须完成所有工作才能到达那里
Dialogue: 0,0:17:59.40,0:18:01.80,*Default,NTP,0000,0000,0000,,它必须将每个数字加倍 3456
Dialogue: 0,0:18:03.10,0:18:04.07,*Default,NTP,0000,0000,0000,,所以这是可能的
Dialogue: 0,0:18:04.07,0:18:06.93,*Default,NTP,0000,0000,0000,,使用这些迭代器来计算答案的穷举
Dialogue: 0,0:18:07.17,0:18:09.80,*Default,NTP,0000,0000,0000,,但如果你不要求提供值列表
Dialogue: 0,0:18:10.00,0:18:12.67,*Default,NTP,0000,0000,0000,,并且你一次只会请求一个元素
Dialogue: 0,0:18:12.67,0:18:14.73,*Default,NTP,0000,0000,0000,,那么它们将被合法地计算
Dialogue: 0,0:18:16.07,0:18:18.77,*Default,NTP,0000,0000,0000,,惰性计算最方便
Dialogue: 0,0:18:18.97,0:18:20.00,*Default,NTP,0000,0000,0000,,因为
Dialogue: 0,0:18:20.17,0:18:24.37,*Default,NTP,0000,0000,0000,,它允许您指定如何计算大量值
Dialogue: 0,0:18:24.37,0:18:26.20,*Default,NTP,0000,0000,0000,,但如果你实际上并不需要所有这些值
Dialogue: 0,0:18:26.20,0:18:27.80,*Default,NTP,0000,0000,0000,,那么你就不用费心去计算它们
Dialogue: 0,0:18:28.40,0:18:31.17,*Default,NTP,0000,0000,0000,,但有一些事情需要注意
Dialogue: 0,0:18:32.27,0:18:32.97,*Default,NTP,0000,0000,0000,,例如
Dialogue: 0,0:18:32.97,0:18:36.47,*Default,NTP,0000,0000,0000,,如果我创建一个向前或向后相同的列表
Dialogue: 0,0:18:37.13,0:18:41.00,*Default,NTP,0000,0000,0000,,我问该列表的反转版本是什么
Dialogue: 0,0:18:41.90,0:18:45.53,*Default,NTP,0000,0000,0000,,我得到的是一个欲望反转的迭代器对象
Dialogue: 0,0:18:46.07,0:18:49.10,*Default,NTP,0000,0000,0000,,所以只是说 t 的逆等于 t
Dialogue: 0,0:18:49.13,0:18:51.33,*Default,NTP,0000,0000,0000,,会给我结果 false
Dialogue: 0,0:18:51.87,0:18:53.53,*Default,NTP,0000,0000,0000,,现在如果我列出来
Dialogue: 0,0:18:53.73,0:18:57.17,*Default,NTP,0000,0000,0000,,反向迭代器的所有内容
Dialogue: 0,0:18:57.33,0:18:58.70,*Default,NTP,0000,0000,0000,,这等于 t
Dialogue: 0,0:18:59.70,0:19:02.53,*Default,NTP,0000,0000,0000,,但你想避免应用平等
Dialogue: 0,0:19:02.90,0:19:06.47,*Default,NTP,0000,0000,0000,,到一个列表和一个迭代器，因为你会得到 false
Dialogue: 0,0:19:07.07,0:19:09.70,*Default,NTP,0000,0000,0000,,你必须比较一个列表和一个列表
Dialogue: 0,0:19:11.17,0:19:12.53,*Default,NTP,0000,0000,0000,,这是最后一个演示
Dialogue: 0,0:19:12.70,0:19:14.33,*Default,NTP,0000,0000,0000,,如果我有一本字典
Dialogue: 0,0:19:15.10,0:19:16.67,*Default,NTP,0000,0000,0000,,元素以任意顺序出现
Dialogue: 0,0:19:16.67,0:19:18.07,*Default,NTP,0000,0000,0000,,但是当我迭代它们时
Dialogue: 0,0:19:18.07,0:19:20.40,*Default,NTP,0000,0000,0000,,我每次都得到一致的订单
Dialogue: 0,0:19:21.30,0:19:23.70,*Default,NTP,0000,0000,0000,,迭代项目的一种方法
Dialogue: 0,0:19:24.40,0:19:26.10,*Default,NTP,0000,0000,0000,,就是得到一个迭代器
Dialogue: 0,0:19:26.97,0:19:28.57,*Default,NTP,0000,0000,0000,,超过 dw 项目
Dialogue: 0,0:19:30.13,0:19:32.60,*Default,NTP,0000,0000,0000,,然后我会得到 b 2 ，然后是 1
Dialogue: 0,0:19:33.50,0:19:35.70,*Default,NTP,0000,0000,0000,,但另一种方法可以得到相同的结果
Dialogue: 0,0:19:36.50,0:19:40.33,*Default,NTP,0000,0000,0000,,是将键和值压缩在一起
Dialogue: 0,0:19:41.30,0:19:43.07,*Default,NTP,0000,0000,0000,,zip 在迭代器中返回
Dialogue: 0,0:19:43.47,0:19:45.60,*Default,NTP,0000,0000,0000,,为您提供每一项
Dialogue: 0,0:19:45.60,0:19:47.50,*Default,NTP,0000,0000,0000,,按照与之前相同的顺序
Dialogue: 0,0:19:49.53,0:19:52.20,*Default,NTP,0000,0000,0000,,生成器是一种特殊的迭代器
Dialogue: 0,0:19:52.37,0:19:55.47,*Default,NTP,0000,0000,0000,,就像地图对象是一种特殊的迭代器一样
Dialogue: 0,0:19:56.13,0:19:58.33,*Default,NTP,0000,0000,0000,,发电机的特别之处
Dialogue: 0,0:19:58.60,0:20:01.47,*Default,NTP,0000,0000,0000,,是它从生成器函数返回
Dialogue: 0,0:20:02.57,0:20:05.30,*Default,NTP,0000,0000,0000,,生成器函数看起来像常规函数
Dialogue: 0,0:20:05.30,0:20:06.50,*Default,NTP,0000,0000,0000,,这是一个例子
Dialogue: 0,0:20:07.10,0:20:11.07,*Default,NTP,0000,0000,0000,,不同之处在于它使用了yield关键字
Dialogue: 0,0:20:11.17,0:20:12.80,*Default,NTP,0000,0000,0000,,而不是返回
Dialogue: 0,0:20:13.40,0:20:15.40,*Default,NTP,0000,0000,0000,,为了返回值
Dialogue: 0,0:20:15.73,0:20:18.57,*Default,NTP,0000,0000,0000,,所以我知道这是一个生成器函数，因为它有
Dialogue: 0,0:20:18.57,0:20:19.93,*Default,NTP,0000,0000,0000,,在某处产生
Dialogue: 0,0:20:20.70,0:20:23.97,*Default,NTP,0000,0000,0000,,当我对值三调用加减时
Dialogue: 0,0:20:24.67,0:20:26.80,*Default,NTP,0000,0000,0000,,我拿回了一台发电机
Dialogue: 0,0:20:28.30,0:20:30.30,*Default,NTP,0000,0000,0000,,这个生成器是一个迭代器
Dialogue: 0,0:20:30.50,0:20:32.90,*Default,NTP,0000,0000,0000,,意味着我可以迭代这些值
Dialogue: 0,0:20:32.90,0:20:35.00,*Default,NTP,0000,0000,0000,,由加减得出
Dialogue: 0,0:20:35.20,0:20:37.60,*Default,NTP,0000,0000,0000,,所以如果我接下来打电话，我会得到三个
Dialogue: 0,0:20:37.90,0:20:41.80,*Default,NTP,0000,0000,0000,,但我可以再次调用 next t 以获得 -3
Dialogue: 0,0:20:42.13,0:20:43.80,*Default,NTP,0000,0000,0000,,所以你可以看到这两个
Dialogue: 0,0:20:43.80,0:20:46.27,*Default,NTP,0000,0000,0000,,正在执行yield语句
Dialogue: 0,0:20:47.00,0:20:49.53,*Default,NTP,0000,0000,0000,,t 本身是一个生成器对象
Dialogue: 0,0:20:49.80,0:20:52.33,*Default,NTP,0000,0000,0000,,它的工作是帮助迭代
Dialogue: 0,0:20:52.33,0:20:54.07,*Default,NTP,0000,0000,0000,,所有产生的值
Dialogue: 0,0:20:54.07,0:20:55.70,*Default,NTP,0000,0000,0000,,被调用的函数的
Dialogue: 0,0:20:56.53,0:20:57.97,*Default,NTP,0000,0000,0000,,所以生成器函数
Dialogue: 0,0:20:57.97,0:20:58.60,*Default,NTP,0000,0000,0000,,是一个函数
Dialogue: 0,0:20:58.60,0:21:00.90,*Default,NTP,0000,0000,0000,,产生值而不是返回值
Dialogue: 0,0:21:01.27,0:21:03.40,*Default,NTP,0000,0000,0000,,普通函数只返回一次
Dialogue: 0,0:21:03.40,0:21:06.33,*Default,NTP,0000,0000,0000,,但生成器函数可以产生多次
Dialogue: 0,0:21:06.80,0:21:08.57,*Default,NTP,0000,0000,0000,,生成器是一个迭代器
Dialogue: 0,0:21:08.57,0:21:09.93,*Default,NTP,0000,0000,0000,,自动创建
Dialogue: 0,0:21:09.93,0:21:12.50,*Default,NTP,0000,0000,0000,,每当你调用生成器函数时
Dialogue: 0,0:21:12.73,0:21:15.20,*Default,NTP,0000,0000,0000,,所以这是我们调用的调用表达式
Dialogue: 0,0:21:15.33,0:21:17.87,*Default,NTP,0000,0000,0000,,加减并得到一个发电机
Dialogue: 0,0:21:18.73,0:21:20.37,*Default,NTP,0000,0000,0000,,当调用生成器函数时
Dialogue: 0,0:21:20.37,0:21:21.67,*Default,NTP,0000,0000,0000,,它返回一个生成器
Dialogue: 0,0:21:21.80,0:21:23.60,*Default,NTP,0000,0000,0000,,并且该生成器迭代
Dialogue: 0,0:21:23.60,0:21:25.33,*Default,NTP,0000,0000,0000,,函数的收益率
Dialogue: 0,0:21:26.57,0:21:28.00,*Default,NTP,0000,0000,0000,,这是另一个例子
Dialogue: 0,0:21:28.33,0:21:30.10,*Default,NTP,0000,0000,0000,,假设我想要
Dialogue: 0,0:21:30.33,0:21:34.20,*Default,NTP,0000,0000,0000,,返回仅遍历偶数的迭代器
Dialogue: 0,0:21:35.10,0:21:37.77,*Default,NTP,0000,0000,0000,,我给出整数起点和终点
Dialogue: 0,0:21:37.93,0:21:39.17,*Default,NTP,0000,0000,0000,,但我想确定
Dialogue: 0,0:21:39.20,0:21:40.13,*Default,NTP,0000,0000,0000,,我实际上
Dialogue: 0,0:21:40.13,0:21:41.50,*Default,NTP,0000,0000,0000,,从偶数开始
Dialogue: 0,0:21:41.50,0:21:43.50,*Default,NTP,0000,0000,0000,,大于等于开始
Dialogue: 0,0:21:44.10,0:21:46.97,*Default,NTP,0000,0000,0000,,所以下一个偶数是开始加上
Dialogue: 0,0:21:46.97,0:21:48.37,*Default,NTP,0000,0000,0000,,零或一
Dialogue: 0,0:21:48.37,0:21:50.73,*Default,NTP,0000,0000,0000,,取决于 start 是偶数还是 on
Dialogue: 0,0:21:51.50,0:21:53.87,*Default,NTP,0000,0000,0000,,虽然这个偶数的情况
Dialogue: 0,0:21:53.87,0:21:55.17,*Default,NTP,0000,0000,0000,,还没有结束
Dialogue: 0,0:21:55.37,0:21:57.37,*Default,NTP,0000,0000,0000,,我将屈服它
Dialogue: 0,0:21:59.37,0:22:00.97,*Default,NTP,0000,0000,0000,,然后我会增加甚至
Dialogue: 0,0:22:00.97,0:22:03.33,*Default,NTP,0000,0000,0000,,乘以 2 得到下一个偶数
Dialogue: 0,0:22:04.60,0:22:06.33,*Default,NTP,0000,0000,0000,,所以当我打电话给evens时
Dialogue: 0,0:22:06.77,0:22:09.13,*Default,NTP,0000,0000,0000,,我从两个增加到十个
Dialogue: 0,0:22:09.90,0:22:11.77,*Default,NTP,0000,0000,0000,,我得到一个生成器对象
Dialogue: 0,0:22:11.93,0:22:13.70,*Default,NTP,0000,0000,0000,,这会给我两个然后四个
Dialogue: 0,0:22:13.70,0:22:14.93,*Default,NTP,0000,0000,0000,,然后六个然后八个
Dialogue: 0,0:22:15.00,0:22:16.47,*Default,NTP,0000,0000,0000,,然后停止迭代
Dialogue: 0,0:22:16.47,0:22:17.40,*Default,NTP,0000,0000,0000,,意味着我们完成了
Dialogue: 0,0:22:19.50,0:22:22.17,*Default,NTP,0000,0000,0000,,如果我列出 1 到 10 之间的所有偶数
Dialogue: 0,0:22:22.27,0:22:23.67,*Default,NTP,0000,0000,0000,,仍然是两点开始
Dialogue: 0,0:22:23.70,0:22:26.00,*Default,NTP,0000,0000,0000,,向上经过但不包括 10
Dialogue: 0,0:22:26.67,0:22:28.67,*Default,NTP,0000,0000,0000,,那么这里实际发生了什么
Dialogue: 0,0:22:29.73,0:22:32.00,*Default,NTP,0000,0000,0000,,当我创建一个生成器时
Dialogue: 0,0:22:32.27,0:22:34.40,*Default,NTP,0000,0000,0000,,通过调用生成器函数
Dialogue: 0,0:22:35.30,0:22:37.33,*Default,NTP,0000,0000,0000,,我还没开始
Dialogue: 0,0:22:37.33,0:22:39.80,*Default,NTP,0000,0000,0000,,尚未执行该函数的主体
Dialogue: 0,0:22:40.33,0:22:42.57,*Default,NTP,0000,0000,0000,,直到 next 被调用
Dialogue: 0,0:22:43.73,0:22:46.20,*Default,NTP,0000,0000,0000,,身体开始被处决
Dialogue: 0,0:22:46.53,0:22:47.97,*Default,NTP,0000,0000,0000,,并且它继续执行
Dialogue: 0,0:22:47.97,0:22:51.00,*Default,NTP,0000,0000,0000,,直到到达yield语句
Dialogue: 0,0:22:51.10,0:22:52.13,*Default,NTP,0000,0000,0000,,此时
Dialogue: 0,0:22:52.30,0:22:53.97,*Default,NTP,0000,0000,0000,,该数字已产生
Dialogue: 0,0:22:53.97,0:22:56.73,*Default,NTP,0000,0000,0000,,作为迭代器 t 中的下一个元素
Dialogue: 0,0:22:57.80,0:22:59.00,*Default,NTP,0000,0000,0000,,在那种情况下
Dialogue: 0,0:22:59.00,0:23:02.47,*Default,NTP,0000,0000,0000,,执行在该产量处暂停，但会记住
Dialogue: 0,0:23:02.50,0:23:04.00,*Default,NTP,0000,0000,0000,,所有的环境
Dialogue: 0,0:23:04.10,0:23:06.13,*Default,NTP,0000,0000,0000,,函数执行的过程
Dialogue: 0,0:23:06.77,0:23:09.57,*Default,NTP,0000,0000,0000,,这样下次下一次就被称为
Dialogue: 0,0:23:09.67,0:23:11.70,*Default,NTP,0000,0000,0000,,它可以从中断处继续
Dialogue: 0,0:23:11.90,0:23:15.07,*Default,NTP,0000,0000,0000,,所以我要做的下一件事是将两个加到偶数
Dialogue: 0,0:23:15.57,0:23:18.13,*Default,NTP,0000,0000,0000,,继续回到狂野语句
Dialogue: 0,0:23:18.17,0:23:20.00,*Default,NTP,0000,0000,0000,,看到 Even 小于 end
Dialogue: 0,0:23:20.00,0:23:22.10,*Default,NTP,0000,0000,0000,,并产生下一个偶数
Dialogue: 0,0:23:22.80,0:23:23.70,*Default,NTP,0000,0000,0000,,以及什么是强大的
Dialogue: 0,0:23:23.70,0:23:25.60,*Default,NTP,0000,0000,0000,,关于生成器是你可以设置
Dialogue: 0,0:23:25.60,0:23:27.30,*Default,NTP,0000,0000,0000,,任何你想要的计算
Dialogue: 0,0:23:27.70,0:23:30.60,*Default,NTP,0000,0000,0000,,并且该计算将被延迟执行
Dialogue: 0,0:23:31.27,0:23:33.93,*Default,NTP,0000,0000,0000,,所以当有人询问下一个元素时
Dialogue: 0,0:23:34.07,0:23:36.67,*Default,NTP,0000,0000,0000,,然后你继续直到达到下一个产量
Dialogue: 0,0:23:36.80,0:23:38.40,*Default,NTP,0000,0000,0000,,但如果没人问
Dialogue: 0,0:23:38.53,0:23:39.60,*Default,NTP,0000,0000,0000,,对于所有元素
Dialogue: 0,0:23:39.60,0:23:41.97,*Default,NTP,0000,0000,0000,,那么你就不必继续计算一切
Dialogue: 0,0:23:42.27,0:23:45.87,*Default,NTP,0000,0000,0000,,你只需暂停直到需要下一个值
Dialogue: 0,0:23:46.53,0:23:49.47,*Default,NTP,0000,0000,0000,,生成器函数返回生成器
Dialogue: 0,0:23:49.70,0:23:52.57,*Default,NTP,0000,0000,0000,,但他们经常处理迭代器
Dialogue: 0,0:23:53.20,0:23:55.13,*Default,NTP,0000,0000,0000,,他们的执行过程
Dialogue: 0,0:23:56.00,0:24:00.17,*Default,NTP,0000,0000,0000,,这种情况在 python 3.3 中经常发生
Dialogue: 0,0:24:00.47,0:24:02.40,*Default,NTP,0000,0000,0000,,2002年发布
Dialogue: 0,0:24:03.33,0:24:06.13,*Default,NTP,0000,0000,0000,,他们添加了一个新的声明yield from
Dialogue: 0,0:24:06.50,0:24:08.07,*Default,NTP,0000,0000,0000,,只有一个发电机
Dialogue: 0,0:24:08.17,0:24:11.20,*Default,NTP,0000,0000,0000,,产生其他迭代器中的所有元素
Dialogue: 0,0:24:12.27,0:24:14.00,*Default,NTP,0000,0000,0000,,因此，yield from 语句会产生所有
Dialogue: 0,0:24:14.00,0:24:15.20,*Default,NTP,0000,0000,0000,,来自迭代器的值
Dialogue: 0,0:24:15.20,0:24:16.30,*Default,NTP,0000,0000,0000,,或可迭代的
Dialogue: 0,0:24:16.40,0:24:20.40,*Default,NTP,0000,0000,0000,,例如，假设我想定义 a then b
Dialogue: 0,0:24:20.80,0:24:22.73,*Default,NTP,0000,0000,0000,,这是一个函数，它接受
Dialogue: 0,0:24:22.97,0:24:25.73,*Default,NTP,0000,0000,0000,,两个可迭代对象或迭代器
Dialogue: 0,0:24:26.00,0:24:28.27,*Default,NTP,0000,0000,0000,,并返回第一个中的所有元素
Dialogue: 0,0:24:28.27,0:24:30.57,*Default,NTP,0000,0000,0000,,接下来是第二个中的所有元素
Dialogue: 0,0:24:31.20,0:24:34.10,*Default,NTP,0000,0000,0000,,我可以这样写的一种方法是对于 x 和 a
Dialogue: 0,0:24:34.10,0:24:37.30,*Default,NTP,0000,0000,0000,,产生 x，然后对于 x 和 b 产生 x
Dialogue: 0,0:24:38.77,0:24:40.13,*Default,NTP,0000,0000,0000,,但有一个更简单的方法
Dialogue: 0,0:24:40.20,0:24:42.93,*Default,NTP,0000,0000,0000,,我可以只写yield from a 然后yield from b
Dialogue: 0,0:24:43.60,0:24:45.27,*Default,NTP,0000,0000,0000,,这些是完全等价的
Dialogue: 0,0:24:45.30,0:24:46.53,*Default,NTP,0000,0000,0000,,所以你可以考虑产量
Dialogue: 0,0:24:46.53,0:24:47.67,*Default,NTP,0000,0000,0000,,这只是简写
Dialogue: 0,0:24:47.73,0:24:49.30,*Default,NTP,0000,0000,0000,,写下四个陈述
Dialogue: 0,0:24:49.30,0:24:51.07,*Default,NTP,0000,0000,0000,,在这里你可以浏览 a 中的所有元素
Dialogue: 0,0:24:51.13,0:24:52.13,*Default,NTP,0000,0000,0000,,并产生它们
Dialogue: 0,0:24:53.27,0:24:55.70,*Default,NTP,0000,0000,0000,,但它确实可以让你避免给出名字
Dialogue: 0,0:24:55.90,0:24:58.10,*Default,NTP,0000,0000,0000,,此序列中的每个项目
Dialogue: 0,0:24:58.17,0:24:59.73,*Default,NTP,0000,0000,0000,,它只会清理你的外套
Dialogue: 0,0:25:01.10,0:25:02.27,*Default,NTP,0000,0000,0000,,这是另一个例子
Dialogue: 0,0:25:02.27,0:25:04.70,*Default,NTP,0000,0000,0000,,假设我们要定义一个生成器函数
Dialogue: 0,0:25:04.70,0:25:06.47,*Default,NTP,0000,0000,0000,,从五倒数
Dialogue: 0,0:25:07.27,0:25:09.60,*Default,NTP,0000,0000,0000,,我可以做到的一种方法是递归
Dialogue: 0,0:25:09.97,0:25:12.67,*Default,NTP,0000,0000,0000,,如果 k 大于零，则 I 产生 k
Dialogue: 0,0:25:12.77,0:25:16.13,*Default,NTP,0000,0000,0000,,然后我产生倒计时 k 中的所有值减一
Dialogue: 0,0:25:16.53,0:25:19.90,*Default,NTP,0000,0000,0000,,通过从倒计时 k 减一调用 Yield
Dialogue: 0,0:25:21.20,0:25:23.20,*Default,NTP,0000,0000,0000,,所以如果我从 k 开始倒数
Dialogue: 0,0:25:24.10,0:25:25.73,*Default,NTP,0000,0000,0000,,如果 kray 大于零
Dialogue: 0,0:25:25.73,0:25:27.80,*Default,NTP,0000,0000,0000,,我绝对想先产生 k
Dialogue: 0,0:25:28.77,0:25:32.37,*Default,NTP,0000,0000,0000,,如果我写错了，我只是写了收益率倒计时
Dialogue: 0,0:25:32.97,0:25:34.20,*Default,NTP,0000,0000,0000,,k 减一
Dialogue: 0,0:25:35.13,0:25:39.30,*Default,NTP,0000,0000,0000,,我返回的迭代器中的第二个元素
Dialogue: 0,0:25:39.47,0:25:41.53,*Default,NTP,0000,0000,0000,,实际上只是另一个迭代器
Dialogue: 0,0:25:43.53,0:25:46.50,*Default,NTP,0000,0000,0000,,所以从三开始倒数会很好
Dialogue: 0,0:25:46.67,0:25:49.27,*Default,NTP,0000,0000,0000,,但接下来我要返回的是一个生成器对象
Dialogue: 0,0:25:49.27,0:25:50.47,*Default,NTP,0000,0000,0000,,这不是我所期望的
Dialogue: 0,0:25:50.47,0:25:52.07,*Default,NTP,0000,0000,0000,,我期待的是No.2
Dialogue: 0,0:25:52.67,0:25:54.40,*Default,NTP,0000,0000,0000,,所以得到数字二和一
Dialogue: 0,0:25:54.40,0:25:56.33,*Default,NTP,0000,0000,0000,,我必须写一个四项声明
Dialogue: 0,0:25:58.07,0:26:00.90,*Default,NTP,0000,0000,0000,,并产生四个语句中的每个元素
Dialogue: 0,0:26:01.47,0:26:04.27,*Default,NTP,0000,0000,0000,,然后如果我倒数的话我会得到三个
Dialogue: 0,0:26:04.50,0:26:06.17,*Default,NTP,0000,0000,0000,,然后两个然后一个
Dialogue: 0,0:26:07.37,0:26:09.07,*Default,NTP,0000,0000,0000,,以及执行此操作的简写方法
Dialogue: 0,0:26:09.10,0:26:11.00,*Default,NTP,0000,0000,0000,,而不是写四个语句
Dialogue: 0,0:26:11.00,0:26:12.80,*Default,NTP,0000,0000,0000,,我刚刚读到产量
Dialogue: 0,0:26:13.37,0:26:15.10,*Default,NTP,0000,0000,0000,,一切都在倒计时
Dialogue: 0,0:26:16.33,0:26:19.27,*Default,NTP,0000,0000,0000,,最后我得到了 3 2 1
Dialogue: 0,0:26:20.57,0:26:22.97,*Default,NTP,0000,0000,0000,,如果最后说发射不是很酷吗
Dialogue: 0,0:26:23.00,0:26:24.20,*Default,NTP,0000,0000,0000,,好吧，我们可以改变这一点
Dialogue: 0,0:26:24.27,0:26:25.57,*Default,NTP,0000,0000,0000,,我们可以说别的
Dialogue: 0,0:26:25.80,0:26:26.60,*Default,NTP,0000,0000,0000,,屈服
Dialogue: 0,0:26:27.17,0:26:28.50,*Default,NTP,0000,0000,0000,,发射
Dialogue: 0,0:26:29.20,0:26:31.77,*Default,NTP,0000,0000,0000,,好的，现在我们可以尝试每一个
Dialogue: 0,0:26:32.27,0:26:34.13,*Default,NTP,0000,0000,0000,,k 倒计时
Dialogue: 0,0:26:35.30,0:26:36.17,*Default,NTP,0000,0000,0000,,三
Dialogue: 0,0:26:37.30,0:26:38.37,*Default,NTP,0000,0000,0000,,打印 k
Dialogue: 0,0:26:39.40,0:26:41.73,*Default,NTP,0000,0000,0000,,它给了我整个倒计时序列
Dialogue: 0,0:26:41.73,0:26:43.70,*Default,NTP,0000,0000,0000,,最后还有一些令人兴奋的事情
Dialogue: 0,0:26:45.10,0:26:48.30,*Default,NTP,0000,0000,0000,,让我们用一个稍微复杂一点的例子来结束
Dialogue: 0,0:26:49.00,0:26:53.27,*Default,NTP,0000,0000,0000,,我可以产生 s 的所有前缀
Dialogue: 0,0:26:53.90,0:26:55.47,*Default,NTP,0000,0000,0000,,或者我会假设 s 是一个字符串
Dialogue: 0,0:26:55.47,0:26:57.27,*Default,NTP,0000,0000,0000,,但它确实可以是任何可迭代的
Dialogue: 0,0:26:57.67,0:26:59.07,*Default,NTP,0000,0000,0000,,如果不为空
Dialogue: 0,0:26:59.17,0:27:01.73,*Default,NTP,0000,0000,0000,,然后我将从前缀中产生
Dialogue: 0,0:27:02.07,0:27:04.17,*Default,NTP,0000,0000,0000,,全部 s 和 2
Dialogue: 0,0:27:04.17,0:27:06.57,*Default,NTP,0000,0000,0000,,但不包括最后一个元素
Dialogue: 0,0:27:07.47,0:27:09.73,*Default,NTP,0000,0000,0000,,然后我会产生 s 本身
Dialogue: 0,0:27:10.47,0:27:12.33,*Default,NTP,0000,0000,0000,,所以两者的前缀
Dialogue: 0,0:27:12.77,0:27:14.53,*Default,NTP,0000,0000,0000,,是一个生成器对象
Dialogue: 0,0:27:14.57,0:27:16.10,*Default,NTP,0000,0000,0000,,如果我把它们列出来
Dialogue: 0,0:27:16.60,0:27:19.37,*Default,NTP,0000,0000,0000,,然后我得到 b bo 机器人，两者都
Dialogue: 0,0:27:19.57,0:27:20.87,*Default,NTP,0000,0000,0000,,我按这个顺序得到它们
Dialogue: 0,0:27:20.87,0:27:25.00,*Default,NTP,0000,0000,0000,,因为我在yield s本身之前从前缀中yield
Dialogue: 0,0:27:26.37,0:27:28.33,*Default,NTP,0000,0000,0000,,一旦我可以生成前缀
Dialogue: 0,0:27:28.33,0:27:30.50,*Default,NTP,0000,0000,0000,,我还可以生成子字符串
Dialogue: 0,0:27:31.90,0:27:33.47,*Default,NTP,0000,0000,0000,,如果 s 不为空
Dialogue: 0,0:27:33.67,0:27:36.67,*Default,NTP,0000,0000,0000,,那么一些子串只是前缀
Dialogue: 0,0:27:36.67,0:27:38.33,*Default,NTP,0000,0000,0000,,所以我会放弃所有这些
Dialogue: 0,0:27:40.17,0:27:43.53,*Default,NTP,0000,0000,0000,,然后我将从子字符串中产生
Dialogue: 0,0:27:43.80,0:27:45.53,*Default,NTP,0000,0000,0000,,字符串的其余部分
Dialogue: 0,0:27:47.77,0:27:49.10,*Default,NTP,0000,0000,0000,,所以子串
Dialogue: 0,0:27:50.37,0:27:52.47,*Default,NTP,0000,0000,0000,,例如上衣
Dialogue: 0,0:27:52.70,0:27:53.87,*Default,NTP,0000,0000,0000,,是一个发电机
Dialogue: 0,0:27:53.97,0:27:59.20,*Default,NTP,0000,0000,0000,,如果我列出其内容，那么我会看到两个顶部和顶部
Dialogue: 0,0:27:59.20,0:28:01.57,*Default,NTP,0000,0000,0000,,这些都是tops的前缀
Dialogue: 0,0:28:01.77,0:28:06.20,*Default,NTP,0000,0000,0000,,但后来我得到了 ops oop ops 的所有前缀
Dialogue: 0,0:28:06.37,0:28:08.80,*Default,NTP,0000,0000,0000,,然后是 PPS 和 s
Dialogue: 0,0:28:09.40,0:28:12.73,*Default,NTP,0000,0000,0000,,这些就是 top 的所有子串
