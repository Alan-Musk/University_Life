[Script Info]
Title: Lecture 21. Composition_哔哩哔哩_bilibili
ScriptType: v4.00+
Collisions: Reverse
PlayResX: 1280
PlayResY: 720
WrapStyle: 3
ScaledBorderAndShadow: yes
; ----------------------
; 本字幕由CC字幕助手自动转换
; 字幕来源https://www.bilibili.com/video/BV1s3411G7yM?p=51&vd_source=6ffca0aa1006734a4fba52f389036611
; 脚本地址https://greasyfork.org/scripts/378513
; 设置了字幕过长自动换行，但若字幕中没有空格换行将无效
; 字体大小依据720p 48号字体等比缩放
; 如显示不正常请尝试使用SRT格式

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Segoe UI,48,&H00FFFFFF,&HF0000000,&H00000000,&HF0000000,1,0,0,0,100,100,0,0.00,1,1,3,2,30,30,20,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.70,0:00:03.30,*Default,NTP,0000,0000,0000,,61 a 第 21 期讲座
Dialogue: 0,0:00:03.53,0:00:04.50,*Default,NTP,0000,0000,0000,,公告
Dialogue: 0,0:00:05.00,0:00:06.77,*Default,NTP,0000,0000,0000,,家庭作业四今天交
Dialogue: 0,0:00:07.20,0:00:08.93,*Default,NTP,0000,0000,0000,,下周五做
Dialogue: 0,0:00:09.00,0:00:10.33,*Default,NTP,0000,0000,0000,,但你必须在下周二之前做一部分
Dialogue: 0,0:00:10.33,0:00:12.47,*Default,NTP,0000,0000,0000,,下周二之前完成，以获得检查点
Dialogue: 0,0:00:12.53,0:00:14.73,*Default,NTP,0000,0000,0000,,提前提交作业可获得奖励分
Dialogue: 0,0:00:14.73,0:00:16.07,*Default,NTP,0000,0000,0000,,提交全部作业
Dialogue: 0,0:00:16.07,0:00:17.80,*Default,NTP,0000,0000,0000,,可以获得提前提交奖励分。
Dialogue: 0,0:00:18.00,0:00:19.47,*Default,NTP,0000,0000,0000,,这就是我的建议
Dialogue: 0,0:00:20.60,0:00:23.80,*Default,NTP,0000,0000,0000,,我们将把下周办公时间的工作人数增加一倍
Dialogue: 0,0:00:23.87,0:00:25.47,*Default,NTP,0000,0000,0000,,办公时间
Dialogue: 0,0:00:25.47,0:00:27.20,*Default,NTP,0000,0000,0000,,所以应该会有更多的预约
Dialogue: 0,0:00:27.27,0:00:30.10,*Default,NTP,0000,0000,0000,,和对办公时间 Q 的回应
Dialogue: 0,0:00:30.70,0:00:33.40,*Default,NTP,0000,0000,0000,,我们还有更多的人在广场工作
Dialogue: 0,0:00:33.77,0:00:34.87,*Default,NTP,0000,0000,0000,,希望我们能
Dialogue: 0,0:00:34.87,0:00:37.00,*Default,NTP,0000,0000,0000,,及时回答您的问题
Dialogue: 0,0:00:37.20,0:00:39.73,*Default,NTP,0000,0000,0000,,我知道在远程课程中很难得到帮助
Dialogue: 0,0:00:39.80,0:00:41.30,*Default,NTP,0000,0000,0000,,但我们会尽力
Dialogue: 0,0:00:41.50,0:00:44.33,*Default,NTP,0000,0000,0000,,但我们会尽最大努力，比上一个项目更及时地回复你们的问题。
Dialogue: 0,0:00:45.67,0:00:48.27,*Default,NTP,0000,0000,0000,,作业 5 将于明天发布
Dialogue: 0,0:00:48.30,0:00:49.33,*Default,NTP,0000,0000,0000,,而且不是下周
Dialogue: 0,0:00:49.40,0:00:52.70,*Default,NTP,0000,0000,0000,,不是下周，而是 26 日的下周一
Dialogue: 0,0:00:52.90,0:00:54.60,*Default,NTP,0000,0000,0000,,我们会尽量简短，因为
Dialogue: 0,0:00:54.60,0:00:56.70,*Default,NTP,0000,0000,0000,,因为本周一是期中考试之前
Dialogue: 0,0:00:57.53,0:00:59.20,*Default,NTP,0000,0000,0000,,完成作业
Dialogue: 0,0:00:59.20,0:01:01.57,*Default,NTP,0000,0000,0000,,是为期中考试做准备的好方法
Dialogue: 0,0:01:01.57,0:01:04.60,*Default,NTP,0000,0000,0000,,这就是为什么我们要在期中考试前做作业
Dialogue: 0,0:01:04.73,0:01:06.90,*Default,NTP,0000,0000,0000,,以确保你们得到一点练习
Dialogue: 0,0:01:07.33,0:01:09.07,*Default,NTP,0000,0000,0000,,该周还有一个实验
Dialogue: 0,0:01:09.07,0:01:11.53,*Default,NTP,0000,0000,0000,,但实验九是唯一的必修课
Dialogue: 0,0:01:11.53,0:01:13.00,*Default,NTP,0000,0000,0000,,也就是10月26日
Dialogue: 0,0:01:13.00,0:01:14.77,*Default,NTP,0000,0000,0000,,作业五的截止日期
Dialogue: 0,0:01:14.90,0:01:16.60,*Default,NTP,0000,0000,0000,,完成作业五
Dialogue: 0,0:01:17.30,0:01:19.40,*Default,NTP,0000,0000,0000,,还有几个选做题
Dialogue: 0,0:01:19.40,0:01:22.27,*Default,NTP,0000,0000,0000,,我强烈建议你们做这些实验题
Dialogue: 0,0:01:22.40,0:01:24.67,*Default,NTP,0000,0000,0000,,为期中考试做准备
Dialogue: 0,0:01:24.73,0:01:26.20,*Default,NTP,0000,0000,0000,,但没有任何要求
Dialogue: 0,0:01:26.20,0:01:27.87,*Default,NTP,0000,0000,0000,,所以你们只需要做一件事
Dialogue: 0,0:01:28.07,0:01:30.60,*Default,NTP,0000,0000,0000,,就是完成家庭作业五
Dialogue: 0,0:01:30.70,0:01:33.50,*Default,NTP,0000,0000,0000,,然后在周三参加期中考试
Dialogue: 0,0:01:34.57,0:01:37.70,*Default,NTP,0000,0000,0000,,期中考试将在两周后举行
Dialogue: 0,0:01:39.27,0:01:39.93,*Default,NTP,0000,0000,0000,,咨询
Dialogue: 0,0:01:39.93,0:01:42.93,*Default,NTP,0000,0000,0000,,办公时间为每周五下午 1:00 至 230:00。
Dialogue: 0,0:01:42.93,0:01:44.30,*Default,NTP,0000,0000,0000,,办公时间
Dialogue: 0,0:01:45.13,0:01:46.77,*Default,NTP,0000,0000,0000,,现在
Dialogue: 0,0:01:46.77,0:01:48.40,*Default,NTP,0000,0000,0000,,我们有一个匿名调查
Dialogue: 0,0:01:48.40,0:01:50.40,*Default,NTP,0000,0000,0000,,关于课程进展情况的匿名调查
Dialogue: 0,0:01:50.40,0:01:52.77,*Default,NTP,0000,0000,0000,,我鼓励你们回复
Dialogue: 0,0:01:52.90,0:01:55.13,*Default,NTP,0000,0000,0000,,我看到已经有几百人回复了
Dialogue: 0,0:01:55.13,0:01:56.70,*Default,NTP,0000,0000,0000,,谢谢
Dialogue: 0,0:01:57.40,0:01:58.70,*Default,NTP,0000,0000,0000,,我没有看到任何
Dialogue: 0,0:01:59.00,0:02:01.30,*Default,NTP,0000,0000,0000,,一致的建议
Dialogue: 0,0:02:01.30,0:02:03.10,*Default,NTP,0000,0000,0000,,期中考试的形式
Dialogue: 0,0:02:03.10,0:02:06.33,*Default,NTP,0000,0000,0000,,因此，它将与我们第一次期中考试的形式相当类似
Dialogue: 0,0:02:06.87,0:02:08.57,*Default,NTP,0000,0000,0000,,它将涵盖直到
Dialogue: 0,0:02:08.57,0:02:10.40,*Default,NTP,0000,0000,0000,,包括今天的讲座
Dialogue: 0,0:02:11.47,0:02:15.07,*Default,NTP,0000,0000,0000,,下周的讲座只是选修或复习
Dialogue: 0,0:02:15.70,0:02:17.47,*Default,NTP,0000,0000,0000,,有一点非常明确
Dialogue: 0,0:02:17.47,0:02:20.00,*Default,NTP,0000,0000,0000,,从匿名调查的反馈来看
Dialogue: 0,0:02:20.10,0:02:21.87,*Default,NTP,0000,0000,0000,,就是你们想要更多的练习
Dialogue: 0,0:02:21.87,0:02:24.30,*Default,NTP,0000,0000,0000,,处理树的问题
Dialogue: 0,0:02:24.50,0:02:27.60,*Default,NTP,0000,0000,0000,,今天的讲座我们将再次讨论树
Dialogue: 0,0:02:27.60,0:02:30.13,*Default,NTP,0000,0000,0000,,从面向对象的角度看树
Dialogue: 0,0:02:32.47,0:02:35.00,*Default,NTP,0000,0000,0000,,链表是一种基本的
Dialogue: 0,0:02:35.00,0:02:37.47,*Default,NTP,0000,0000,0000,,数据结构和计算机科学
Dialogue: 0,0:02:37.60,0:02:39.50,*Default,NTP,0000,0000,0000,,它们随处可见
Dialogue: 0,0:02:40.40,0:02:42.57,*Default,NTP,0000,0000,0000,,现在我们将学习如何实现它们
Dialogue: 0,0:02:42.80,0:02:45.13,*Default,NTP,0000,0000,0000,,使用 python 的对象系统
Dialogue: 0,0:02:46.77,0:02:48.87,*Default,NTP,0000,0000,0000,,因此，一个链表要么是
Dialogue: 0,0:02:48.87,0:02:51.13,*Default,NTP,0000,0000,0000,,空，因为它不包含任何内容
Dialogue: 0,0:02:51.70,0:02:55.33,*Default,NTP,0000,0000,0000,,或者它有某个序列中的第一个值
Dialogue: 0,0:02:55.53,0:02:59.17,*Default,NTP,0000,0000,0000,,然后是链表中的其余值
Dialogue: 0,0:03:00.50,0:03:02.70,*Default,NTP,0000,0000,0000,,下面是我们如何表示序列的方法
Dialogue: 0,0:03:02.70,0:03:04.40,*Default,NTP,0000,0000,0000,,3 4 5
Dialogue: 0,0:03:05.93,0:03:09.40,*Default,NTP,0000,0000,0000,,我们将使用一个名为链接的类的实例
Dialogue: 0,0:03:09.67,0:03:12.17,*Default,NTP,0000,0000,0000,,我还没有定义这个类，但很快就会定义了
Dialogue: 0,0:03:12.97,0:03:14.90,*Default,NTP,0000,0000,0000,,该类有两个属性
Dialogue: 0,0:03:15.13,0:03:16.90,*Default,NTP,0000,0000,0000,,第一个属性是 3
Dialogue: 0,0:03:17.13,0:03:20.90,*Default,NTP,0000,0000,0000,,其余的是某个对象
Dialogue: 0,0:03:21.10,0:03:25.17,*Default,NTP,0000,0000,0000,,现在，该对象将保存其余的值
Dialogue: 0,0:03:25.27,0:03:29.80,*Default,NTP,0000,0000,0000,,它本身也是一个链接列表或链接实例
Dialogue: 0,0:03:30.73,0:03:32.10,*Default,NTP,0000,0000,0000,,所以每个链表
Dialogue: 0,0:03:32.33,0:03:35.93,*Default,NTP,0000,0000,0000,,都有一个更小的链接列表，因为列表的其余部分
Dialogue: 0,0:03:37.67,0:03:41.53,*Default,NTP,0000,0000,0000,,因此这个链接实例的第一个值是 4
Dialogue: 0,0:03:41.73,0:03:43.90,*Default,NTP,0000,0000,0000,,而其列表中的其余链接
Dialogue: 0,0:03:43.90,0:03:46.30,*Default,NTP,0000,0000,0000,,实例的第一个值是五
Dialogue: 0,0:03:46.53,0:03:46.77,*Default,NTP,0000,0000,0000,,现在
Dialogue: 0,0:03:46.77,0:03:50.10,*Default,NTP,0000,0000,0000,,我们已经穷尽了所有要表示的内容
Dialogue: 0,0:03:51.00,0:03:53.87,*Default,NTP,0000,0000,0000,,但我们仍然需要一些其余属性
Dialogue: 0,0:03:54.00,0:03:58.80,*Default,NTP,0000,0000,0000,,在这种情况下，我们使用一个名为 link empty 的特殊值
Dialogue: 0,0:03:59.53,0:04:02.17,*Default,NTP,0000,0000,0000,,link empty 是规则的例外
Dialogue: 0,0:04:02.17,0:04:04.37,*Default,NTP,0000,0000,0000,,我刚才说过，每个链表
Dialogue: 0,0:04:04.67,0:04:07.40,*Default,NTP,0000,0000,0000,,都有一个其余的链接
Dialogue: 0,0:04:07.40,0:04:09.50,*Default,NTP,0000,0000,0000,,而 empty 没有任何首值
Dialogue: 0,0:04:09.50,0:04:11.10,*Default,NTP,0000,0000,0000,,或列表的其他部分
Dialogue: 0,0:04:11.30,0:04:14.57,*Default,NTP,0000,0000,0000,,它只是代表了一个事实：什么都没有了
Dialogue: 0,0:04:16.97,0:04:17.17,*Default,NTP,0000,0000,0000,,所以
Dialogue: 0,0:04:17.17,0:04:19.80,*Default,NTP,0000,0000,0000,,思考链接列表的正确方式并不是这个
Dialogue: 0,0:04:19.80,0:04:23.57,*Default,NTP,0000,0000,0000,,具有这些特定属性名的特定类
Dialogue: 0,0:04:23.60,0:04:25.50,*Default,NTP,0000,0000,0000,,而是一对值
Dialogue: 0,0:04:25.93,0:04:28.60,*Default,NTP,0000,0000,0000,,它是某个序列的第一个元素
Dialogue: 0,0:04:28.67,0:04:30.67,*Default,NTP,0000,0000,0000,,然后是该序列的其余部分
Dialogue: 0,0:04:32.33,0:04:34.80,*Default,NTP,0000,0000,0000,,在本例中，我们将第一个
Dialogue: 0,0:04:35.00,0:04:39.13,*Default,NTP,0000,0000,0000,,实际上，零 f 元素是一个属性值
Dialogue: 0,0:04:39.87,0:04:41.00,*Default,NTP,0000,0000,0000,,我称之为零
Dialogue: 0,0:04:41.00,0:04:43.87,*Default,NTP,0000,0000,0000,,因为它将对应索引零
Dialogue: 0,0:04:44.10,0:04:47.50,*Default,NTP,0000,0000,0000,,一旦我们找到了索引列表的方法
Dialogue: 0,0:04:51.33,0:04:55.10,*Default,NTP,0000,0000,0000,,列表的其余部分本身是一个链接列表或链接
Dialogue: 0,0:04:55.33,0:04:58.93,*Default,NTP,0000,0000,0000,,空，并存储为另一个属性
Dialogue: 0,0:04:59.47,0:05:03.50,*Default,NTP,0000,0000,0000,,因此，你可以拥有作为属性值的对象
Dialogue: 0,0:05:03.67,0:05:07.00,*Default,NTP,0000,0000,0000,,在这里，我们使用了组合的概念
Dialogue: 0,0:05:07.13,0:05:10.17,*Default,NTP,0000,0000,0000,,来构建一个有趣的结构
Dialogue: 0,0:05:11.93,0:05:17.37,*Default,NTP,0000,0000,0000,,因此，一个链接列表的属性值是一个链接列表
Dialogue: 0,0:05:19.00,0:05:21.40,*Default,NTP,0000,0000,0000,,最后，还有一些类属性
Dialogue: 0,0:05:21.77,0:05:24.33,*Default,NTP,0000,0000,0000,,我们把它称为 link empty。
Dialogue: 0,0:05:24.33,0:05:26.20,*Default,NTP,0000,0000,0000,,我们称之为 link empty
Dialogue: 0,0:05:28.27,0:05:30.70,*Default,NTP,0000,0000,0000,,现在，我们构建这个结构的方法不是写三个
Dialogue: 0,0:05:30.70,0:05:32.07,*Default,NTP,0000,0000,0000,,来一个四来一个五
Dialogue: 0,0:05:32.27,0:05:33.53,*Default,NTP,0000,0000,0000,,来构成一个元组
Dialogue: 0,0:05:33.97,0:05:36.90,*Default,NTP,0000,0000,0000,,而是要写出构造函数
Dialogue: 0,0:05:37.30,0:05:38.77,*Default,NTP,0000,0000,0000,,a link with three
Dialogue: 0,0:05:39.10,0:05:41.53,*Default,NTP,0000,0000,0000,,的链接，而列表的其余部分是一个从四开始的链接
Dialogue: 0,0:05:41.53,0:05:44.47,*Default,NTP,0000,0000,0000,,该列表的其余部分是一个以五开头的链接
Dialogue: 0,0:05:44.80,0:05:47.20,*Default,NTP,0000,0000,0000,,该列表的其余部分是空的链接
Dialogue: 0,0:05:49.47,0:05:51.60,*Default,NTP,0000,0000,0000,,所以每次调用 link
Dialogue: 0,0:05:51.60,0:05:53.37,*Default,NTP,0000,0000,0000,,都会创建一个新的链接实例
Dialogue: 0,0:05:54.40,0:05:56.57,*Default,NTP,0000,0000,0000,,这次调用创建的实例
Dialogue: 0,0:05:57.17,0:06:00.17,*Default,NTP,0000,0000,0000,,这个实例必须存在，才能进行这次调用
Dialogue: 0,0:06:01.00,0:06:03.93,*Default,NTP,0000,0000,0000,,会创建一个从四
Dialogue: 0,0:06:03.93,0:06:05.27,*Default,NTP,0000,0000,0000,,然后是五
Dialogue: 0,0:06:06.10,0:06:08.07,*Default,NTP,0000,0000,0000,,这里
Dialogue: 0,0:06:08.07,0:06:10.80,*Default,NTP,0000,0000,0000,,函数在 python 中的运算顺序非常重要
Dialogue: 0,0:06:11.60,0:06:13.10,*Default,NTP,0000,0000,0000,,为了评估 link
Dialogue: 0,0:06:13.10,0:06:16.10,*Default,NTP,0000,0000,0000,,为逗号 link five 逗号 link mt
Dialogue: 0,0:06:16.30,0:06:17.60,*Default,NTP,0000,0000,0000,,我们有第一个
Dialogue: 0,0:06:18.60,0:06:20.70,*Default,NTP,0000,0000,0000,,评估这个
Dialogue: 0,0:06:20.90,0:06:22.53,*Default,NTP,0000,0000,0000,,操作符子表达式
Dialogue: 0,0:06:22.53,0:06:24.60,*Default,NTP,0000,0000,0000,,以创建链接实例
Dialogue: 0,0:06:24.60,0:06:27.93,*Default,NTP,0000,0000,0000,,表示从
Dialogue: 0,0:06:27.97,0:06:29.30,*Default,NTP,0000,0000,0000,,后无其他内容的链接实例
Dialogue: 0,0:06:29.60,0:06:32.70,*Default,NTP,0000,0000,0000,,一旦创建完成，我们就可以把它作为参数传递给
Dialogue: 0,0:06:32.77,0:06:35.33,*Default,NTP,0000,0000,0000,,到这个以 4 开始
Dialogue: 0,0:06:35.40,0:06:37.30,*Default,NTP,0000,0000,0000,,的链接的参数。
Dialogue: 0,0:06:37.90,0:06:40.50,*Default,NTP,0000,0000,0000,,最后，我们可以评估整个表达式
Dialogue: 0,0:06:40.73,0:06:42.80,*Default,NTP,0000,0000,0000,,并建立整个链表
Dialogue: 0,0:06:45.93,0:06:48.50,*Default,NTP,0000,0000,0000,,这些结构在计算机科学中非常常见
Dialogue: 0,0:06:48.50,0:06:50.53,*Default,NTP,0000,0000,0000,,这些结构在计算机科学中非常常见
Dialogue: 0,0:06:50.80,0:06:52.67,*Default,NTP,0000,0000,0000,,关于如何绘制它们
Dialogue: 0,0:06:53.47,0:06:53.93,*Default,NTP,0000,0000,0000,,通常
Dialogue: 0,0:06:53.93,0:06:56.87,*Default,NTP,0000,0000,0000,,你可以将它们绘制成带箭头的成对序列
Dialogue: 0,0:06:56.87,0:06:57.73,*Default,NTP,0000,0000,0000,,像这样
Dialogue: 0,0:06:57.97,0:07:00.87,*Default,NTP,0000,0000,0000,,但不是画一个箭头来连接空的
Dialogue: 0,0:07:00.90,0:07:03.67,*Default,NTP,0000,0000,0000,,而不是画一个箭头来连接空的部分，这是很常见的做法。
Dialogue: 0,0:07:03.90,0:07:06.30,*Default,NTP,0000,0000,0000,,这不是任何正式的符号
Dialogue: 0,0:07:06.30,0:07:08.47,*Default,NTP,0000,0000,0000,,但你会在世界上看到有人这么做
Dialogue: 0,0:07:08.47,0:07:09.90,*Default,NTP,0000,0000,0000,,所以我想现在就给你演示一下
Dialogue: 0,0:07:11.37,0:07:13.20,*Default,NTP,0000,0000,0000,,在我们的实现中
Dialogue: 0,0:07:13.27,0:07:15.93,*Default,NTP,0000,0000,0000,,我们将照搬这种结构
Dialogue: 0,0:07:16.13,0:07:17.33,*Default,NTP,0000,0000,0000,,将 link
Dialogue: 0,0:07:17.53,0:07:21.70,*Default,NTP,0000,0000,0000,,空作为其余属性的默认值
Dialogue: 0,0:07:21.90,0:07:23.73,*Default,NTP,0000,0000,0000,,这意味着
Dialogue: 0,0:07:23.73,0:07:25.73,*Default,NTP,0000,0000,0000,,当你想构建一个链接列表时
Dialogue: 0,0:07:28.33,0:07:30.80,*Default,NTP,0000,0000,0000,,所以我们希望这个表达式实际上
Dialogue: 0,0:07:30.80,0:07:32.50,*Default,NTP,0000,0000,0000,,评估到一个链接实例
Dialogue: 0,0:07:32.50,0:07:35.73,*Default,NTP,0000,0000,0000,,代表序列 3 4 5
Dialogue: 0,0:07:35.97,0:07:38.10,*Default,NTP,0000,0000,0000,,为此，我们需要一个类语句
Dialogue: 0,0:07:38.73,0:07:42.30,*Default,NTP,0000,0000,0000,,在链接列表类中，我们只需在其中添加一个
Dialogue: 0,0:07:42.70,0:07:45.73,*Default,NTP,0000,0000,0000,,方法，该方法接收第一个和其余的
Dialogue: 0,0:07:45.90,0:07:48.73,*Default,NTP,0000,0000,0000,,这里是类，这里是 in it 方法
Dialogue: 0,0:07:48.87,0:07:50.30,*Default,NTP,0000,0000,0000,,正如我之前提到的
Dialogue: 0,0:07:50.30,0:07:52.87,*Default,NTP,0000,0000,0000,,我们将为其余部分设置一个默认值
Dialogue: 0,0:07:52.93,0:07:54.50,*Default,NTP,0000,0000,0000,,链接为空
Dialogue: 0,0:07:54.57,0:07:56.17,*Default,NTP,0000,0000,0000,,我还没有找到
Dialogue: 0,0:07:57.70,0:08:00.13,*Default,NTP,0000,0000,0000,,首先要做的是确保
Dialogue: 0,0:08:00.13,0:08:03.60,*Default,NTP,0000,0000,0000,,我们构建的链接列表是完整的
Dialogue: 0,0:08:03.80,0:08:05.67,*Default,NTP,0000,0000,0000,,它遵循我所说的属性
Dialogue: 0,0:08:05.67,0:08:07.27,*Default,NTP,0000,0000,0000,,即列表的其余部分
Dialogue: 0,0:08:07.27,0:08:08.77,*Default,NTP,0000,0000,0000,,必须是空列表
Dialogue: 0,0:08:08.77,0:08:09.90,*Default,NTP,0000,0000,0000,,链接空列表
Dialogue: 0,0:08:10.33,0:08:13.97,*Default,NTP,0000,0000,0000,,或者是链接类的实例
Dialogue: 0,0:08:14.13,0:08:16.27,*Default,NTP,0000,0000,0000,,这意味着它本身就是一个链接列表
Dialogue: 0,0:08:16.50,0:08:16.90,*Default,NTP,0000,0000,0000,,所以这些
Dialogue: 0,0:08:16.90,0:08:18.93,*Default,NTP,0000,0000,0000,,是仅有的两种允许传递的信息。
Dialogue: 0,0:08:18.93,0:08:20.60,*Default,NTP,0000,0000,0000,,作为列表的其余部分
Dialogue: 0,0:08:22.50,0:08:23.77,*Default,NTP,0000,0000,0000,,然后我们将第一个
Dialogue: 0,0:08:23.77,0:08:25.80,*Default,NTP,0000,0000,0000,,元素和列表的其余部分作为
Dialogue: 0,0:08:26.20,0:08:28.30,*Default,NTP,0000,0000,0000,,属性
Dialogue: 0,0:08:29.40,0:08:32.87,*Default,NTP,0000,0000,0000,,是实例是 python 中的一个内置函数
Dialogue: 0,0:08:32.97,0:08:35.90,*Default,NTP,0000,0000,0000,,返回其余元素是否是链接
Dialogue: 0,0:08:36.07,0:08:38.13,*Default,NTP,0000,0000,0000,,当通过这两个参数时
Dialogue: 0,0:08:39.10,0:08:42.37,*Default,NTP,0000,0000,0000,,如果你向 python 求助他的实例
Dialogue: 0,0:08:42.37,0:08:43.17,*Default,NTP,0000,0000,0000,,它会告诉你
Dialogue: 0,0:08:43.17,0:08:46.70,*Default,NTP,0000,0000,0000,,它返回一个对象是类的实例
Dialogue: 0,0:08:47.37,0:08:49.77,*Default,NTP,0000,0000,0000,,或其子类的实例
Dialogue: 0,0:08:51.40,0:08:52.57,*Default,NTP,0000,0000,0000,,所以这与
Dialogue: 0,0:08:52.57,0:08:53.33,*Default,NTP,0000,0000,0000,,和仅仅获取
Dialogue: 0,0:08:53.33,0:08:55.40,*Default,NTP,0000,0000,0000,,类型并查看它是否与
Dialogue: 0,0:08:55.40,0:08:56.47,*Default,NTP,0000,0000,0000,,等于 link
Dialogue: 0,0:08:57.17,0:09:00.37,*Default,NTP,0000,0000,0000,,如果 rest
Dialogue: 0,0:09:00.93,0:09:06.37,*Default,NTP,0000,0000,0000,,是一个从 link 继承而来的类的实例时
Dialogue: 0,0:09:07.77,0:09:09.37,*Default,NTP,0000,0000,0000,,的类的实例，这也是一个好主意
Dialogue: 0,0:09:10.00,0:09:12.20,*Default,NTP,0000,0000,0000,,因为现在我们的系统是可扩展的
Dialogue: 0,0:09:12.20,0:09:15.13,*Default,NTP,0000,0000,0000,,如果我们想建立一种特殊的链接列表
Dialogue: 0,0:09:15.13,0:09:16.87,*Default,NTP,0000,0000,0000,,时
Dialogue: 0,0:09:17.13,0:09:19.33,*Default,NTP,0000,0000,0000,,我们仍然可以使用相同的构造函数
Dialogue: 0,0:09:19.67,0:09:22.90,*Default,NTP,0000,0000,0000,,而这个验证仍将按照我们的预期进行
Dialogue: 0,0:09:24.90,0:09:27.00,*Default,NTP,0000,0000,0000,,那么链接到底是什么呢？
Dialogue: 0,0:09:27.27,0:09:29.90,*Default,NTP,0000,0000,0000,,在这里，我们可以选择我们的实现方式
Dialogue: 0,0:09:30.20,0:09:33.30,*Default,NTP,0000,0000,0000,,我选择将其表示为空元组
Dialogue: 0,0:09:33.73,0:09:35.93,*Default,NTP,0000,0000,0000,,尽管我可以为空链表
Dialogue: 0,0:09:35.93,0:09:37.73,*Default,NTP,0000,0000,0000,,的特殊类
Dialogue: 0,0:09:38.17,0:09:41.50,*Default,NTP,0000,0000,0000,,但我选择了零长度序列
Dialogue: 0,0:09:41.73,0:09:44.53,*Default,NTP,0000,0000,0000,,因为它就是一个零长度序列
Dialogue: 0,0:09:46.73,0:09:48.60,*Default,NTP,0000,0000,0000,,好吧，让我们看看它是如何工作的
Dialogue: 0,0:09:50.73,0:09:52.67,*Default,NTP,0000,0000,0000,,我可以创建一个链表
Dialogue: 0,0:09:53.07,0:09:57.97,*Default,NTP,0000,0000,0000,,有 3 个，然后是 4 个，然后是 5 个
Dialogue: 0,0:10:01.57,0:10:06.30,*Default,NTP,0000,0000,0000,,如果我调用这个 s，我就可以开始检查它的属性了
Dialogue: 0,0:10:06.53,0:10:08.10,*Default,NTP,0000,0000,0000,,s dot first 是 3
Dialogue: 0,0:10:08.13,0:10:10.57,*Default,NTP,0000,0000,0000,,s dot rest 是 four five
Dialogue: 0,0:10:10.77,0:10:14.57,*Default,NTP,0000,0000,0000,,也就是说，如果我想获取元素 four
Dialogue: 0,0:10:14.70,0:10:18.50,*Default,NTP,0000,0000,0000,,我需要写的是 s dot rest first
Dialogue: 0,0:10:18.53,0:10:21.13,*Default,NTP,0000,0000,0000,,列表其余部分的第一个元素
Dialogue: 0,0:10:21.67,0:10:23.67,*Default,NTP,0000,0000,0000,,我可以通过
Dialogue: 0,0:10:23.67,0:10:26.57,*Default,NTP,0000,0000,0000,,列表其余部分的其余部分的
Dialogue: 0,0:10:26.57,0:10:29.07,*Default,NTP,0000,0000,0000,,的第一个元素是五
Dialogue: 0,0:10:32.37,0:10:34.97,*Default,NTP,0000,0000,0000,,最后，我可以问
Dialogue: 0,0:10:34.97,0:10:37.53,*Default,NTP,0000,0000,0000,,的其余部分
Dialogue: 0,0:10:37.67,0:10:38.87,*Default,NTP,0000,0000,0000,,是否链接
Dialogue: 0,0:10:39.50,0:10:42.70,*Default,NTP,0000,0000,0000,,应该是空的，因为那里什么都没有
Dialogue: 0,0:10:43.93,0:10:44.87,*Default,NTP,0000,0000,0000,,这些就是
Dialogue: 0,0:10:44.87,0:10:47.00,*Default,NTP,0000,0000,0000,,操作链表的方法
Dialogue: 0,0:10:48.67,0:10:49.80,*Default,NTP,0000,0000,0000,,当然
Dialogue: 0,0:10:49.80,0:10:52.73,*Default,NTP,0000,0000,0000,,当然也可以更改列表中的值
Dialogue: 0,0:10:52.87,0:10:56.70,*Default,NTP,0000,0000,0000,,我可以将 s 设为 1-7
Dialogue: 0,0:10:58.70,0:11:01.60,*Default,NTP,0000,0000,0000,,然后，如果我查看 s 的值
Dialogue: 0,0:11:01.80,0:11:03.40,*Default,NTP,0000,0000,0000,,我发现它是 3
Dialogue: 0,0:11:03.40,0:11:06.30,*Default,NTP,0000,0000,0000,,后面是 7，后面是 5
Dialogue: 0,0:11:06.93,0:11:07.87,*Default,NTP,0000,0000,0000,,然而
Dialogue: 0,0:11:09.10,0:11:09.90,*Default,NTP,0000,0000,0000,,有时
Dialogue: 0,0:11:09.90,0:11:12.17,*Default,NTP,0000,0000,0000,,在不改变数值的情况下
Dialogue: 0,0:11:12.17,0:11:13.60,*Default,NTP,0000,0000,0000,,值发生变化的情况下
Dialogue: 0,0:11:13.60,0:11:15.53,*Default,NTP,0000,0000,0000,,这就是它们的特殊用途
Dialogue: 0,0:11:15.87,0:11:18.40,*Default,NTP,0000,0000,0000,,因此，你可以创建一个与另一个列表相似的列表
Dialogue: 0,0:11:18.53,0:11:20.10,*Default,NTP,0000,0000,0000,,只需在
Dialogue: 0,0:11:20.53,0:11:22.30,*Default,NTP,0000,0000,0000,,一个不同的值
Dialogue: 0,0:11:22.47,0:11:25.37,*Default,NTP,0000,0000,0000,,因此，如果我想创建一个以
Dialogue: 0,0:11:25.80,0:11:28.67,*Default,NTP,0000,0000,0000,,8，然后是 7 和 5
Dialogue: 0,0:11:28.67,0:11:30.20,*Default,NTP,0000,0000,0000,,我只需编写
Dialogue: 0,0:11:30.77,0:11:33.47,*Default,NTP,0000,0000,0000,,链接八，然后是列表的其余部分
Dialogue: 0,0:11:33.80,0:11:35.57,*Default,NTP,0000,0000,0000,,这样写会创建一个新的列表
Dialogue: 0,0:11:35.57,0:11:37.20,*Default,NTP,0000,0000,0000,,但不会改变旧列表
Dialogue: 0,0:11:39.40,0:11:43.17,*Default,NTP,0000,0000,0000,,递归在链表处理中非常常见
Dialogue: 0,0:11:43.20,0:11:45.17,*Default,NTP,0000,0000,0000,,当构建一个新的链表
Dialogue: 0,0:11:45.17,0:11:47.20,*Default,NTP,0000,0000,0000,,或使用现有的链接表
Dialogue: 0,0:11:47.20,0:11:48.80,*Default,NTP,0000,0000,0000,,并对其进行处理时
Dialogue: 0,0:11:49.10,0:11:50.67,*Default,NTP,0000,0000,0000,,我们来看几个例子
Dialogue: 0,0:11:51.70,0:11:53.10,*Default,NTP,0000,0000,0000,,内置范围
Dialogue: 0,0:11:53.27,0:11:54.77,*Default,NTP,0000,0000,0000,,内置的 map 函数
Dialogue: 0,0:11:54.77,0:11:57.20,*Default,NTP,0000,0000,0000,,和 python 内置的过滤器函数
Dialogue: 0,0:11:57.47,0:11:59.07,*Default,NTP,0000,0000,0000,,但它们不能对链接
Dialogue: 0,0:11:59.07,0:12:01.17,*Default,NTP,0000,0000,0000,,因为这些都是用户定义的
Dialogue: 0,0:12:02.00,0:12:04.17,*Default,NTP,0000,0000,0000,,因此，如果我们想要同样的功能
Dialogue: 0,0:12:04.20,0:12:07.00,*Default,NTP,0000,0000,0000,,我们就必须实现自己的范围概念
Dialogue: 0,0:12:07.00,0:12:08.73,*Default,NTP,0000,0000,0000,,以及 map 和 filter
Dialogue: 0,0:12:09.67,0:12:11.50,*Default,NTP,0000,0000,0000,,让我们回忆一下这些函数的作用
Dialogue: 0,0:12:11.97,0:12:14.97,*Default,NTP,0000,0000,0000,,如果我有两个函数，比如 square
Dialogue: 0,0:12:15.00,0:12:16.97,*Default,NTP,0000,0000,0000,,这样的函数
Dialogue: 0,0:12:17.13,0:12:18.97,*Default,NTP,0000,0000,0000,,an奇数，接收一个 x
Dialogue: 0,0:12:18.97,0:12:21.10,*Default,NTP,0000,0000,0000,,并返回它是否是奇数
Dialogue: 0,0:12:21.93,0:12:23.53,*Default,NTP,0000,0000,0000,,例如
Dialogue: 0,0:12:23.87,0:12:26.10,*Default,NTP,0000,0000,0000,,写出下面的表达式
Dialogue: 0,0:12:26.30,0:12:28.93,*Default,NTP,0000,0000,0000,,使用内置的映射和范围过滤器
Dialogue: 0,0:12:29.70,0:12:32.17,*Default,NTP,0000,0000,0000,,获取数字一、二、三、四和五
Dialogue: 0,0:12:32.40,0:12:34.27,*Default,NTP,0000,0000,0000,,只过滤奇数
Dialogue: 0,0:12:34.27,0:12:36.17,*Default,NTP,0000,0000,0000,,所以现在我有了一三五
Dialogue: 0,0:12:36.37,0:12:39.70,*Default,NTP,0000,0000,0000,,然后在这些数字上映射平方函数
Dialogue: 0,0:12:39.87,0:12:41.47,*Default,NTP,0000,0000,0000,,所以 1 的平方是 1
Dialogue: 0,0:12:41.47,0:12:44.80,*Default,NTP,0000,0000,0000,,三的平方是九，五的平方是 25
Dialogue: 0,0:12:45.53,0:12:48.13,*Default,NTP,0000,0000,0000,,这些结果将放入一个列表
Dialogue: 0,0:12:49.13,0:12:52.27,*Default,NTP,0000,0000,0000,,同样的事情也可以用链接列表来做
Dialogue: 0,0:12:52.27,0:12:54.67,*Default,NTP,0000,0000,0000,,使用我们刚刚定义的类
Dialogue: 0,0:12:55.17,0:12:57.27,*Default,NTP,0000,0000,0000,,但语法略有不同
Dialogue: 0,0:12:57.73,0:13:00.90,*Default,NTP,0000,0000,0000,,我们必须使用映射链接函数
Dialogue: 0,0:13:00.90,0:13:02.60,*Default,NTP,0000,0000,0000,,稍后将实现
Dialogue: 0,0:13:03.27,0:13:04.60,*Default,NTP,0000,0000,0000,,该函数将把
Dialogue: 0,0:13:04.60,0:13:06.37,*Default,NTP,0000,0000,0000,,的所有元素。
Dialogue: 0,0:13:06.37,0:13:08.90,*Default,NTP,0000,0000,0000,,过滤链表的结果
Dialogue: 0,0:13:09.07,0:13:10.67,*Default,NTP,0000,0000,0000,,使用奇数函数
Dialogue: 0,0:13:10.70,0:13:12.17,*Default,NTP,0000,0000,0000,,的结果。
Dialogue: 0,0:13:12.20,0:13:15.90,*Default,NTP,0000,0000,0000,,代表范围 1 2 3 4 5 的链表
Dialogue: 0,0:13:16.53,0:13:18.77,*Default,NTP,0000,0000,0000,,过滤掉 2 和 4，只剩下 1
Dialogue: 0,0:13:18.77,0:13:19.50,*Default,NTP,0000,0000,0000,,3 和 5
Dialogue: 0,0:13:19.50,0:13:20.53,*Default,NTP,0000,0000,0000,,奇数
Dialogue: 0,0:13:20.57,0:13:23.97,*Default,NTP,0000,0000,0000,,将所有这些相加，得到一个包含 1 的链表
Dialogue: 0,0:13:23.97,0:13:25.50,*Default,NTP,0000,0000,0000,,九和二十五
Dialogue: 0,0:13:26.40,0:13:28.93,*Default,NTP,0000,0000,0000,,因此，让我们执行一个范围链接
Dialogue: 0,0:13:28.97,0:13:32.13,*Default,NTP,0000,0000,0000,,，它有一个起始整数和一个终止整数
Dialogue: 0,0:13:32.13,0:13:34.67,*Default,NTP,0000,0000,0000,,并返回一个包含连续整数的链接
Dialogue: 0,0:13:34.67,0:13:35.50,*Default,NTP,0000,0000,0000,,从开始
Dialogue: 0,0:13:35.57,0:13:37.67,*Default,NTP,0000,0000,0000,,到结束的连续整数
Dialogue: 0,0:13:37.77,0:13:39.17,*Default,NTP,0000,0000,0000,,不包括结束的整数
Dialogue: 0,0:13:39.27,0:13:41.93,*Default,NTP,0000,0000,0000,,因此，从 3 到 6 的范围链接将是 3
Dialogue: 0,0:13:41.93,0:13:43.13,*Default,NTP,0000,0000,0000,,四和五
Dialogue: 0,0:13:44.13,0:13:46.10,*Default,NTP,0000,0000,0000,,还将写入 map link
Dialogue: 0,0:13:46.20,0:13:48.27,*Default,NTP,0000,0000,0000,,会返回一个新的链接列表
Dialogue: 0,0:13:48.30,0:13:50.47,*Default,NTP,0000,0000,0000,,中的每个
Dialogue: 0,0:13:50.47,0:13:53.13,*Default,NTP,0000,0000,0000,,x 的新链表。
Dialogue: 0,0:13:53.50,0:13:57.00,*Default,NTP,0000,0000,0000,,因此，如果我们将 3 到 6 范围内的所有数据平方
Dialogue: 0,0:13:57.17,0:13:58.17,*Default,NTP,0000,0000,0000,,就会得到 3 的平方
Dialogue: 0,0:13:58.17,0:13:59.77,*Default,NTP,0000,0000,0000,,四平方和五平方
Dialogue: 0,0:14:00.17,0:14:01.90,*Default,NTP,0000,0000,0000,,还将写入过滤链接
Dialogue: 0,0:14:02.17,0:14:04.20,*Default,NTP,0000,0000,0000,,会返回一个链表，其中只包含
Dialogue: 0,0:14:04.20,0:14:05.53,*Default,NTP,0000,0000,0000,,只包含
Dialogue: 0,0:14:05.53,0:14:08.10,*Default,NTP,0000,0000,0000,,的元素。
Dialogue: 0,0:14:08.20,0:14:11.40,*Default,NTP,0000,0000,0000,,的元素返回真值
Dialogue: 0,0:14:12.30,0:14:15.17,*Default,NTP,0000,0000,0000,,因此，如果我们只过滤这个范围内的奇数元素
Dialogue: 0,0:14:15.17,0:14:16.50,*Default,NTP,0000,0000,0000,,就会得到 3 和 5
Dialogue: 0,0:14:16.50,0:14:17.73,*Default,NTP,0000,0000,0000,,去掉四个
Dialogue: 0,0:14:18.57,0:14:19.10,*Default,NTP,0000,0000,0000,,实际上
Dialogue: 0,0:14:19.10,0:14:21.50,*Default,NTP,0000,0000,0000,,所有这些都将是递归函数
Dialogue: 0,0:14:22.10,0:14:23.73,*Default,NTP,0000,0000,0000,,这是我们的链接类
Dialogue: 0,0:14:23.90,0:14:25.37,*Default,NTP,0000,0000,0000,,这里是平方和奇数
Dialogue: 0,0:14:25.80,0:14:27.53,*Default,NTP,0000,0000,0000,,我们如何建立一个范围
Dialogue: 0,0:14:28.57,0:14:30.27,*Default,NTP,0000,0000,0000,,如果是这样
Dialogue: 0,0:14:30.27,0:14:33.00,*Default,NTP,0000,0000,0000,,开始大于等于结束
Dialogue: 0,0:14:33.10,0:14:35.60,*Default,NTP,0000,0000,0000,,那么在这个范围内什么都没有
Dialogue: 0,0:14:35.93,0:14:37.53,*Default,NTP,0000,0000,0000,,我们返回 link
Dialogue: 0,0:14:37.90,0:14:41.00,*Default,NTP,0000,0000,0000,,空，表示链接列表为空
Dialogue: 0,0:14:41.37,0:14:44.57,*Default,NTP,0000,0000,0000,,否则，范围内至少有一个元素
Dialogue: 0,0:14:44.60,0:14:46.80,*Default,NTP,0000,0000,0000,,那就是起始元素
Dialogue: 0,0:14:46.93,0:14:48.53,*Default,NTP,0000,0000,0000,,然后是其他一些元素
Dialogue: 0,0:14:48.93,0:14:53.10,*Default,NTP,0000,0000,0000,,返回以 start 为第一个元素的链接
Dialogue: 0,0:14:53.27,0:14:55.60,*Default,NTP,0000,0000,0000,,以及范围的其余部分
Dialogue: 0,0:14:55.73,0:14:59.87,*Default,NTP,0000,0000,0000,,而这个范围是从开始元素加一开始
Dialogue: 0,0:14:59.90,0:15:01.33,*Default,NTP,0000,0000,0000,,到终点的范围
Dialogue: 0,0:15:02.47,0:15:04.97,*Default,NTP,0000,0000,0000,,如何将一个函数映射到另一个函数上？
Dialogue: 0,0:15:04.97,0:15:06.67,*Default,NTP,0000,0000,0000,,中的所有元素
Dialogue: 0,0:15:06.90,0:15:09.00,*Default,NTP,0000,0000,0000,,在每个元素上调用 f
Dialogue: 0,0:15:09.07,0:15:11.37,*Default,NTP,0000,0000,0000,,并建立一个结果链表
Dialogue: 0,0:15:12.07,0:15:15.10,*Default,NTP,0000,0000,0000,,如果 s 的链表是空的
Dialogue: 0,0:15:15.13,0:15:16.73,*Default,NTP,0000,0000,0000,,那就没什么可做的了
Dialogue: 0,0:15:16.77,0:15:19.47,*Default,NTP,0000,0000,0000,,我们可以返回 s 或返回链表为空
Dialogue: 0,0:15:19.53,0:15:20.57,*Default,NTP,0000,0000,0000,,因为这只是两个
Dialogue: 0,0:15:20.57,0:15:21.93,*Default,NTP,0000,0000,0000,,表达式
Dialogue: 0,0:15:21.93,0:15:23.70,*Default,NTP,0000,0000,0000,,写哪一个并不重要
Dialogue: 0,0:15:24.53,0:15:26.90,*Default,NTP,0000,0000,0000,,否则你就会知道至少有一个元素
Dialogue: 0,0:15:26.90,0:15:28.47,*Default,NTP,0000,0000,0000,,所以我们调用 f
Dialogue: 0,0:15:28.67,0:15:30.77,*Default,NTP,0000,0000,0000,,我们将返回一个新的链表
Dialogue: 0,0:15:30.87,0:15:33.87,*Default,NTP,0000,0000,0000,,的第一个元素就是在 s 的第一个元素上调用 f
Dialogue: 0,0:15:33.97,0:15:35.73,*Default,NTP,0000,0000,0000,,的第一个元素
Dialogue: 0,0:15:35.90,0:15:39.07,*Default,NTP,0000,0000,0000,,然后我们需要在其余的元素上调用 f
Dialogue: 0,0:15:39.30,0:15:42.00,*Default,NTP,0000,0000,0000,,为此，我们将递归调用 map link
Dialogue: 0,0:15:42.13,0:15:44.07,*Default,NTP,0000,0000,0000,,调用同一个函数 f
Dialogue: 0,0:15:44.27,0:15:46.33,*Default,NTP,0000,0000,0000,,对 s 中的所有元素进行调用
Dialogue: 0,0:15:47.13,0:15:48.93,*Default,NTP,0000,0000,0000,,那么过滤呢？
Dialogue: 0,0:15:49.20,0:15:52.77,*Default,NTP,0000,0000,0000,,如果 s 链接为空
Dialogue: 0,0:15:53.37,0:15:56.93,*Default,NTP,0000,0000,0000,,就没有元素需要过滤，所以会返回 s
Dialogue: 0,0:15:57.17,0:16:00.70,*Default,NTP,0000,0000,0000,,否则，我认为我们需要过滤
Dialogue: 0,0:16:00.70,0:16:02.10,*Default,NTP,0000,0000,0000,,中的所有元素
Dialogue: 0,0:16:02.20,0:16:04.07,*Default,NTP,0000,0000,0000,,的其余部分中的所有元素，所以我们要得到经过过滤的其余部分
Dialogue: 0,0:16:04.53,0:16:07.13,*Default,NTP,0000,0000,0000,,是调用 filter link
Dialogue: 0,0:16:07.57,0:16:10.67,*Default,NTP,0000,0000,0000,,的结果。
Dialogue: 0,0:16:11.40,0:16:13.20,*Default,NTP,0000,0000,0000,,但现在我们必须做出决定
Dialogue: 0,0:16:13.60,0:16:18.40,*Default,NTP,0000,0000,0000,,结果中是否包含了 s 的第一点？
Dialogue: 0,0:16:18.60,0:16:20.53,*Default,NTP,0000,0000,0000,,这取决于你得到的结果
Dialogue: 0,0:16:20.67,0:16:23.47,*Default,NTP,0000,0000,0000,,当你在 s 点第一位上调用 f 时
Dialogue: 0,0:16:24.13,0:16:25.80,*Default,NTP,0000,0000,0000,,如果是真值
Dialogue: 0,0:16:25.80,0:16:28.87,*Default,NTP,0000,0000,0000,,那么我们就需要把 s dot first 放在结果中
Dialogue: 0,0:16:29.20,0:16:30.70,*Default,NTP,0000,0000,0000,,那么其他内容呢？
Dialogue: 0,0:16:30.80,0:16:31.10,*Default,NTP,0000,0000,0000,,而
Dialogue: 0,0:16:31.10,0:16:34.00,*Default,NTP,0000,0000,0000,,这是过滤列表中其他内容的结果
Dialogue: 0,0:16:35.17,0:16:38.13,*Default,NTP,0000,0000,0000,,否则，如果这是一个假值
Dialogue: 0,0:16:38.20,0:16:41.73,*Default,NTP,0000,0000,0000,,那么结果中就不应该有 s dot first。
Dialogue: 0,0:16:41.73,0:16:44.53,*Default,NTP,0000,0000,0000,,所以我们可以只返回过滤后的结果
Dialogue: 0,0:16:45.40,0:16:48.30,*Default,NTP,0000,0000,0000,,让我们检查一下我们的 doctest 是否有效
Dialogue: 0,0:16:48.60,0:16:51.30,*Default,NTP,0000,0000,0000,,是的，所以应该是这样的
Dialogue: 0,0:16:51.60,0:16:54.57,*Default,NTP,0000,0000,0000,,如果我从
Dialogue: 0,0:16:54.77,0:16:58.80,*Default,NTP,0000,0000,0000,,从一到六，所以是一二三四五
Dialogue: 0,0:16:59.13,0:17:01.90,*Default,NTP,0000,0000,0000,,使用奇数进行过滤
Dialogue: 0,0:17:02.57,0:17:06.07,*Default,NTP,0000,0000,0000,,在结果上映射平方函数
Dialogue: 0,0:17:06.17,0:17:09.73,*Default,NTP,0000,0000,0000,,得到的结果就是 1 9 16
Dialogue: 0,0:17:09.93,0:17:10.90,*Default,NTP,0000,0000,0000,,就是这样
Dialogue: 0,0:17:12.40,0:17:14.90,*Default,NTP,0000,0000,0000,,既然链表是几种递归结构
Dialogue: 0,0:17:15.00,0:17:18.13,*Default,NTP,0000,0000,0000,,处理它们的自然方法就是递归
Dialogue: 0,0:17:18.13,0:17:20.50,*Default,NTP,0000,0000,0000,,就像我们在这些示例中看到的那样
Dialogue: 0,0:17:22.40,0:17:24.90,*Default,NTP,0000,0000,0000,,链接表实例是一个对象
Dialogue: 0,0:17:25.47,0:17:28.73,*Default,NTP,0000,0000,0000,,而用户定义的类的所有实例都可以
Dialogue: 0,0:17:28.77,0:17:30.57,*Default,NTP,0000,0000,0000,,改变或突变
Dialogue: 0,0:17:31.00,0:17:32.53,*Default,NTP,0000,0000,0000,,让我们看看
Dialogue: 0,0:17:32.53,0:17:34.80,*Default,NTP,0000,0000,0000,,当你开始改变链接实例的属性时
Dialogue: 0,0:17:34.80,0:17:36.20,*Default,NTP,0000,0000,0000,,会发生什么情况
Dialogue: 0,0:17:37.77,0:17:39.27,*Default,NTP,0000,0000,0000,,无链接可以更改
Dialogue: 0,0:17:39.90,0:17:41.90,*Default,NTP,0000,0000,0000,,使用属性赋值语句
Dialogue: 0,0:17:41.90,0:17:42.57,*Default,NTP,0000,0000,0000,,您可以更改
Dialogue: 0,0:17:42.57,0:17:45.10,*Default,NTP,0000,0000,0000,,链接实例的第一属性和其余属性
Dialogue: 0,0:17:46.17,0:17:48.87,*Default,NTP,0000,0000,0000,,事实上，这样做的一个有趣结果是
Dialogue: 0,0:17:48.93,0:17:51.50,*Default,NTP,0000,0000,0000,,就是链接列表的其余部分可以包含链接
Dialogue: 0,0:17:51.50,0:17:53.17,*Default,NTP,0000,0000,0000,,列表作为子列表
Dialogue: 0,0:17:54.07,0:17:55.77,*Default,NTP,0000,0000,0000,,因此，假设我从一个链接列表开始
Dialogue: 0,0:17:55.77,0:17:56.70,*Default,NTP,0000,0000,0000,,有三个元素
Dialogue: 0,0:17:56.70,0:17:57.87,*Default,NTP,0000,0000,0000,,一、二、三
Dialogue: 0,0:17:58.90,0:18:01.67,*Default,NTP,0000,0000,0000,,下面是一个简图
Dialogue: 0,0:18:02.37,0:18:05.00,*Default,NTP,0000,0000,0000,,实际环境图更为复杂
Dialogue: 0,0:18:05.27,0:18:07.97,*Default,NTP,0000,0000,0000,,但链接列表的本质是
Dialogue: 0,0:18:08.37,0:18:12.00,*Default,NTP,0000,0000,0000,,就是它只有两个属性，第一个和其余的
Dialogue: 0,0:18:12.30,0:18:14.67,*Default,NTP,0000,0000,0000,,在本例中，第一个属性是数字
Dialogue: 0,0:18:14.90,0:18:17.93,*Default,NTP,0000,0000,0000,,其余的是另一个链接实例
Dialogue: 0,0:18:17.93,0:18:19.27,*Default,NTP,0000,0000,0000,,下面是第二个属性
Dialogue: 0,0:18:20.77,0:18:23.20,*Default,NTP,0000,0000,0000,,如果我指定第一个属性 estad 等于 5
Dialogue: 0,0:18:23.37,0:18:27.10,*Default,NTP,0000,0000,0000,,剩下的就是 5 2 3
Dialogue: 0,0:18:28.17,0:18:29.70,*Default,NTP,0000,0000,0000,,但这就变得非常有趣了
Dialogue: 0,0:18:29.70,0:18:31.73,*Default,NTP,0000,0000,0000,,当你想出另一个名字
Dialogue: 0,0:18:31.87,0:18:33.17,*Default,NTP,0000,0000,0000,,s tad rest
Dialogue: 0,0:18:33.17,0:18:35.90,*Default,NTP,0000,0000,0000,,比如 t，这就是链接列表
Dialogue: 0,0:18:36.07,0:18:41.47,*Default,NTP,0000,0000,0000,,2 3，然后我们重新分配链接实例的 rest 属性
Dialogue: 0,0:18:41.53,0:18:43.73,*Default,NTP,0000,0000,0000,,属性
Dialogue: 0,0:18:44.80,0:18:47.00,*Default,NTP,0000,0000,0000,,在本例中，我们将其赋值给 s
Dialogue: 0,0:18:47.40,0:18:50.00,*Default,NTP,0000,0000,0000,,那么 s first first 就是 5
Dialogue: 0,0:18:50.30,0:18:54.17,*Default,NTP,0000,0000,0000,,那么 s rest rest rest rest first 是什么呢？
Dialogue: 0,0:18:54.50,0:18:55.20,*Default,NTP,0000,0000,0000,,我们再想想
Dialogue: 0,0:18:55.20,0:18:57.27,*Default,NTP,0000,0000,0000,,看你能不能想出来
Dialogue: 0,0:18:59.60,0:19:01.30,*Default,NTP,0000,0000,0000,,这将是第二个
Dialogue: 0,0:19:01.77,0:19:03.57,*Default,NTP,0000,0000,0000,,一个合理的反应是
Dialogue: 0,0:19:03.70,0:19:05.93,*Default,NTP,0000,0000,0000,,我们怎么会有这么多点休止符
Dialogue: 0,0:19:05.93,0:19:07.73,*Default,NTP,0000,0000,0000,,而我们的链表只有
Dialogue: 0,0:19:07.73,0:19:09.07,*Default,NTP,0000,0000,0000,,三个元素
Dialogue: 0,0:19:09.97,0:19:13.33,*Default,NTP,0000,0000,0000,,我们创建它的时候，它只有三个元素
Dialogue: 0,0:19:13.47,0:19:15.37,*Default,NTP,0000,0000,0000,,但现在它的结构不同了
Dialogue: 0,0:19:15.53,0:19:17.77,*Default,NTP,0000,0000,0000,,因为我们改变了 t 的点休止符
Dialogue: 0,0:19:17.93,0:19:19.97,*Default,NTP,0000,0000,0000,,而 t 是 s 的一部分
Dialogue: 0,0:19:20.40,0:19:22.77,*Default,NTP,0000,0000,0000,,我们创建的结构如下
Dialogue: 0,0:19:23.50,0:19:25.47,*Default,NTP,0000,0000,0000,,我们将 s 的第一点改为 5
Dialogue: 0,0:19:25.67,0:19:27.80,*Default,NTP,0000,0000,0000,,我们从未改变过 s 的余点
Dialogue: 0,0:19:28.20,0:19:30.30,*Default,NTP,0000,0000,0000,,我们给它起了个名字 t
Dialogue: 0,0:19:31.10,0:19:33.90,*Default,NTP,0000,0000,0000,,并将 t 点其余部分
Dialogue: 0,0:19:34.33,0:19:36.33,*Default,NTP,0000,0000,0000,,指代 s
Dialogue: 0,0:19:37.27,0:19:38.67,*Default,NTP,0000,0000,0000,,所以当你计算
Dialogue: 0,0:19:39.00,0:19:44.70,*Default,NTP,0000,0000,0000,,点休止符点休止符点休止符点休止符点休止符点休止符点休止符点休止符首先
Dialogue: 0,0:19:44.90,0:19:46.17,*Default,NTP,0000,0000,0000,,就会得到 No.2
Dialogue: 0,0:19:48.93,0:19:51.73,*Default,NTP,0000,0000,0000,,下面是一个链表突变的例子
Dialogue: 0,0:19:52.40,0:19:54.97,*Default,NTP,0000,0000,0000,,假设我们有一个有序列表
Dialogue: 0,0:19:55.20,0:19:57.53,*Default,NTP,0000,0000,0000,,没有重复元素
Dialogue: 0,0:19:57.90,0:19:59.57,*Default,NTP,0000,0000,0000,,我们想保持
Dialogue: 0,0:19:59.57,0:20:03.33,*Default,NTP,0000,0000,0000,,s 是一个没有重复元素的有序列表这一事实
Dialogue: 0,0:20:03.53,0:20:05.97,*Default,NTP,0000,0000,0000,,但写一个函数 add
Dialogue: 0,0:20:06.33,0:20:09.47,*Default,NTP,0000,0000,0000,,函数，将元素放入列表
Dialogue: 0,0:20:09.57,0:20:11.27,*Default,NTP,0000,0000,0000,,的适当位置
Dialogue: 0,0:20:11.27,0:20:12.57,*Default,NTP,0000,0000,0000,,以便所有元素都保持
Dialogue: 0,0:20:12.57,0:20:14.53,*Default,NTP,0000,0000,0000,,从少到多排序
Dialogue: 0,0:20:15.00,0:20:16.30,*Default,NTP,0000,0000,0000,,函数如下
Dialogue: 0,0:20:16.97,0:20:20.13,*Default,NTP,0000,0000,0000,,向列表 s 添加值 v
Dialogue: 0,0:20:20.33,0:20:23.97,*Default,NTP,0000,0000,0000,,修改 s 以确保它包含 v
Dialogue: 0,0:20:24.17,0:20:27.20,*Default,NTP,0000,0000,0000,,然后返回修改后的 s
Dialogue: 0,0:20:27.70,0:20:30.77,*Default,NTP,0000,0000,0000,,但如果 v 已经在 s 中
Dialogue: 0,0:20:30.77,0:20:32.50,*Default,NTP,0000,0000,0000,,那么我们就不修改
Dialogue: 0,0:20:32.50,0:20:35.10,*Default,NTP,0000,0000,0000,,这样就不会在列表中出现重复值
Dialogue: 0,0:20:35.70,0:20:38.77,*Default,NTP,0000,0000,0000,,但我们仍希望从 add 函数中返回 s
Dialogue: 0,0:20:39.20,0:20:41.10,*Default,NTP,0000,0000,0000,,现在是暂停视频的好时机
Dialogue: 0,0:20:41.17,0:20:42.67,*Default,NTP,0000,0000,0000,,并尝试编写这个函数
Dialogue: 0,0:20:42.87,0:20:47.10,*Default,NTP,0000,0000,0000,,我将用 321 来描述它是如何工作的
Dialogue: 0,0:20:47.20,0:20:49.50,*Default,NTP,0000,0000,0000,,将 0 加到 s 时
Dialogue: 0,0:20:49.77,0:20:51.27,*Default,NTP,0000,0000,0000,,时，我们要确保零
Dialogue: 0,0:20:51.27,0:20:53.37,*Default,NTP,0000,0000,0000,,是开头的元素
Dialogue: 0,0:20:53.53,0:20:55.57,*Default,NTP,0000,0000,0000,,之后的元素
Dialogue: 0,0:20:56.73,0:21:00.20,*Default,NTP,0000,0000,0000,,而不是重写列表中的所有值
Dialogue: 0,0:21:00.40,0:21:01.70,*Default,NTP,0000,0000,0000,,我们可以这样做
Dialogue: 0,0:21:01.80,0:21:04.57,*Default,NTP,0000,0000,0000,,只需创建一个新的链接实例
Dialogue: 0,0:21:04.57,0:21:06.53,*Default,NTP,0000,0000,0000,,其第一个元素为 1
Dialogue: 0,0:21:06.97,0:21:11.20,*Default,NTP,0000,0000,0000,,更改 s，使其第一个元素为 0
Dialogue: 0,0:21:11.47,0:21:13.00,*Default,NTP,0000,0000,0000,,并重新路由
Dialogue: 0,0:21:13.13,0:21:14.00,*Default,NTP,0000,0000,0000,,使
Dialogue: 0,0:21:14.00,0:21:18.73,*Default,NTP,0000,0000,0000,,的其余部分是链接实例，其其余部分是 3
Dialogue: 0,0:21:18.73,0:21:22.80,*Default,NTP,0000,0000,0000,,现在我们有一个链表
Dialogue: 0,0:21:22.80,0:21:25.53,*Default,NTP,0000,0000,0000,,代表序列 0 1 3 5
Dialogue: 0,0:21:25.53,0:21:27.53,*Default,NTP,0000,0000,0000,,而不仅仅是 1 3 5
Dialogue: 0,0:21:27.93,0:21:29.47,*Default,NTP,0000,0000,0000,,如果我们再加上 3
Dialogue: 0,0:21:29.90,0:21:30.67,*Default,NTP,0000,0000,0000,,我们应该
Dialogue: 0,0:21:30.67,0:21:34.60,*Default,NTP,0000,0000,0000,,查找 s，直到找到 3 所在的位置。
Dialogue: 0,0:21:34.60,0:21:37.50,*Default,NTP,0000,0000,0000,,既然我们发现 3 已经在那里了
Dialogue: 0,0:21:37.57,0:21:39.73,*Default,NTP,0000,0000,0000,,我们根本不用修改 s
Dialogue: 0,0:21:40.00,0:21:41.27,*Default,NTP,0000,0000,0000,,我们只是返回它
Dialogue: 0,0:21:41.80,0:21:43.87,*Default,NTP,0000,0000,0000,,如果我们加上 4
Dialogue: 0,0:21:44.50,0:21:46.57,*Default,NTP,0000,0000,0000,,我们沿着这里找
Dialogue: 0,0:21:46.70,0:21:49.10,*Default,NTP,0000,0000,0000,,直到我们找到四应该放在
Dialogue: 0,0:21:49.10,0:21:50.60,*Default,NTP,0000,0000,0000,,在三和五之间
Dialogue: 0,0:21:50.90,0:21:54.73,*Default,NTP,0000,0000,0000,,这意味着我们可以将 5 改为 4
Dialogue: 0,0:21:55.30,0:21:57.60,*Default,NTP,0000,0000,0000,,为 5 添加一个新的链接实例
Dialogue: 0,0:21:57.77,0:22:00.27,*Default,NTP,0000,0000,0000,,现在我们有了 0 1 3 4 5
Dialogue: 0,0:22:00.53,0:22:02.07,*Default,NTP,0000,0000,0000,,如果我们添加 6
Dialogue: 0,0:22:02.57,0:22:04.13,*Default,NTP,0000,0000,0000,,这实际上有点不同
Dialogue: 0,0:22:04.13,0:22:05.17,*Default,NTP,0000,0000,0000,,我们继续查找
Dialogue: 0,0:22:05.33,0:22:07.33,*Default,NTP,0000,0000,0000,,直到我们发现已经到了终点
Dialogue: 0,0:22:07.53,0:22:11.27,*Default,NTP,0000,0000,0000,,因此，rest 不再是空链接
Dialogue: 0,0:22:11.33,0:22:13.37,*Default,NTP,0000,0000,0000,,剩下的部分需要成为一个新的链接实例
Dialogue: 0,0:22:13.37,0:22:14.57,*Default,NTP,0000,0000,0000,,包含六个
Dialogue: 0,0:22:15.20,0:22:17.60,*Default,NTP,0000,0000,0000,,这就是我们将 v 加入 s 的方法
Dialogue: 0,0:22:18.57,0:22:19.77,*Default,NTP,0000,0000,0000,,试着实现它
Dialogue: 0,0:22:20.00,0:22:23.57,*Default,NTP,0000,0000,0000,,将 v 添加到 s 中，返回修改后的 s
Dialogue: 0,0:22:24.00,0:22:26.80,*Default,NTP,0000,0000,0000,,如果 v 已在 s 中，则不更改 s
Dialogue: 0,0:22:27.00,0:22:30.77,*Default,NTP,0000,0000,0000,,并确保 s 保持有序
Dialogue: 0,0:22:30.77,0:22:33.57,*Default,NTP,0000,0000,0000,,我们假设 s 在开始时是有序的
Dialogue: 0,0:22:33.70,0:22:35.27,*Default,NTP,0000,0000,0000,,我们必须将 v
Dialogue: 0,0:22:35.33,0:22:35.80,*Default,NTP,0000,0000,0000,,放入 s
Dialogue: 0,0:22:35.80,0:22:38.57,*Default,NTP,0000,0000,0000,,以便保持从少到多的顺序
Dialogue: 0,0:22:38.70,0:22:40.27,*Default,NTP,0000,0000,0000,,下面是一些例子
Dialogue: 0,0:22:40.37,0:22:44.97,*Default,NTP,0000,0000,0000,,如果 s 是 1 3 5，我们加上 0，那么在 0 1 3 5 处
Dialogue: 0,0:22:45.10,0:22:46.90,*Default,NTP,0000,0000,0000,,加上 3 不变
Dialogue: 0,0:22:46.90,0:22:47.67,*Default,NTP,0000,0000,0000,,我们加上 4
Dialogue: 0,0:22:47.67,0:22:49.73,*Default,NTP,0000,0000,0000,,4 出现在正确的位置上
Dialogue: 0,0:22:49.73,0:22:52.17,*Default,NTP,0000,0000,0000,,然后我们加上 6，最后它出现在末尾
Dialogue: 0,0:22:52.53,0:22:55.50,*Default,NTP,0000,0000,0000,,假设 s 并不是空的
Dialogue: 0,0:22:55.60,0:22:56.53,*Default,NTP,0000,0000,0000,,我们该怎么做
Dialogue: 0,0:22:56.60,0:22:58.77,*Default,NTP,0000,0000,0000,,断言 s 不为空
Dialogue: 0,0:22:59.37,0:23:02.20,*Default,NTP,0000,0000,0000,,然后，如果 s 点与 v 相比大于 v
Dialogue: 0,0:23:02.47,0:23:07.47,*Default,NTP,0000,0000,0000,,我们通过改变 s dot rest 中的 s dot first 来改变 s to
Dialogue: 0,0:23:08.10,0:23:12.50,*Default,NTP,0000,0000,0000,,如果 s dot versus 小于 v 且 s dot rest 为空
Dialogue: 0,0:23:12.77,0:23:15.30,*Default,NTP,0000,0000,0000,,那么我们必须在末尾添加一个值
Dialogue: 0,0:23:15.73,0:23:18.40,*Default,NTP,0000,0000,0000,,如果 s dot rest 小于 v，我们必须做一些事情
Dialogue: 0,0:23:18.53,0:23:20.40,*Default,NTP,0000,0000,0000,,最后我们返回 s
Dialogue: 0,0:23:20.87,0:23:23.00,*Default,NTP,0000,0000,0000,,为什么不暂停一下，试着填空呢？
Dialogue: 0,0:23:23.00,0:23:25.87,*Default,NTP,0000,0000,0000,,我们将在 321 中讨论这个问题
Dialogue: 0,0:23:26.20,0:23:28.60,*Default,NTP,0000,0000,0000,,如果 s 点第一位大于 v
Dialogue: 0,0:23:28.90,0:23:32.20,*Default,NTP,0000,0000,0000,,那么我们就把 v 放在 s 的第一个点上
Dialogue: 0,0:23:32.33,0:23:37.87,*Default,NTP,0000,0000,0000,,并将 s dot rest 改为包含旧的 s dot first
Dialogue: 0,0:23:37.90,0:23:40.13,*Default,NTP,0000,0000,0000,,和旧的 s 点其余部分
Dialogue: 0,0:23:40.27,0:23:42.27,*Default,NTP,0000,0000,0000,,这就是建立这个链接实例
Dialogue: 0,0:23:42.40,0:23:44.93,*Default,NTP,0000,0000,0000,,或建立此链接实例
Dialogue: 0,0:23:45.30,0:23:48.93,*Default,NTP,0000,0000,0000,,如果 esta first 小于 v 且其余为空
Dialogue: 0,0:23:49.17,0:23:52.73,*Default,NTP,0000,0000,0000,,那么我们需要将 s
Dialogue: 0,0:23:53.10,0:23:54.97,*Default,NTP,0000,0000,0000,,rest 设置为链接
Dialogue: 0,0:23:55.10,0:23:58.57,*Default,NTP,0000,0000,0000,,其中 v 是第一个元素，其余为空
Dialogue: 0,0:23:58.67,0:24:01.33,*Default,NTP,0000,0000,0000,,这是 link 的默认第二个参数
Dialogue: 0,0:24:01.87,0:24:02.67,*Default,NTP,0000,0000,0000,,否则
Dialogue: 0,0:24:02.87,0:24:05.37,*Default,NTP,0000,0000,0000,,我们将继续寻找放置
Dialogue: 0,0:24:05.37,0:24:08.60,*Default,NTP,0000,0000,0000,,v 的地方，这只是递归调用 add
Dialogue: 0,0:24:08.93,0:24:10.70,*Default,NTP,0000,0000,0000,,的递归调用，我们不需要返回
Dialogue: 0,0:24:11.00,0:24:13.30,*Default,NTP,0000,0000,0000,,因为我们会返回
Dialogue: 0,0:24:13.30,0:24:15.30,*Default,NTP,0000,0000,0000,,我们总是要返回 s
Dialogue: 0,0:24:15.40,0:24:16.60,*Default,NTP,0000,0000,0000,,这个调用
Dialogue: 0,0:24:16.60,0:24:18.87,*Default,NTP,0000,0000,0000,,的目的不是计算一个返回值
Dialogue: 0,0:24:18.93,0:24:23.30,*Default,NTP,0000,0000,0000,,而是对 s 的其余部分执行加法运算
Dialogue: 0,0:24:25.27,0:24:28.77,*Default,NTP,0000,0000,0000,,另一种递归计算数据结构
Dialogue: 0,0:24:29.07,0:24:30.33,*Default,NTP,0000,0000,0000,,是树
Dialogue: 0,0:24:30.77,0:24:34.40,*Default,NTP,0000,0000,0000,,我们已经在本课中讨论过树了
Dialogue: 0,0:24:34.60,0:24:35.47,*Default,NTP,0000,0000,0000,,但它们是如此重要
Dialogue: 0,0:24:35.53,0:24:38.20,*Default,NTP,0000,0000,0000,,树非常重要，我们应该再讲一遍
Dialogue: 0,0:24:38.70,0:24:41.77,*Default,NTP,0000,0000,0000,,树很像链表
Dialogue: 0,0:24:42.20,0:24:44.57,*Default,NTP,0000,0000,0000,,树有一个根标签
Dialogue: 0,0:24:44.57,0:24:47.50,*Default,NTP,0000,0000,0000,,和一个树分支列表
Dialogue: 0,0:24:47.73,0:24:50.67,*Default,NTP,0000,0000,0000,,链表有一个首元素
Dialogue: 0,0:24:50.67,0:24:52.60,*Default,NTP,0000,0000,0000,,和列表的其余部分
Dialogue: 0,0:24:53.10,0:24:54.47,*Default,NTP,0000,0000,0000,,所以主要区别
Dialogue: 0,0:24:54.57,0:24:58.13,*Default,NTP,0000,0000,0000,,树有多个树分支
Dialogue: 0,0:24:58.20,0:25:01.53,*Default,NTP,0000,0000,0000,,而一个链表只有一个链表
Dialogue: 0,0:25:01.53,0:25:03.70,*Default,NTP,0000,0000,0000,,作为列表的其余部分
Dialogue: 0,0:25:04.30,0:25:07.07,*Default,NTP,0000,0000,0000,,下面是我们以前讨论过的词汇
Dialogue: 0,0:25:07.30,0:25:08.57,*Default,NTP,0000,0000,0000,,但我们还是要再讲一遍
Dialogue: 0,0:25:09.33,0:25:12.30,*Default,NTP,0000,0000,0000,,有两种描述树的方法
Dialogue: 0,0:25:12.37,0:25:14.13,*Default,NTP,0000,0000,0000,,递归描述
Dialogue: 0,0:25:14.47,0:25:16.53,*Default,NTP,0000,0000,0000,,类比木头
Dialogue: 0,0:25:16.53,0:25:18.37,*Default,NTP,0000,0000,0000,,从地里长出来的树
Dialogue: 0,0:25:18.77,0:25:21.27,*Default,NTP,0000,0000,0000,,只不过它们是向下生长，而不是向上生长
Dialogue: 0,0:25:21.60,0:25:24.80,*Default,NTP,0000,0000,0000,,一棵树有一个根标签和一个分支列表
Dialogue: 0,0:25:24.80,0:25:26.47,*Default,NTP,0000,0000,0000,,这里的根标签是三个
Dialogue: 0,0:25:26.47,0:25:28.97,*Default,NTP,0000,0000,0000,,有一个树枝，还有一个树枝
Dialogue: 0,0:25:29.27,0:25:31.17,*Default,NTP,0000,0000,0000,,每个分支都是一棵树
Dialogue: 0,0:25:31.80,0:25:34.77,*Default,NTP,0000,0000,0000,,没有分支的树叫做树叶
Dialogue: 0,0:25:35.07,0:25:38.00,*Default,NTP,0000,0000,0000,,图中有五片叶子
Dialogue: 0,0:25:38.13,0:25:40.17,*Default,NTP,0000,0000,0000,,树叶也有标签
Dialogue: 0,0:25:40.33,0:25:42.10,*Default,NTP,0000,0000,0000,,只是没有分支
Dialogue: 0,0:25:42.73,0:25:44.67,*Default,NTP,0000,0000,0000,,一棵树从树根开始
Dialogue: 0,0:25:44.80,0:25:46.93,*Default,NTP,0000,0000,0000,,这就是整棵树的根
Dialogue: 0,0:25:47.33,0:25:49.70,*Default,NTP,0000,0000,0000,,左侧分支的根
Dialogue: 0,0:25:50.10,0:25:53.50,*Default,NTP,0000,0000,0000,,可以有多个分支，也可以只有一个或零个分支
Dialogue: 0,0:25:53.77,0:25:56.40,*Default,NTP,0000,0000,0000,,每个分支都是另一棵树
Dialogue: 0,0:25:56.53,0:25:59.70,*Default,NTP,0000,0000,0000,,也就是说，每一个分支都有另一条路径
Dialogue: 0,0:26:00.10,0:26:03.47,*Default,NTP,0000,0000,0000,,描述一棵树中所有不同的树
Dialogue: 0,0:26:03.47,0:26:06.90,*Default,NTP,0000,0000,0000,,通常涉及节点一词
Dialogue: 0,0:26:07.07,0:26:11.77,*Default,NTP,0000,0000,0000,,节点是树中的一个位置或地点
Dialogue: 0,0:26:12.33,0:26:14.70,*Default,NTP,0000,0000,0000,,它本身总是另一棵树
Dialogue: 0,0:26:14.73,0:26:16.77,*Default,NTP,0000,0000,0000,,但在使用节点一词时
Dialogue: 0,0:26:16.87,0:26:20.10,*Default,NTP,0000,0000,0000,,考虑子树就没那么有趣了
Dialogue: 0,0:26:20.10,0:26:21.50,*Default,NTP,0000,0000,0000,,而只是
Dialogue: 0,0:26:21.57,0:26:25.00,*Default,NTP,0000,0000,0000,,它们与其他节点的相对位置
Dialogue: 0,0:26:25.73,0:26:27.50,*Default,NTP,0000,0000,0000,,每个节点都有一个标签
Dialogue: 0,0:26:27.90,0:26:28.70,*Default,NTP,0000,0000,0000,,而每个
Dialogue: 0,0:26:28.70,0:26:33.47,*Default,NTP,0000,0000,0000,,节点也有相对于其他节点的配置
Dialogue: 0,0:26:33.80,0:26:35.80,*Default,NTP,0000,0000,0000,,三是二的父节点
Dialogue: 0,0:26:36.00,0:26:38.07,*Default,NTP,0000,0000,0000,,二是三的子节点
Dialogue: 0,0:26:38.93,0:26:40.93,*Default,NTP,0000,0000,0000,,最上面的节点是根节点
Dialogue: 0,0:26:41.30,0:26:43.33,*Default,NTP,0000,0000,0000,,就像我刚才做的那样
Dialogue: 0,0:26:43.33,0:26:46.90,*Default,NTP,0000,0000,0000,,人们经常使用标签来指代位置
Dialogue: 0,0:26:47.33,0:26:48.57,*Default,NTP,0000,0000,0000,,而不是说
Dialogue: 0,0:26:48.93,0:26:50.67,*Default,NTP,0000,0000,0000,,标签为
Dialogue: 0,0:26:50.67,0:26:54.37,*Default,NTP,0000,0000,0000,,是标签为三的节点的子节点
Dialogue: 0,0:26:54.53,0:26:57.97,*Default,NTP,0000,0000,0000,,人们通常会随口说
Dialogue: 0,0:26:58.30,0:27:00.10,*Default,NTP,0000,0000,0000,,2 是 3 的子节点
Dialogue: 0,0:27:00.50,0:27:02.47,*Default,NTP,0000,0000,0000,,但事实上，节点才有
Dialogue: 0,0:27:02.47,0:27:04.10,*Default,NTP,0000,0000,0000,,这种家族关系
Dialogue: 0,0:27:04.30,0:27:06.57,*Default,NTP,0000,0000,0000,,它们的标签只是数字
Dialogue: 0,0:27:07.13,0:27:10.50,*Default,NTP,0000,0000,0000,,路径是一个节点序列
Dialogue: 0,0:27:10.50,0:27:12.53,*Default,NTP,0000,0000,0000,,其中每个元素要么是前一个注释的父节点
Dialogue: 0,0:27:12.53,0:27:14.73,*Default,NTP,0000,0000,0000,,或前一个节点的子节点
Dialogue: 0,0:27:14.80,0:27:17.40,*Default,NTP,0000,0000,0000,,因此它们在树形图中是相连的
Dialogue: 0,0:27:17.97,0:27:19.80,*Default,NTP,0000,0000,0000,,最常见的路径有
Dialogue: 0,0:27:19.80,0:27:21.87,*Default,NTP,0000,0000,0000,,从路径到叶子的路径
Dialogue: 0,0:27:22.30,0:27:25.27,*Default,NTP,0000,0000,0000,,但也可以有其他类型的路径
Dialogue: 0,0:27:25.90,0:27:28.93,*Default,NTP,0000,0000,0000,,我们可以使用数据抽象来处理树图
Dialogue: 0,0:27:29.17,0:27:32.33,*Default,NTP,0000,0000,0000,,但我们也可以使用 Pythons 对象系统
Dialogue: 0,0:27:33.37,0:27:36.27,*Default,NTP,0000,0000,0000,,树有一个标签和一个分支列表
Dialogue: 0,0:27:36.30,0:27:38.70,*Default,NTP,0000,0000,0000,,每个分支也是一棵树
Dialogue: 0,0:27:39.50,0:27:43.50,*Default,NTP,0000,0000,0000,,我们可以通过定义一个树类来说明这一点
Dialogue: 0,0:27:43.53,0:27:46.13,*Default,NTP,0000,0000,0000,,的构造函数来说明这一点。
Dialogue: 0,0:27:46.37,0:27:50.60,*Default,NTP,0000,0000,0000,,和一个默认为空的分支列表
Dialogue: 0,0:27:51.37,0:27:52.57,*Default,NTP,0000,0000,0000,,我们设置标签
Dialogue: 0,0:27:53.07,0:27:56.80,*Default,NTP,0000,0000,0000,,检查每个分支是否都是一棵树
Dialogue: 0,0:27:56.90,0:27:59.50,*Default,NTP,0000,0000,0000,,然后分配自顶分支
Dialogue: 0,0:27:59.90,0:28:02.67,*Default,NTP,0000,0000,0000,,在此，我们创建一个分支列表
Dialogue: 0,0:28:02.73,0:28:04.87,*Default,NTP,0000,0000,0000,,以保留一份
Dialogue: 0,0:28:05.07,0:28:07.80,*Default,NTP,0000,0000,0000,,并将分支转换为列表
Dialogue: 0,0:28:07.80,0:28:09.60,*Default,NTP,0000,0000,0000,,如果是其他东西
Dialogue: 0,0:28:09.67,0:28:13.47,*Default,NTP,0000,0000,0000,,这里是使用数据抽象的定义
Dialogue: 0,0:28:14.47,0:28:18.40,*Default,NTP,0000,0000,0000,,非常相似，但有一些重要区别
Dialogue: 0,0:28:18.80,0:28:21.20,*Default,NTP,0000,0000,0000,,现在我们使用对象系统
Dialogue: 0,0:28:21.50,0:28:24.17,*Default,NTP,0000,0000,0000,,我们定义了如何构建一棵树
Dialogue: 0,0:28:24.57,0:28:27.47,*Default,NTP,0000,0000,0000,,但我们不必明确定义
Dialogue: 0,0:28:27.60,0:28:30.30,*Default,NTP,0000,0000,0000,,如何从构建的树中获取不同的属性
Dialogue: 0,0:28:30.47,0:28:32.20,*Default,NTP,0000,0000,0000,,的不同属性
Dialogue: 0,0:28:32.87,0:28:34.27,*Default,NTP,0000,0000,0000,,在数据抽象中
Dialogue: 0,0:28:34.27,0:28:37.67,*Default,NTP,0000,0000,0000,,我们写下了构造函数和选择器
Dialogue: 0,0:28:37.87,0:28:39.73,*Default,NTP,0000,0000,0000,,在这里，我们写下了构造函数
Dialogue: 0,0:28:39.73,0:28:42.17,*Default,NTP,0000,0000,0000,,而选择器是隐式的
Dialogue: 0,0:28:42.20,0:28:44.27,*Default,NTP,0000,0000,0000,,自点标签将给出标签
Dialogue: 0,0:28:44.27,0:28:46.53,*Default,NTP,0000,0000,0000,,和点分支将给出分支
Dialogue: 0,0:28:46.70,0:28:48.13,*Default,NTP,0000,0000,0000,,更重要的是
Dialogue: 0,0:28:48.50,0:28:50.17,*Default,NTP,0000,0000,0000,,在使用数据抽象时
Dialogue: 0,0:28:50.17,0:28:52.13,*Default,NTP,0000,0000,0000,,我们必须发明一种方法
Dialogue: 0,0:28:52.13,0:28:54.77,*Default,NTP,0000,0000,0000,,将这些片段组合在一起
Dialogue: 0,0:28:54.77,0:28:56.53,*Default,NTP,0000,0000,0000,,标签和分支
Dialogue: 0,0:28:56.77,0:28:57.60,*Default,NTP,0000,0000,0000,,在这种情况下
Dialogue: 0,0:28:57.60,0:29:00.47,*Default,NTP,0000,0000,0000,,我们决定把它们放在一个长列表中
Dialogue: 0,0:29:00.57,0:29:02.50,*Default,NTP,0000,0000,0000,,但我们也可以用其他方法
Dialogue: 0,0:29:02.67,0:29:05.60,*Default,NTP,0000,0000,0000,,把它们放在一对中 把它们放在字典中
Dialogue: 0,0:29:05.93,0:29:07.17,*Default,NTP,0000,0000,0000,,不管我们做了什么
Dialogue: 0,0:29:07.27,0:29:09.30,*Default,NTP,0000,0000,0000,,我们都必须想出一种方法
Dialogue: 0,0:29:09.40,0:29:11.80,*Default,NTP,0000,0000,0000,,将这些片段提取出来
Dialogue: 0,0:29:12.07,0:29:14.13,*Default,NTP,0000,0000,0000,,使用选择器函数
Dialogue: 0,0:29:14.13,0:29:16.27,*Default,NTP,0000,0000,0000,,当我们使用 Python 的对象系统时
Dialogue: 0,0:29:16.33,0:29:18.70,*Default,NTP,0000,0000,0000,,我们不需要决定
Dialogue: 0,0:29:18.70,0:29:20.80,*Default,NTP,0000,0000,0000,,我们总是选择相同的方式
Dialogue: 0,0:29:20.87,0:29:23.97,*Default,NTP,0000,0000,0000,,我们总是选择相同的方式
Dialogue: 0,0:29:24.20,0:29:26.47,*Default,NTP,0000,0000,0000,,每个部分都是一个属性
Dialogue: 0,0:29:26.47,0:29:30.00,*Default,NTP,0000,0000,0000,,而一个对象的所有属性都可以
Dialogue: 0,0:29:30.13,0:29:31.00,*Default,NTP,0000,0000,0000,,的名称
Dialogue: 0,0:29:31.67,0:29:33.87,*Default,NTP,0000,0000,0000,,这样定义就简单多了
Dialogue: 0,0:29:33.87,0:29:35.37,*Default,NTP,0000,0000,0000,,使用对象系统
Dialogue: 0,0:29:35.47,0:29:37.77,*Default,NTP,0000,0000,0000,,但使用树实例
Dialogue: 0,0:29:37.77,0:29:41.07,*Default,NTP,0000,0000,0000,,就像使用树数据抽象一样
Dialogue: 0,0:29:41.40,0:29:42.60,*Default,NTP,0000,0000,0000,,下面是一个
Dialogue: 0,0:29:42.60,0:29:45.40,*Default,NTP,0000,0000,0000,,创建斐波那契树的函数的定义
Dialogue: 0,0:29:45.73,0:29:48.73,*Default,NTP,0000,0000,0000,,与飞行不同的是
Dialogue: 0,0:29:49.13,0:29:50.50,*Default,NTP,0000,0000,0000,,当我使用对象系统时
Dialogue: 0,0:29:50.50,0:29:52.47,*Default,NTP,0000,0000,0000,,我将 "树 "字大写
Dialogue: 0,0:29:52.60,0:29:55.97,*Default,NTP,0000,0000,0000,,并使用点符号访问标签
Dialogue: 0,0:29:56.17,0:29:57.70,*Default,NTP,0000,0000,0000,,在数据抽象下
Dialogue: 0,0:29:57.73,0:29:59.50,*Default,NTP,0000,0000,0000,,我有一个名为 tree 的函数
Dialogue: 0,0:29:59.53,0:30:03.00,*Default,NTP,0000,0000,0000,,的函数，并使用选择器函数访问标签
Dialogue: 0,0:30:03.10,0:30:05.17,*Default,NTP,0000,0000,0000,,但我们的代码没有任何变化
Dialogue: 0,0:30:05.33,0:30:09.47,*Default,NTP,0000,0000,0000,,因此，面向对象编程所使用的编码风格
Dialogue: 0,0:30:09.73,0:30:10.37,*Default,NTP,0000,0000,0000,,与面向对象编程
Dialogue: 0,0:30:10.37,0:30:13.37,*Default,NTP,0000,0000,0000,,因此，面向对象编程的编码风格与使用
Dialogue: 0,0:30:13.37,0:30:14.60,*Default,NTP,0000,0000,0000,,数据抽象
Dialogue: 0,0:30:15.77,0:30:17.40,*Default,NTP,0000,0000,0000,,一旦定义了树类
Dialogue: 0,0:30:17.40,0:30:19.33,*Default,NTP,0000,0000,0000,,我就可以继续使用它
Dialogue: 0,0:30:19.90,0:30:23.73,*Default,NTP,0000,0000,0000,,因此，我只需调用 tree 就能创建一个叶子
Dialogue: 0,0:30:24.00,0:30:26.73,*Default,NTP,0000,0000,0000,,如果我想在树上添加分支
Dialogue: 0,0:30:26.73,0:30:30.93,*Default,NTP,0000,0000,0000,,我不能只通过传递标签值来实现这一点
Dialogue: 0,0:30:30.97,0:30:34.33,*Default,NTP,0000,0000,0000,,我必须输入一个树的列表
Dialogue: 0,0:30:36.10,0:30:38.57,*Default,NTP,0000,0000,0000,,这样就创建了一棵树，我称之为 t
Dialogue: 0,0:30:39.30,0:30:41.57,*Default,NTP,0000,0000,0000,,它的重写字符串是一个表达式
Dialogue: 0,0:30:41.57,0:30:43.50,*Default,NTP,0000,0000,0000,,的表达式
Dialogue: 0,0:30:44.07,0:30:45.37,*Default,NTP,0000,0000,0000,,打印出来
Dialogue: 0,0:30:45.70,0:30:47.80,*Default,NTP,0000,0000,0000,,会有多行输出
Dialogue: 0,0:30:47.93,0:30:49.90,*Default,NTP,0000,0000,0000,,其中路由标签在前
Dialogue: 0,0:30:50.10,0:30:52.47,*Default,NTP,0000,0000,0000,,而其他标签都缩进的地方
Dialogue: 0,0:30:52.70,0:30:54.10,*Default,NTP,0000,0000,0000,,不妨
Dialogue: 0,0:30:54.17,0:30:55.77,*Default,NTP,0000,0000,0000,,看看
Dialogue: 0,0:30:55.77,0:30:57.40,*Default,NTP,0000,0000,0000,,生成 repper 字符串
Dialogue: 0,0:30:57.40,0:30:58.80,*Default,NTP,0000,0000,0000,,和 stir string
Dialogue: 0,0:30:58.90,0:31:00.67,*Default,NTP,0000,0000,0000,,以了解其工作原理
Dialogue: 0,0:31:01.00,0:31:04.13,*Default,NTP,0000,0000,0000,,我们还添加了一个方法，即叶
Dialogue: 0,0:31:04.27,0:31:07.37,*Default,NTP,0000,0000,0000,,返回是否没有分支
Dialogue: 0,0:31:07.67,0:31:10.27,*Default,NTP,0000,0000,0000,,我们还定义了纤维树函数
Dialogue: 0,0:31:10.67,0:31:12.80,*Default,NTP,0000,0000,0000,,就像幻灯片上一样
Dialogue: 0,0:31:13.20,0:31:16.17,*Default,NTP,0000,0000,0000,,纤维树四是一棵相当大的树
Dialogue: 0,0:31:16.27,0:31:20.17,*Default,NTP,0000,0000,0000,,纤维树五的路径是斐波纳契第 5 号
Dialogue: 0,0:31:20.17,0:31:23.77,*Default,NTP,0000,0000,0000,,纤维树六看起来确实很大
Dialogue: 0,0:31:24.27,0:31:27.87,*Default,NTP,0000,0000,0000,,看看这些括号和方括号
Dialogue: 0,0:31:28.00,0:31:29.50,*Default,NTP,0000,0000,0000,,但如果我把它打印出来
Dialogue: 0,0:31:29.50,0:31:31.50,*Default,NTP,0000,0000,0000,,就更容易看清结构了
Dialogue: 0,0:31:31.93,0:31:33.00,*Default,NTP,0000,0000,0000,,路线上的 8
Dialogue: 0,0:31:33.33,0:31:35.07,*Default,NTP,0000,0000,0000,,两个不同的分支
Dialogue: 0,0:31:35.10,0:31:37.07,*Default,NTP,0000,0000,0000,,一个路径标签为 3
Dialogue: 0,0:31:37.07,0:31:38.97,*Default,NTP,0000,0000,0000,,另一条的路线标号是五
Dialogue: 0,0:31:39.07,0:31:40.90,*Default,NTP,0000,0000,0000,,三加五等于八
Dialogue: 0,0:31:41.13,0:31:42.97,*Default,NTP,0000,0000,0000,,那么这棵树的叶子是什么呢？
Dialogue: 0,0:31:42.97,0:31:48.57,*Default,NTP,0000,0000,0000,,我们有 0 1 1 0 1 1 0 1 等
Dialogue: 0,0:31:48.80,0:31:50.20,*Default,NTP,0000,0000,0000,,让我们写一个函数
Dialogue: 0,0:31:50.20,0:31:53.17,*Default,NTP,0000,0000,0000,,以列表形式计算树的叶子
Dialogue: 0,0:31:53.30,0:31:58.30,*Default,NTP,0000,0000,0000,,如果 t 是树叶，那么将返回一个包含一个元素的列表
Dialogue: 0,0:31:58.73,0:32:00.50,*Default,NTP,0000,0000,0000,,树的标签
Dialogue: 0,0:32:01.07,0:32:05.07,*Default,NTP,0000,0000,0000,,否则，我们需要建立一个包含所有树叶的列表
Dialogue: 0,0:32:05.20,0:32:07.07,*Default,NTP,0000,0000,0000,,让我们从一个空列表开始
Dialogue: 0,0:32:07.13,0:32:09.40,*Default,NTP,0000,0000,0000,,并对每 bnt
Dialogue: 0,0:32:09.80,0:32:13.60,*Default,NTP,0000,0000,0000,,分支，我们将递归调用 b 的叶子
Dialogue: 0,0:32:13.87,0:32:15.27,*Default,NTP,0000,0000,0000,,我们该怎么做
Dialogue: 0,0:32:15.27,0:32:19.60,*Default,NTP,0000,0000,0000,,我们将把它的所有元素添加到所有叶子中
Dialogue: 0,0:32:19.77,0:32:23.10,*Default,NTP,0000,0000,0000,,这是列表的内置方法之一
Dialogue: 0,0:32:23.53,0:32:24.47,*Default,NTP,0000,0000,0000,,其中一个
Dialogue: 0,0:32:24.97,0:32:28.73,*Default,NTP,0000,0000,0000,,而我们要扩展所有叶子的列表
Dialogue: 0,0:32:28.73,0:32:31.07,*Default,NTP,0000,0000,0000,,与新的叶子列表
Dialogue: 0,0:32:31.07,0:32:33.33,*Default,NTP,0000,0000,0000,,通过递归调用叶
Dialogue: 0,0:32:33.33,0:32:34.90,*Default,NTP,0000,0000,0000,,在分支 v
Dialogue: 0,0:32:35.17,0:32:37.67,*Default,NTP,0000,0000,0000,,那么我们可以返回所有这些叶子
Dialogue: 0,0:32:38.80,0:32:42.30,*Default,NTP,0000,0000,0000,,如果我们调用纤维树 6 上的叶子
Dialogue: 0,0:32:42.57,0:32:47.30,*Default,NTP,0000,0000,0000,,我们会得到一个与 8 相等的叶子列表
Dialogue: 0,0:32:47.70,0:32:49.93,*Default,NTP,0000,0000,0000,,这就是斐波那契第 6 号
Dialogue: 0,0:32:50.00,0:32:51.93,*Default,NTP,0000,0000,0000,,这棵树的高度是多少
Dialogue: 0,0:32:52.30,0:32:54.80,*Default,NTP,0000,0000,0000,,叶子的高度为零
Dialogue: 0,0:32:54.80,0:32:57.30,*Default,NTP,0000,0000,0000,,一般来说，一棵树的高度
Dialogue: 0,0:32:57.87,0:33:01.10,*Default,NTP,0000,0000,0000,,是其最长路径上的过渡次数
Dialogue: 0,0:33:01.47,0:33:02.80,*Default,NTP,0000,0000,0000,,我们从这里
Dialogue: 0,0:33:02.97,0:33:04.50,*Default,NTP,0000,0000,0000,,到一个过渡
Dialogue: 0,0:33:04.50,0:33:06.87,*Default,NTP,0000,0000,0000,,两个过渡 三个过渡
Dialogue: 0,0:33:06.87,0:33:08.77,*Default,NTP,0000,0000,0000,,四个过渡 五
Dialogue: 0,0:33:09.27,0:33:12.33,*Default,NTP,0000,0000,0000,,我认为纤维树 6 的高度是 5
Dialogue: 0,0:33:12.80,0:33:14.47,*Default,NTP,0000,0000,0000,,我们如何计算
Dialogue: 0,0:33:15.00,0:33:17.37,*Default,NTP,0000,0000,0000,,如果 t 是叶子
Dialogue: 0,0:33:17.70,0:33:19.20,*Default,NTP,0000,0000,0000,,则高度为零
Dialogue: 0,0:33:19.60,0:33:22.80,*Default,NTP,0000,0000,0000,,否则高度为一
Dialogue: 0,0:33:23.00,0:33:26.27,*Default,NTP,0000,0000,0000,,则高度比任何分支的最大高度多一倍
Dialogue: 0,0:33:26.27,0:33:28.17,*Default,NTP,0000,0000,0000,,所以我们来计算高度 b
Dialogue: 0,0:33:28.40,0:33:33.00,*Default,NTP,0000,0000,0000,,取最大值
Dialogue: 0,0:33:33.47,0:33:35.07,*Default,NTP,0000,0000,0000,,有一棵纤维树 6
Dialogue: 0,0:33:35.20,0:33:37.33,*Default,NTP,0000,0000,0000,,它的高度是多少？
Dialogue: 0,0:33:37.33,0:33:40.17,*Default,NTP,0000,0000,0000,,所以我们学过的关于处理树的所有知识
Dialogue: 0,0:33:40.17,0:33:41.17,*Default,NTP,0000,0000,0000,,都是一样的
Dialogue: 0,0:33:41.20,0:33:45.50,*Default,NTP,0000,0000,0000,,无论是使用数据抽象还是使用树类
Dialogue: 0,0:33:45.50,0:33:48.57,*Default,NTP,0000,0000,0000,,但使用树类有一些好处
Dialogue: 0,0:33:48.80,0:33:51.40,*Default,NTP,0000,0000,0000,,比如显示树的好方法
Dialogue: 0,0:33:51.47,0:33:53.70,*Default,NTP,0000,0000,0000,,使用这个简单的递归
Dialogue: 0,0:33:53.90,0:33:55.47,*Default,NTP,0000,0000,0000,,函数
Dialogue: 0,0:33:57.37,0:33:59.67,*Default,NTP,0000,0000,0000,,下面是一个树处理示例
Dialogue: 0,0:33:59.93,0:34:02.90,*Default,NTP,0000,0000,0000,,在这里，我们实际上改变了树的实例
Dialogue: 0,0:34:04.80,0:34:07.93,*Default,NTP,0000,0000,0000,,删除树的部分子树称为
Dialogue: 0,0:34:07.93,0:34:08.77,*Default,NTP,0000,0000,0000,,修剪
Dialogue: 0,0:34:09.70,0:34:11.97,*Default,NTP,0000,0000,0000,,要么删除一些分支
Dialogue: 0,0:34:11.97,0:34:15.47,*Default,NTP,0000,0000,0000,,或删除分支中的某些分支等
Dialogue: 0,0:34:15.77,0:34:18.20,*Default,NTP,0000,0000,0000,,在可能的情况下
Dialogue: 0,0:34:18.37,0:34:20.87,*Default,NTP,0000,0000,0000,,首先修剪当前树的分支
Dialogue: 0,0:34:21.53,0:34:25.50,*Default,NTP,0000,0000,0000,,然后递归修剪剩余的分支
Dialogue: 0,0:34:25.93,0:34:29.00,*Default,NTP,0000,0000,0000,,你可以在移除某个分支之前修剪该分支
Dialogue: 0,0:34:29.27,0:34:31.30,*Default,NTP,0000,0000,0000,,但既然要移除整个分支
Dialogue: 0,0:34:31.50,0:34:34.60,*Default,NTP,0000,0000,0000,,为什么不先移除它，然后再修剪剩下的分支呢？
Dialogue: 0,0:34:35.30,0:34:36.80,*Default,NTP,0000,0000,0000,,下面是一棵树的例子
Dialogue: 0,0:34:37.07,0:34:38.80,*Default,NTP,0000,0000,0000,,假设我们要修剪
Dialogue: 0,0:34:38.80,0:34:42.73,*Default,NTP,0000,0000,0000,,所有根标签为 1 的子树
Dialogue: 0,0:34:42.97,0:34:46.13,*Default,NTP,0000,0000,0000,,这个 0 将被删除，因为它是这个子树的一部分
Dialogue: 0,0:34:46.97,0:34:48.00,*Default,NTP,0000,0000,0000,,下面是一个模板
Dialogue: 0,0:34:48.60,0:34:51.00,*Default,NTP,0000,0000,0000,,停顿片刻，试着把它填满
Dialogue: 0,0:34:51.13,0:34:54.97,*Default,NTP,0000,0000,0000,,我将用 321 复述解决方案
Dialogue: 0,0:34:55.50,0:34:59.37,*Default,NTP,0000,0000,0000,,这里的关键是修改 tw 分支
Dialogue: 0,0:34:59.40,0:35:01.87,*Default,NTP,0000,0000,0000,,等于一个新的列表
Dialogue: 0,0:35:01.90,0:35:04.97,*Default,NTP,0000,0000,0000,,我们也可以修改旧的 tw 分支列表
Dialogue: 0,0:35:05.17,0:35:07.13,*Default,NTP,0000,0000,0000,,但我们通过
Dialogue: 0,0:35:07.27,0:35:10.33,*Default,NTP,0000,0000,0000,,通过列表理解建立一个新列表
Dialogue: 0,0:35:10.53,0:35:13.10,*Default,NTP,0000,0000,0000,,为树上的每个分支建立一个新的列表
Dialogue: 0,0:35:13.67,0:35:17.33,*Default,NTP,0000,0000,0000,,我将把它保留在 t dot 分支中
Dialogue: 0,0:35:17.37,0:35:20.87,*Default,NTP,0000,0000,0000,,如果它的标签不是 in
Dialogue: 0,0:35:21.90,0:35:23.67,*Default,NTP,0000,0000,0000,,现在 t dop 分支
Dialogue: 0,0:35:23.70,0:35:26.30,*Default,NTP,0000,0000,0000,,中可能没有所有的旧分支
Dialogue: 0,0:35:26.37,0:35:29.53,*Default,NTP,0000,0000,0000,,因此，我们会遍历剩下的分支
Dialogue: 0,0:35:29.53,0:35:30.97,*Default,NTP,0000,0000,0000,,将每个分支称为 b
Dialogue: 0,0:35:31.27,0:35:34.87,*Default,NTP,0000,0000,0000,,并使用 n 作为标签剪枝该分支。
Dialogue: 0,0:35:34.87,0:35:37.20,*Default,NTP,0000,0000,0000,,进行修剪，就是这样
Dialogue: 0,0:35:37.80,0:35:39.10,*Default,NTP,0000,0000,0000,,我们不需要返回
Dialogue: 0,0:35:39.30,0:35:41.33,*Default,NTP,0000,0000,0000,,因为剪枝函数的目的
Dialogue: 0,0:35:41.53,0:35:43.50,*Default,NTP,0000,0000,0000,,的目的是删除子树
Dialogue: 0,0:35:43.53,0:35:45.20,*Default,NTP,0000,0000,0000,,而不是计算一个新值
