[Script Info]
Title: Lecture 35. Tail Calls_哔哩哔哩_bilibili
ScriptType: v4.00+
Collisions: Reverse
PlayResX: 1280
PlayResY: 720
WrapStyle: 3
ScaledBorderAndShadow: yes
; ----------------------
; 本字幕由CC字幕助手自动转换
; 字幕来源https://www.bilibili.com/video/BV1s3411G7yM?p=84&vd_source=6ffca0aa1006734a4fba52f389036611
; 脚本地址https://greasyfork.org/scripts/378513
; 设置了字幕过长自动换行，但若字幕中没有空格换行将无效
; 字体大小依据720p 48号字体等比缩放
; 如显示不正常请尝试使用SRT格式

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Segoe UI,48,&H00FFFFFF,&HF0000000,&H00000000,&HF0000000,1,0,0,0,100,100,0,0.00,1,1,3,2,30,30,20,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.87,0:00:03.20,*Default,NTP,0000,0000,0000,,61 a 第 35 期讲座
Dialogue: 0,0:00:03.53,0:00:04.53,*Default,NTP,0000,0000,0000,,公告
Dialogue: 0,0:00:05.67,0:00:08.40,*Default,NTP,0000,0000,0000,,计划项目周二到期
Dialogue: 0,0:00:08.80,0:00:10.13,*Default,NTP,0000,0000,0000,,您可以提前提交
Dialogue: 0,0:00:10.13,0:00:11.57,*Default,NTP,0000,0000,0000,,奖励分
Dialogue: 0,0:00:11.57,0:00:12.93,*Default,NTP,0000,0000,0000,,周一前完成
Dialogue: 0,0:00:13.57,0:00:15.37,*Default,NTP,0000,0000,0000,,如果您想获得提前提交奖励分
Dialogue: 0,0:00:15.67,0:00:17.27,*Default,NTP,0000,0000,0000,,和额外学分
Dialogue: 0,0:00:17.27,0:00:19.07,*Default,NTP,0000,0000,0000,,解决字母 lambda 问题
Dialogue: 0,0:00:19.17,0:00:20.67,*Default,NTP,0000,0000,0000,,请在周一前完成
Dialogue: 0,0:00:21.87,0:00:25.27,*Default,NTP,0000,0000,0000,,第九个作业在感恩节后的周四完成
Dialogue: 0,0:00:25.27,0:00:26.57,*Default,NTP,0000,0000,0000,,已经发布了
Dialogue: 0,0:00:26.67,0:00:28.37,*Default,NTP,0000,0000,0000,,但你可以忽略它，等到下周再做
Dialogue: 0,0:00:28.37,0:00:29.47,*Default,NTP,0000,0000,0000,,没问题
Dialogue: 0,0:00:30.10,0:00:30.90,*Default,NTP,0000,0000,0000,,实验 13
Dialogue: 0,0:00:31.47,0:00:33.17,*Default,NTP,0000,0000,0000,,通常会做
Dialogue: 0,0:00:34.00,0:00:36.73,*Default,NTP,0000,0000,0000,,可选
Dialogue: 0,0:00:36.73,0:00:38.93,*Default,NTP,0000,0000,0000,,每个人都将获得该实验的学分
Dialogue: 0,0:00:39.07,0:00:41.00,*Default,NTP,0000,0000,0000,,无论你做还是不做
Dialogue: 0,0:00:41.20,0:00:43.33,*Default,NTP,0000,0000,0000,,但我建议你们做这个实验
Dialogue: 0,0:00:43.33,0:00:44.73,*Default,NTP,0000,0000,0000,,因为这是为期末考试
Dialogue: 0,0:00:44.73,0:00:45.97,*Default,NTP,0000,0000,0000,,期末考试
Dialogue: 0,0:00:46.90,0:00:49.50,*Default,NTP,0000,0000,0000,,我们通常有五次实验指导
Dialogue: 0,0:00:49.50,0:00:51.40,*Default,NTP,0000,0000,0000,,但我们已经减少到两次
Dialogue: 0,0:00:51.60,0:00:53.07,*Default,NTP,0000,0000,0000,,因为这是选修课
Dialogue: 0,0:00:53.10,0:00:55.87,*Default,NTP,0000,0000,0000,,我估计参加人数会少一点
Dialogue: 0,0:00:56.27,0:00:57.20,*Default,NTP,0000,0000,0000,,当然，我们会
Dialogue: 0,0:00:57.20,0:01:00.20,*Default,NTP,0000,0000,0000,,如果不方便的话
Dialogue: 0,0:01:00.20,0:01:01.73,*Default,NTP,0000,0000,0000,,如果时间不方便
Dialogue: 0,0:01:01.93,0:01:03.50,*Default,NTP,0000,0000,0000,,这样您就可以在本周三至周五
Dialogue: 0,0:01:05.33,0:01:06.67,*Default,NTP,0000,0000,0000,,本周三至周五
Dialogue: 0,0:01:06.67,0:01:08.60,*Default,NTP,0000,0000,0000,,这堂课没有任何相关内容
Dialogue: 0,0:01:08.60,0:01:11.73,*Default,NTP,0000,0000,0000,,没有讲座，没有讨论，没有辅导，没有办公时间
Dialogue: 0,0:01:11.97,0:01:13.53,*Default,NTP,0000,0000,0000,,唯一的活动
Dialogue: 0,0:01:13.53,0:01:15.07,*Default,NTP,0000,0000,0000,,是完全可选的
Dialogue: 0,0:01:15.13,0:01:17.30,*Default,NTP,0000,0000,0000,,计划递归艺术竞赛
Dialogue: 0,0:01:17.47,0:01:18.73,*Default,NTP,0000,0000,0000,,有参赛作品
Dialogue: 0,0:01:18.73,0:01:20.73,*Default,NTP,0000,0000,0000,,感恩节后的星期一
Dialogue: 0,0:01:21.10,0:01:23.87,*Default,NTP,0000,0000,0000,,你会发现一份计划竞赛的作业
Dialogue: 0,0:01:24.07,0:01:25.60,*Default,NTP,0000,0000,0000,,介绍了比赛规则
Dialogue: 0,0:01:25.90,0:01:27.13,*Default,NTP,0000,0000,0000,,以及如何提交作品
Dialogue: 0,0:01:28.70,0:01:30.67,*Default,NTP,0000,0000,0000,,还有一件事要注意
Dialogue: 0,0:01:30.80,0:01:32.60,*Default,NTP,0000,0000,0000,,感恩节后一周
Dialogue: 0,0:01:32.70,0:01:33.97,*Default,NTP,0000,0000,0000,,是我们为该周增加了一些
Dialogue: 0,0:01:34.07,0:01:37.50,*Default,NTP,0000,0000,0000,,更长的 45 分钟教程
Dialogue: 0,0:01:38.00,0:01:40.00,*Default,NTP,0000,0000,0000,,重点是复习
Dialogue: 0,0:01:40.40,0:01:41.57,*Default,NTP,0000,0000,0000,,讨论和实验
Dialogue: 0,0:01:41.57,0:01:43.57,*Default,NTP,0000,0000,0000,,无论如何，那一周的重点是复习
Dialogue: 0,0:01:44.07,0:01:46.30,*Default,NTP,0000,0000,0000,,但我们将尝试一些更长的教程
Dialogue: 0,0:01:46.33,0:01:48.17,*Default,NTP,0000,0000,0000,,如果您认为这种形式更合适
Dialogue: 0,0:01:49.37,0:01:51.10,*Default,NTP,0000,0000,0000,,如果你在教程上滚动
Dialogue: 0,0:01:51.10,0:01:52.00,*Default,NTP,0000,0000,0000,,就会看到
Dialogue: 0,0:01:52.00,0:01:53.47,*Default,NTP,0000,0000,0000,,在这里链接的 Oreg
Dialogue: 0,0:01:53.57,0:01:54.87,*Default,NTP,0000,0000,0000,,你会发现其中一些
Dialogue: 0,0:01:55.33,0:01:57.73,*Default,NTP,0000,0000,0000,,希望你们有一个愉快的感恩节
Dialogue: 0,0:01:57.87,0:01:59.60,*Default,NTP,0000,0000,0000,,今天的讲座可有可无
Dialogue: 0,0:01:59.87,0:02:00.93,*Default,NTP,0000,0000,0000,,你们真的应该看看
Dialogue: 0,0:02:00.93,0:02:03.17,*Default,NTP,0000,0000,0000,,这是我最喜欢的课程主题之一
Dialogue: 0,0:02:03.50,0:02:05.60,*Default,NTP,0000,0000,0000,,叫做尾部调用
Dialogue: 0,0:02:05.80,0:02:08.87,*Default,NTP,0000,0000,0000,,这是对野生循环的回答
Dialogue: 0,0:02:09.77,0:02:12.80,*Default,NTP,0000,0000,0000,,为什么在Scheme中没有wild语句？
Dialogue: 0,0:02:12.80,0:02:14.40,*Default,NTP,0000,0000,0000,,你可以使用递归
Dialogue: 0,0:02:14.47,0:02:17.70,*Default,NTP,0000,0000,0000,,但递归不是很慢吗？
Dialogue: 0,0:02:17.73,0:02:19.60,*Default,NTP,0000,0000,0000,,不一定
Dialogue: 0,0:02:19.80,0:02:20.90,*Default,NTP,0000,0000,0000,,这里有一个主题
Dialogue: 0,0:02:20.90,0:02:21.33,*Default,NTP,0000,0000,0000,,关于
Dialogue: 0,0:02:21.33,0:02:24.00,*Default,NTP,0000,0000,0000,,编程语言及其解释方式
Dialogue: 0,0:02:24.13,0:02:26.33,*Default,NTP,0000,0000,0000,,正是要解决这个问题
Dialogue: 0,0:02:27.47,0:02:28.30,*Default,NTP,0000,0000,0000,,在整个讲座中
Dialogue: 0,0:02:28.30,0:02:30.73,*Default,NTP,0000,0000,0000,,你可能会听到额外学分的说法
Dialogue: 0,0:02:31.13,0:02:33.53,*Default,NTP,0000,0000,0000,,因为在一个典型的学期里
Dialogue: 0,0:02:33.80,0:02:36.10,*Default,NTP,0000,0000,0000,,重新设计你的解释器
Dialogue: 0,0:02:36.10,0:02:38.70,*Default,NTP,0000,0000,0000,,使其执行调用优化
Dialogue: 0,0:02:38.80,0:02:40.60,*Default,NTP,0000,0000,0000,,是一个额外学分问题
Dialogue: 0,0:02:41.17,0:02:41.97,*Default,NTP,0000,0000,0000,,而
Dialogue: 0,0:02:41.97,0:02:44.87,*Default,NTP,0000,0000,0000,,让塔兰达问题通常是一个必修问题
Dialogue: 0,0:02:44.87,0:02:46.90,*Default,NTP,0000,0000,0000,,但现在我们把它变成了额外学分
Dialogue: 0,0:02:47.13,0:02:49.20,*Default,NTP,0000,0000,0000,,去掉了尾部调用问题
Dialogue: 0,0:02:49.40,0:02:50.33,*Default,NTP,0000,0000,0000,,它仍然存在
Dialogue: 0,0:02:50.33,0:02:52.37,*Default,NTP,0000,0000,0000,,如果你愿意，可以选择性地解决它
Dialogue: 0,0:02:52.37,0:02:53.87,*Default,NTP,0000,0000,0000,,事实上
Dialogue: 0,0:02:53.87,0:02:55.00,*Default,NTP,0000,0000,0000,,如何将
Dialogue: 0,0:02:55.00,0:02:56.67,*Default,NTP,0000,0000,0000,,解释器
Dialogue: 0,0:02:56.90,0:02:57.93,*Default,NTP,0000,0000,0000,,这需要你
Dialogue: 0,0:02:57.93,0:02:59.50,*Default,NTP,0000,0000,0000,,了解程序的整体结构
Dialogue: 0,0:02:59.50,0:03:00.20,*Default,NTP,0000,0000,0000,,你在
Dialogue: 0,0:03:00.20,0:03:01.07,*Default,NTP,0000,0000,0000,,项目四
Dialogue: 0,0:03:02.20,0:03:03.70,*Default,NTP,0000,0000,0000,,如果你不想这样做
Dialogue: 0,0:03:03.70,0:03:05.37,*Default,NTP,0000,0000,0000,,你可以只听这个讲座
Dialogue: 0,0:03:05.37,0:03:06.80,*Default,NTP,0000,0000,0000,,然后你就会知道
Dialogue: 0,0:03:06.80,0:03:08.40,*Default,NTP,0000,0000,0000,,人们所说的
Dialogue: 0,0:03:08.40,0:03:10.87,*Default,NTP,0000,0000,0000,,故事递归或故事调用
Dialogue: 0,0:03:11.73,0:03:14.13,*Default,NTP,0000,0000,0000,,如果其中一个讲座视频提到
Dialogue: 0,0:03:14.13,0:03:14.93,*Default,NTP,0000,0000,0000,,关于额外学分
Dialogue: 0,0:03:14.93,0:03:16.27,*Default,NTP,0000,0000,0000,,而你想知道本学期是否可以
Dialogue: 0,0:03:16.27,0:03:18.17,*Default,NTP,0000,0000,0000,,额外学分
Dialogue: 0,0:03:18.30,0:03:19.67,*Default,NTP,0000,0000,0000,,答案是否定的
Dialogue: 0,0:03:19.70,0:03:22.00,*Default,NTP,0000,0000,0000,,但我没有重新录制所有视频
Dialogue: 0,0:03:22.00,0:03:23.77,*Default,NTP,0000,0000,0000,,因为内容是一样的
Dialogue: 0,0:03:24.17,0:03:25.47,*Default,NTP,0000,0000,0000,,好了，让我们开始吧
Dialogue: 0,0:03:28.17,0:03:30.17,*Default,NTP,0000,0000,0000,,今天的整个讲座
Dialogue: 0,0:03:30.57,0:03:33.50,*Default,NTP,0000,0000,0000,,是关于如何解决项目四的额外学分问题
Dialogue: 0,0:03:33.70,0:03:35.10,*Default,NTP,0000,0000,0000,,项目四
Dialogue: 0,0:03:35.80,0:03:38.90,*Default,NTP,0000,0000,0000,,但它也提出了一个非常重要的概念
Dialogue: 0,0:03:39.13,0:03:42.70,*Default,NTP,0000,0000,0000,,编程语言中一个非常重要的概念，叫做尾部递归
Dialogue: 0,0:03:44.50,0:03:47.67,*Default,NTP,0000,0000,0000,,函数式编程的理念是
Dialogue: 0,0:03:47.97,0:03:51.13,*Default,NTP,0000,0000,0000,,你可以根据纯函数来组织整个程序
Dialogue: 0,0:03:51.13,0:03:53.33,*Default,NTP,0000,0000,0000,,根据纯函数
Dialogue: 0,0:03:53.50,0:03:57.00,*Default,NTP,0000,0000,0000,,我们的模块可以以有趣的方式组合
Dialogue: 0,0:03:57.20,0:03:59.10,*Default,NTP,0000,0000,0000,,而且还有其他优点
Dialogue: 0,0:03:59.80,0:04:01.30,*Default,NTP,0000,0000,0000,,所以函数式编程
Dialogue: 0,0:04:01.80,0:04:03.13,*Default,NTP,0000,0000,0000,,是一个非常宽泛的术语
Dialogue: 0,0:04:03.13,0:04:05.80,*Default,NTP,0000,0000,0000,,但通常指以下特性
Dialogue: 0,0:04:06.30,0:04:08.20,*Default,NTP,0000,0000,0000,,所有函数都是纯函数
Dialogue: 0,0:04:08.20,0:04:09.90,*Default,NTP,0000,0000,0000,,没有副作用
Dialogue: 0,0:04:10.40,0:04:12.10,*Default,NTP,0000,0000,0000,,没有重赋值
Dialogue: 0,0:04:12.27,0:04:14.20,*Default,NTP,0000,0000,0000,,没有可变数据类型
Dialogue: 0,0:04:14.60,0:04:17.10,*Default,NTP,0000,0000,0000,,当你创建一个东西时，它就在那里，不会消失
Dialogue: 0,0:04:18.00,0:04:18.57,*Default,NTP,0000,0000,0000,,名称
Dialogue: 0,0:04:18.57,0:04:21.53,*Default,NTP,0000,0000,0000,,值绑定也是永久性的
Dialogue: 0,0:04:22.97,0:04:24.47,*Default,NTP,0000,0000,0000,,有了这些东西
Dialogue: 0,0:04:24.80,0:04:27.30,*Default,NTP,0000,0000,0000,,就能获得某些优势
Dialogue: 0,0:04:28.07,0:04:28.80,*Default,NTP,0000,0000,0000,,第一
Dialogue: 0,0:04:28.80,0:04:32.13,*Default,NTP,0000,0000,0000,,表达式的值与子表达式的求值顺序无关
Dialogue: 0,0:04:32.13,0:04:35.27,*Default,NTP,0000,0000,0000,,子表达式的求值顺序
Dialogue: 0,0:04:36.30,0:04:37.10,*Default,NTP,0000,0000,0000,,现在
Dialogue: 0,0:04:37.67,0:04:39.50,*Default,NTP,0000,0000,0000,,我们可以选择一个特定的顺序
Dialogue: 0,0:04:39.50,0:04:41.57,*Default,NTP,0000,0000,0000,,我们在 Python 中就是这么做的
Dialogue: 0,0:04:41.87,0:04:43.27,*Default,NTP,0000,0000,0000,,但如果
Dialogue: 0,0:04:43.47,0:04:45.90,*Default,NTP,0000,0000,0000,,如果我们能根据情况
Dialogue: 0,0:04:45.90,0:04:47.70,*Default,NTP,0000,0000,0000,,视情况而定
Dialogue: 0,0:04:48.17,0:04:49.20,*Default,NTP,0000,0000,0000,,特别是
Dialogue: 0,0:04:49.57,0:04:53.10,*Default,NTP,0000,0000,0000,,我们可以并行评估子表达式
Dialogue: 0,0:04:53.10,0:04:56.20,*Default,NTP,0000,0000,0000,,如果我们有多个不同的处理单元
Dialogue: 0,0:04:56.40,0:04:57.73,*Default,NTP,0000,0000,0000,,或者我们甚至可以等待
Dialogue: 0,0:04:57.73,0:04:58.73,*Default,NTP,0000,0000,0000,,看看我们是否真的
Dialogue: 0,0:04:58.73,0:05:00.77,*Default,NTP,0000,0000,0000,,需要某个子表达式的值
Dialogue: 0,0:05:00.87,0:05:03.27,*Default,NTP,0000,0000,0000,,的值，然后再开始求值
Dialogue: 0,0:05:06.20,0:05:09.60,*Default,NTP,0000,0000,0000,,这些都是富有成效的参照透明
Dialogue: 0,0:05:09.90,0:05:12.40,*Default,NTP,0000,0000,0000,,表达式的值
Dialogue: 0,0:05:12.70,0:05:13.80,*Default,NTP,0000,0000,0000,,不会改变
Dialogue: 0,0:05:14.10,0:05:16.70,*Default,NTP,0000,0000,0000,,当你用一个子表达式的值代替它时
Dialogue: 0,0:05:16.73,0:05:18.90,*Default,NTP,0000,0000,0000,,时，表达式的值不会改变
Dialogue: 0,0:05:19.20,0:05:21.70,*Default,NTP,0000,0000,0000,,这让你在进行记忆等操作时
Dialogue: 0,0:05:21.80,0:05:23.20,*Default,NTP,0000,0000,0000,,而不必担心
Dialogue: 0,0:05:23.20,0:05:25.77,*Default,NTP,0000,0000,0000,,你会改变程序的行为
Dialogue: 0,0:05:26.70,0:05:28.10,*Default,NTP,0000,0000,0000,,所以这些都是好事
Dialogue: 0,0:05:28.10,0:05:31.10,*Default,NTP,0000,0000,0000,,因此，函数式编程让人兴奋不已
Dialogue: 0,0:05:31.53,0:05:34.57,*Default,NTP,0000,0000,0000,,尤其是在这个时代
Dialogue: 0,0:05:34.60,0:05:37.07,*Default,NTP,0000,0000,0000,,计算机处理单元越来越多的时代
Dialogue: 0,0:05:37.10,0:05:40.97,*Default,NTP,0000,0000,0000,,自动瘫痪工作不是很好吗
Dialogue: 0,0:05:42.00,0:05:43.93,*Default,NTP,0000,0000,0000,,但有人可能会问
Dialogue: 0,0:05:44.17,0:05:46.73,*Default,NTP,0000,0000,0000,,如果没有四则运算语句
Dialogue: 0,0:05:46.73,0:05:48.77,*Default,NTP,0000,0000,0000,,因为我们不允许将名称
Dialogue: 0,0:05:48.77,0:05:49.93,*Default,NTP,0000,0000,0000,,重绑定到一个新值
Dialogue: 0,0:05:50.07,0:05:55.53,*Default,NTP,0000,0000,0000,,我们真的能让基本的迭代过程变得高效吗？
Dialogue: 0,0:05:55.87,0:05:59.47,*Default,NTP,0000,0000,0000,,或者我们只能使用递归，而递归又很慢
Dialogue: 0,0:05:59.70,0:06:00.50,*Default,NTP,0000,0000,0000,,所以
Dialogue: 0,0:06:00.53,0:06:03.50,*Default,NTP,0000,0000,0000,,这些语言不可能变得很快
Dialogue: 0,0:06:04.20,0:06:07.13,*Default,NTP,0000,0000,0000,,事实证明，这个问题是有答案的
Dialogue: 0,0:06:07.57,0:06:10.17,*Default,NTP,0000,0000,0000,,你可以让函数式编程语言
Dialogue: 0,0:06:10.27,0:06:11.67,*Default,NTP,0000,0000,0000,,一样高效
Dialogue: 0,0:06:11.93,0:06:13.30,*Default,NTP,0000,0000,0000,,一样高效
Dialogue: 0,0:06:13.80,0:06:15.37,*Default,NTP,0000,0000,0000,,一样高效。
Dialogue: 0,0:06:15.37,0:06:18.73,*Default,NTP,0000,0000,0000,,我们今天要讨论的尾部递归概念
Dialogue: 0,0:06:20.67,0:06:22.57,*Default,NTP,0000,0000,0000,,让我们来看一个例子
Dialogue: 0,0:06:23.20,0:06:24.80,*Default,NTP,0000,0000,0000,,递归与迭代
Dialogue: 0,0:06:24.80,0:06:28.50,*Default,NTP,0000,0000,0000,,在 python 中，递归调用总是创建新的
Dialogue: 0,0:06:28.73,0:06:29.90,*Default,NTP,0000,0000,0000,,活动帧
Dialogue: 0,0:06:30.10,0:06:31.10,*Default,NTP,0000,0000,0000,,让我们看看这意味着什么
Dialogue: 0,0:06:31.10,0:06:35.10,*Default,NTP,0000,0000,0000,,让我们来看看这意味着什么。
Dialogue: 0,0:06:35.37,0:06:38.53,*Default,NTP,0000,0000,0000,,计算 k 乘以 n 的阶乘
Dialogue: 0,0:06:39.93,0:06:41.67,*Default,NTP,0000,0000,0000,,下面是递归定义
Dialogue: 0,0:06:42.00,0:06:43.13,*Default,NTP,0000,0000,0000,,如果 n 为零
Dialogue: 0,0:06:43.13,0:06:46.10,*Default,NTP,0000,0000,0000,,我们只返回 k，因为零阶乘为一
Dialogue: 0,0:06:46.73,0:06:50.73,*Default,NTP,0000,0000,0000,,否则，我们返回一个递归调用
Dialogue: 0,0:06:51.60,0:06:54.97,*Default,NTP,0000,0000,0000,,其中 end 被递减，并乘以
Dialogue: 0,0:06:55.07,0:06:56.17,*Default,NTP,0000,0000,0000,,乘以常数
Dialogue: 0,0:06:56.50,0:06:57.87,*Default,NTP,0000,0000,0000,,这样我们就积累了
Dialogue: 0,0:06:57.87,0:06:59.57,*Default,NTP,0000,0000,0000,,阶乘的所有不同项
Dialogue: 0,0:06:59.57,0:07:01.50,*Default,NTP,0000,0000,0000,,的所有阶乘
Dialogue: 0,0:07:03.17,0:07:04.97,*Default,NTP,0000,0000,0000,,下面是一个完整的定义
Dialogue: 0,0:07:05.37,0:07:10.50,*Default,NTP,0000,0000,0000,,阶乘 nk 当 n 大于零时，重新绑定 nk
Dialogue: 0,0:07:10.93,0:07:14.30,*Default,NTP,0000,0000,0000,,到减一和 k 的末尾，然后返回 k
Dialogue: 0,0:07:14.57,0:07:15.20,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:07:15.20,0:07:17.40,*Default,NTP,0000,0000,0000,,在这两种情况下应用了相同的逻辑
Dialogue: 0,0:07:17.40,0:07:18.70,*Default,NTP,0000,0000,0000,,但还是有区别的
Dialogue: 0,0:07:19.00,0:07:23.10,*Default,NTP,0000,0000,0000,,时间上的差异仅为一个常数因子
Dialogue: 0,0:07:23.10,0:07:25.17,*Default,NTP,0000,0000,0000,,这是一个线性时间递归
Dialogue: 0,0:07:25.73,0:07:29.30,*Default,NTP,0000,0000,0000,,但线性时间递归需要线性空间
Dialogue: 0,0:07:30.53,0:07:33.10,*Default,NTP,0000,0000,0000,,迭代版本也需要线性时间
Dialogue: 0,0:07:33.10,0:07:34.37,*Default,NTP,0000,0000,0000,,你必须
Dialogue: 0,0:07:34.47,0:07:36.67,*Default,NTP,0000,0000,0000,,多次
Dialogue: 0,0:07:37.27,0:07:38.00,*Default,NTP,0000,0000,0000,,每结束一次
Dialogue: 0,0:07:38.00,0:07:39.93,*Default,NTP,0000,0000,0000,,然后每次都会得到甲板许可
Dialogue: 0,0:07:40.27,0:07:43.13,*Default,NTP,0000,0000,0000,,但我们只有恒定的空间
Dialogue: 0,0:07:43.13,0:07:44.47,*Default,NTP,0000,0000,0000,,因为我们有固定数量的
Dialogue: 0,0:07:44.47,0:07:46.00,*Default,NTP,0000,0000,0000,,我们必须记住
Dialogue: 0,0:07:46.20,0:07:51.17,*Default,NTP,0000,0000,0000,,和 nk 以及阶乘，无论它们有多大。
Dialogue: 0,0:07:54.37,0:07:56.10,*Default,NTP,0000,0000,0000,,那么我们如何弥补
Dialogue: 0,0:07:56.53,0:07:58.73,*Default,NTP,0000,0000,0000,,之间的差距
Dialogue: 0,0:07:58.73,0:08:01.13,*Default,NTP,0000,0000,0000,,之间的差距
Dialogue: 0,0:08:01.17,0:08:02.60,*Default,NTP,0000,0000,0000,,与阶乘所需的空间之间的鸿沟
Dialogue: 0,0:08:02.80,0:08:05.57,*Default,NTP,0000,0000,0000,,这就是我们今天要讨论的主题
Dialogue: 0,0:08:09.50,0:08:14.30,*Default,NTP,0000,0000,0000,,如果你读一下滑雪语言的说明
Dialogue: 0,0:08:16.40,0:08:16.90,*Default,NTP,0000,0000,0000,,它说
Dialogue: 0,0:08:16.90,0:08:20.30,*Default,NTP,0000,0000,0000,,模式的实现需要适当的阶乘
Dialogue: 0,0:08:20.30,0:08:21.17,*Default,NTP,0000,0000,0000,,递归
Dialogue: 0,0:08:21.60,0:08:25.40,*Default,NTP,0000,0000,0000,,这允许在恒定空间内执行迭代计算
Dialogue: 0,0:08:25.53,0:08:27.00,*Default,NTP,0000,0000,0000,,在恒定空间内执行
Dialogue: 0,0:08:27.37,0:08:30.33,*Default,NTP,0000,0000,0000,,即使迭代计算是由语法上递归的过程描述的
Dialogue: 0,0:08:30.37,0:08:33.53,*Default,NTP,0000,0000,0000,,由语法递归过程描述
Dialogue: 0,0:08:34.70,0:08:37.73,*Default,NTP,0000,0000,0000,,所以请记住，我们在 Python 中的迭代版本
Dialogue: 0,0:08:37.77,0:08:40.73,*Default,NTP,0000,0000,0000,,这需要线性时间，但空间不变
Dialogue: 0,0:08:41.27,0:08:44.77,*Default,NTP,0000,0000,0000,,我们的想法是，如果编写与方案过程相同的逻辑
Dialogue: 0,0:08:45.17,0:08:46.97,*Default,NTP,0000,0000,0000,,的逻辑
Dialogue: 0,0:08:47.77,0:08:50.90,*Default,NTP,0000,0000,0000,,那么计算的方式和时间就是
Dialogue: 0,0:08:51.10,0:08:52.20,*Default,NTP,0000,0000,0000,,k 次阶乘
Dialogue: 0,0:08:52.20,0:08:54.27,*Default,NTP,0000,0000,0000,,是检查 an 是否为零
Dialogue: 0,0:08:54.40,0:08:57.07,*Default,NTP,0000,0000,0000,,然后返回 k，否则进行递归调用
Dialogue: 0,0:08:58.73,0:09:01.10,*Default,NTP,0000,0000,0000,,这样就可以利用资源
Dialogue: 0,0:09:01.67,0:09:02.77,*Default,NTP,0000,0000,0000,,但我们如何做到这一点呢？
Dialogue: 0,0:09:02.90,0:09:05.37,*Default,NTP,0000,0000,0000,,答案就是我们去掉中间环节
Dialogue: 0,0:09:05.40,0:09:09.13,*Default,NTP,0000,0000,0000,,消除不再需要的框架
Dialogue: 0,0:09:10.00,0:09:11.90,*Default,NTP,0000,0000,0000,,当我们进行递归调用时
Dialogue: 0,0:09:13.00,0:09:14.97,*Default,NTP,0000,0000,0000,,让我告诉你这些框架是什么
Dialogue: 0,0:09:18.00,0:09:19.50,*Default,NTP,0000,0000,0000,,现在我们回到 Python
Dialogue: 0,0:09:19.73,0:09:22.97,*Default,NTP,0000,0000,0000,,我们来看阶乘的递归定义
Dialogue: 0,0:09:23.73,0:09:25.17,*Default,NTP,0000,0000,0000,,的递归定义。
Dialogue: 0,0:09:25.40,0:09:28.33,*Default,NTP,0000,0000,0000,,我们看到每次调用阶乘都会创建一个新的框架
Dialogue: 0,0:09:30.57,0:09:32.73,*Default,NTP,0000,0000,0000,,在这里，我们的末端绑定到 4
Dialogue: 0,0:09:32.73,0:09:35.20,*Default,NTP,0000,0000,0000,,这里的末端绑定到 3 末端绑定到 2
Dialogue: 0,0:09:35.93,0:09:39.47,*Default,NTP,0000,0000,0000,,很快，我们将看到末端绑定到 1，末端绑定到 0
Dialogue: 0,0:09:39.80,0:09:41.33,*Default,NTP,0000,0000,0000,,这就是最终状态
Dialogue: 0,0:09:42.17,0:09:43.90,*Default,NTP,0000,0000,0000,,现在将返回什么
Dialogue: 0,0:09:43.90,0:09:45.87,*Default,NTP,0000,0000,0000,,这个将返回 40
Dialogue: 0,0:09:45.87,0:09:48.57,*Default,NTP,0000,0000,0000,,我们看到了，但请注意，其他每个
Dialogue: 0,0:09:48.57,0:09:49.37,*Default,NTP,0000,0000,0000,,调用
Dialogue: 0,0:09:49.37,0:09:51.77,*Default,NTP,0000,0000,0000,,都会返回上一个调用的结果
Dialogue: 0,0:09:53.57,0:09:54.07,*Default,NTP,0000,0000,0000,,40
Dialogue: 0,0:09:54.07,0:09:57.40,*Default,NTP,0000,0000,0000,,四十二 四十二 四十二 四十四 我们就完成了
Dialogue: 0,0:09:58.07,0:10:02.17,*Default,NTP,0000,0000,0000,,现在，我们没有必要为了弄清我们只是在调用最后一个结果
Dialogue: 0,0:10:02.60,0:10:04.27,*Default,NTP,0000,0000,0000,,以确定我们只是
Dialogue: 0,0:10:04.27,0:10:06.17,*Default,NTP,0000,0000,0000,,返回下一次调用
Dialogue: 0,0:10:06.30,0:10:07.67,*Default,NTP,0000,0000,0000,,从下一次调用
Dialogue: 0,0:10:07.93,0:10:09.93,*Default,NTP,0000,0000,0000,,所以中间这些额外的帧
Dialogue: 0,0:10:10.13,0:10:12.20,*Default,NTP,0000,0000,0000,,是为了弄清楚
Dialogue: 0,0:10:12.20,0:10:13.80,*Default,NTP,0000,0000,0000,,如何进行递归调用
Dialogue: 0,0:10:13.90,0:10:15.47,*Default,NTP,0000,0000,0000,,但在递归调用完成后
Dialogue: 0,0:10:15.47,0:10:17.17,*Default,NTP,0000,0000,0000,,在递归调用完成后
Dialogue: 0,0:10:17.30,0:10:18.60,*Default,NTP,0000,0000,0000,,但我们还是保留了它们
Dialogue: 0,0:10:18.60,0:10:20.27,*Default,NTP,0000,0000,0000,,因为这就是 python 的工作方式
Dialogue: 0,0:10:20.47,0:10:24.07,*Default,NTP,0000,0000,0000,,但一个正确的递归语言不会这样做
Dialogue: 0,0:10:29.07,0:10:31.33,*Default,NTP,0000,0000,0000,,这里的基本思想是使
Dialogue: 0,0:10:32.07,0:10:34.20,*Default,NTP,0000,0000,0000,,使这些递归过程高效的基本思想
Dialogue: 0,0:10:34.60,0:10:37.17,*Default,NTP,0000,0000,0000,,的基本思想是，有些调用
Dialogue: 0,0:10:37.57,0:10:40.33,*Default,NTP,0000,0000,0000,,是尾调用，有些不是
Dialogue: 0,0:10:41.13,0:10:43.40,*Default,NTP,0000,0000,0000,,这种区别可以确定
Dialogue: 0,0:10:43.67,0:10:46.17,*Default,NTP,0000,0000,0000,,当一个存储过程调用另一个存储过程时
Dialogue: 0,0:10:46.57,0:10:48.53,*Default,NTP,0000,0000,0000,,是否有更多的工作要做
Dialogue: 0,0:10:49.53,0:10:53.00,*Default,NTP,0000,0000,0000,,被调用的存储过程是否已经结束
Dialogue: 0,0:10:53.73,0:10:56.10,*Default,NTP,0000,0000,0000,,如果没有其他工作要做
Dialogue: 0,0:10:56.10,0:10:56.67,*Default,NTP,0000,0000,0000,,除了
Dialogue: 0,0:10:56.67,0:10:59.60,*Default,NTP,0000,0000,0000,,只返回所调用表达式的值
Dialogue: 0,0:10:59.90,0:11:01.53,*Default,NTP,0000,0000,0000,,那么这就是尾调用
Dialogue: 0,0:11:02.53,0:11:05.40,*Default,NTP,0000,0000,0000,,所以尾部调用有一个很长的定义
Dialogue: 0,0:11:05.40,0:11:06.70,*Default,NTP,0000,0000,0000,,让我们来了解一下
Dialogue: 0,0:11:07.40,0:11:10.93,*Default,NTP,0000,0000,0000,,尚未返回有效值的过程调用
Dialogue: 0,0:11:11.10,0:11:11.90,*Default,NTP,0000,0000,0000,,意思是
Dialogue: 0,0:11:12.40,0:11:14.60,*Default,NTP,0000,0000,0000,,有一天我们仍然会从中返回一些东西
Dialogue: 0,0:11:15.20,0:11:17.17,*Default,NTP,0000,0000,0000,,有些过程调用是尾调用
Dialogue: 0,0:11:17.17,0:11:18.53,*Default,NTP,0000,0000,0000,,方案解释器
Dialogue: 0,0:11:18.90,0:11:21.10,*Default,NTP,0000,0000,0000,,应支持无限制的数量
Dialogue: 0,0:11:21.10,0:11:22.50,*Default,NTP,0000,0000,0000,,这意味着我们想要多少就有多少
Dialogue: 0,0:11:22.60,0:11:25.00,*Default,NTP,0000,0000,0000,,不受限制的尾部调用次数
Dialogue: 0,0:11:25.07,0:11:27.60,*Default,NTP,0000,0000,0000,,只使用恒定的空间
Dialogue: 0,0:11:28.07,0:11:29.17,*Default,NTP,0000,0000,0000,,而要做到这一点
Dialogue: 0,0:11:29.30,0:11:32.33,*Default,NTP,0000,0000,0000,,跳过你在环境图中看到的所有额外帧
Dialogue: 0,0:11:32.33,0:11:33.80,*Default,NTP,0000,0000,0000,,在环境图中
Dialogue: 0,0:11:33.80,0:11:35.10,*Default,NTP,0000,0000,0000,,这显示在 python 中
Dialogue: 0,0:11:35.93,0:11:37.50,*Default,NTP,0000,0000,0000,,什么是尾调用
Dialogue: 0,0:11:37.67,0:11:39.87,*Default,NTP,0000,0000,0000,,尾调用是一个调用表达式
Dialogue: 0,0:11:40.20,0:11:42.30,*Default,NTP,0000,0000,0000,,在尾部上下文中
Dialogue: 0,0:11:42.87,0:11:44.80,*Default,NTP,0000,0000,0000,,什么是 tail 上下文
Dialogue: 0,0:11:45.37,0:11:46.80,*Default,NTP,0000,0000,0000,,有几种
Dialogue: 0,0:11:46.90,0:11:48.17,*Default,NTP,0000,0000,0000,,一个是最后一个
Dialogue: 0,0:11:48.17,0:11:51.00,*Default,NTP,0000,0000,0000,,子表达式
Dialogue: 0,0:11:51.80,0:11:54.07,*Default,NTP,0000,0000,0000,,原来 lambda 表达式
Dialogue: 0,0:11:54.07,0:11:55.20,*Default,NTP,0000,0000,0000,,可以有多个不同的
Dialogue: 0,0:11:55.20,0:11:56.73,*Default,NTP,0000,0000,0000,,体表达式
Dialogue: 0,0:11:56.73,0:11:59.93,*Default,NTP,0000,0000,0000,,最后一个是决定返回值的
Dialogue: 0,0:11:59.97,0:12:00.77,*Default,NTP,0000,0000,0000,,值的表达式
Dialogue: 0,0:12:01.27,0:12:04.80,*Default,NTP,0000,0000,0000,,因此该表达式处于尾部上下文中
Dialogue: 0,0:12:05.00,0:12:08.27,*Default,NTP,0000,0000,0000,,也就是说，它描述了该程序要做的最后一件事
Dialogue: 0,0:12:08.27,0:12:10.30,*Default,NTP,0000,0000,0000,,的描述。
Dialogue: 0,0:12:10.77,0:12:12.17,*Default,NTP,0000,0000,0000,,在返回之前
Dialogue: 0,0:12:15.37,0:12:16.93,*Default,NTP,0000,0000,0000,,此外
Dialogue: 0,0:12:17.37,0:12:20.70,*Default,NTP,0000,0000,0000,,您还可以将尾部调用作为子表达式
Dialogue: 0,0:12:20.70,0:12:25.60,*Default,NTP,0000,0000,0000,,尾部上下文中的两个或三个 if 表达式
Dialogue: 0,0:12:27.50,0:12:28.07,*Default,NTP,0000,0000,0000,,所以请记住
Dialogue: 0,0:12:28.07,0:12:31.13,*Default,NTP,0000,0000,0000,,if 表达式有三个子表达式
Dialogue: 0,0:12:31.13,0:12:32.20,*Default,NTP,0000,0000,0000,,结果
Dialogue: 0,0:12:32.33,0:12:33.53,*Default,NTP,0000,0000,0000,,和备选表达式
Dialogue: 0,0:12:33.90,0:12:37.53,*Default,NTP,0000,0000,0000,,这些结果和备选表达式是尾部上下文
Dialogue: 0,0:12:37.87,0:12:39.57,*Default,NTP,0000,0000,0000,,如果整个 if
Dialogue: 0,0:12:39.57,0:12:41.50,*Default,NTP,0000,0000,0000,,表达式处于尾语境中
Dialogue: 0,0:12:43.50,0:12:45.93,*Default,NTP,0000,0000,0000,,因此，让我们来看看这个阶乘定义
Dialogue: 0,0:12:47.13,0:12:50.07,*Default,NTP,0000,0000,0000,,最后一个正文子表达式
Dialogue: 0,0:12:50.13,0:12:52.20,*Default,NTP,0000,0000,0000,,在阶乘定义中
Dialogue: 0,0:12:52.57,0:12:53.80,*Default,NTP,0000,0000,0000,,是整个
Dialogue: 0,0:12:54.47,0:12:55.97,*Default,NTP,0000,0000,0000,,这是一个 if 表达式
Dialogue: 0,0:12:56.27,0:12:59.00,*Default,NTP,0000,0000,0000,,因此，这个 if 表达式处于尾部上下文中
Dialogue: 0,0:12:59.60,0:13:02.97,*Default,NTP,0000,0000,0000,,这意味着它的子表达式二和三
Dialogue: 0,0:13:03.20,0:13:05.47,*Default,NTP,0000,0000,0000,,也在尾部上下文中
Dialogue: 0,0:13:05.67,0:13:07.27,*Default,NTP,0000,0000,0000,,这就是这里的 k
Dialogue: 0,0:13:07.53,0:13:10.73,*Default,NTP,0000,0000,0000,,和这里的阶乘调用
Dialogue: 0,0:13:11.73,0:13:14.17,*Default,NTP,0000,0000,0000,,也是尾部上下文
Dialogue: 0,0:13:14.47,0:13:17.53,*Default,NTP,0000,0000,0000,,这是在尾部上下文中的调用表达式
Dialogue: 0,0:13:17.57,0:13:19.13,*Default,NTP,0000,0000,0000,,所以是尾部调用
Dialogue: 0,0:13:19.37,0:13:20.80,*Default,NTP,0000,0000,0000,,所以这种情况
Dialogue: 0,0:13:20.90,0:13:23.40,*Default,NTP,0000,0000,0000,,应该只需要一定的空间
Dialogue: 0,0:13:23.40,0:13:23.90,*Default,NTP,0000,0000,0000,,无论
Dialogue: 0,0:13:23.90,0:13:26.50,*Default,NTP,0000,0000,0000,,我们反复调用它多少次
Dialogue: 0,0:13:28.90,0:13:32.07,*Default,NTP,0000,0000,0000,,我们的想法是，一旦计算
Dialogue: 0,0:13:32.17,0:13:34.27,*Default,NTP,0000,0000,0000,,的
Dialogue: 0,0:13:34.50,0:13:35.30,*Default,NTP,0000,0000,0000,,你
Dialogue: 0,0:13:35.87,0:13:38.40,*Default,NTP,0000,0000,0000,,就已经完成了阶乘 mk 所需要做的所有工作。
Dialogue: 0,0:13:38.40,0:13:40.80,*Default,NTP,0000,0000,0000,,mk 所要做的就是返回它
Dialogue: 0,0:13:40.80,0:13:43.33,*Default,NTP,0000,0000,0000,,所以 n 和 kr 的值已经不重要了
Dialogue: 0,0:13:43.57,0:13:45.07,*Default,NTP,0000,0000,0000,,完成这些工作后
Dialogue: 0,0:13:47.33,0:13:49.40,*Default,NTP,0000,0000,0000,,现在还有其他尾部上下文
Dialogue: 0,0:13:49.67,0:13:53.20,*Default,NTP,0000,0000,0000,,所以尾语境中的所有非谓词子表达式
Dialogue: 0,0:13:53.30,0:13:55.90,*Default,NTP,0000,0000,0000,,您将在项目中阅读到的 con
Dialogue: 0,0:13:56.27,0:13:59.80,*Default,NTP,0000,0000,0000,,尾语境中的最后一个子表达式和 或 或 或
Dialogue: 0,0:14:00.17,0:14:02.97,*Default,NTP,0000,0000,0000,,和尾语境中的最后一个子表达式 begin
Dialogue: 0,0:14:04.17,0:14:06.93,*Default,NTP,0000,0000,0000,,这些并不重要，重要的是
Dialogue: 0,0:14:07.00,0:14:09.30,*Default,NTP,0000,0000,0000,,如果你真正坐下来编写
Dialogue: 0,0:14:09.47,0:14:10.57,*Default,NTP,0000,0000,0000,,计划程序
Dialogue: 0,0:14:10.57,0:14:12.77,*Default,NTP,0000,0000,0000,,你需要知道尾部上下文是什么
Dialogue: 0,0:14:12.77,0:14:13.67,*Default,NTP,0000,0000,0000,,以便知道
Dialogue: 0,0:14:13.70,0:14:16.87,*Default,NTP,0000,0000,0000,,程序的空间效率或空间使用情况
Dialogue: 0,0:14:16.90,0:14:17.90,*Default,NTP,0000,0000,0000,,空间使用率
Dialogue: 0,0:14:18.27,0:14:20.67,*Default,NTP,0000,0000,0000,,所以人们会花很多时间
Dialogue: 0,0:14:20.67,0:14:22.07,*Default,NTP,0000,0000,0000,,确保把所有的
Dialogue: 0,0:14:22.27,0:14:25.20,*Default,NTP,0000,0000,0000,,和尾部上下文。
Dialogue: 0,0:14:25.40,0:14:27.80,*Default,NTP,0000,0000,0000,,这样整个程序就不会占用太多空间
Dialogue: 0,0:14:28.60,0:14:30.90,*Default,NTP,0000,0000,0000,,但今天我们只关注前两种情况
Dialogue: 0,0:14:30.90,0:14:35.20,*Default,NTP,0000,0000,0000,,在 alamda 表达式中的最后一个正文子表达式或
Dialogue: 0,0:14:35.67,0:14:38.20,*Default,NTP,0000,0000,0000,,尾部上下文中的子表达式二和三
Dialogue: 0,0:14:38.20,0:14:39.30,*Default,NTP,0000,0000,0000,,如果表达式
Dialogue: 0,0:14:39.77,0:14:42.47,*Default,NTP,0000,0000,0000,,我们已经看过这两个例子了
Dialogue: 0,0:14:45.37,0:14:46.73,*Default,NTP,0000,0000,0000,,让我们再做一个例子
Dialogue: 0,0:14:46.90,0:14:48.60,*Default,NTP,0000,0000,0000,,计算列表长度
Dialogue: 0,0:14:49.60,0:14:52.27,*Default,NTP,0000,0000,0000,,调用表达式不是尾调用
Dialogue: 0,0:14:52.60,0:14:54.73,*Default,NTP,0000,0000,0000,,如果需要更多计算
Dialogue: 0,0:14:54.73,0:14:56.27,*Default,NTP,0000,0000,0000,,在调用过程中
Dialogue: 0,0:14:56.70,0:14:58.30,*Default,NTP,0000,0000,0000,,因此，如果我完成
Dialogue: 0,0:14:58.30,0:14:59.17,*Default,NTP,0000,0000,0000,,我的递归调用
Dialogue: 0,0:14:59.17,0:15:01.77,*Default,NTP,0000,0000,0000,,我仍然需要将该值与其他值结合起来
Dialogue: 0,0:15:01.93,0:15:03.57,*Default,NTP,0000,0000,0000,,那么我就没有尾调用
Dialogue: 0,0:15:04.57,0:15:07.37,*Default,NTP,0000,0000,0000,,但线性递归过程通常可以重写为
Dialogue: 0,0:15:07.37,0:15:08.57,*Default,NTP,0000,0000,0000,,通常可以重写
Dialogue: 0,0:15:08.57,0:15:09.80,*Default,NTP,0000,0000,0000,,使用尾调用
Dialogue: 0,0:15:12.00,0:15:13.07,*Default,NTP,0000,0000,0000,,所以这里有一个
Dialogue: 0,0:15:13.07,0:15:15.77,*Default,NTP,0000,0000,0000,,线性递归过程
Dialogue: 0,0:15:15.77,0:15:17.13,*Default,NTP,0000,0000,0000,,的线性递归过程
Dialogue: 0,0:15:17.70,0:15:18.73,*Default,NTP,0000,0000,0000,,说
Dialogue: 0,0:15:19.70,0:15:21.10,*Default,NTP,0000,0000,0000,,它认为 nullet 为零
Dialogue: 0,0:15:21.10,0:15:21.57,*Default,NTP,0000,0000,0000,,否则
Dialogue: 0,0:15:21.57,0:15:24.10,*Default,NTP,0000,0000,0000,,它比 s 的其余部分的长度多 1
Dialogue: 0,0:15:24.93,0:15:28.17,*Default,NTP,0000,0000,0000,,现在这是一个故事背景
Dialogue: 0,0:15:28.47,0:15:31.60,*Default,NTP,0000,0000,0000,,因为它是长度的最后一个表达式
Dialogue: 0,0:15:33.47,0:15:36.70,*Default,NTP,0000,0000,0000,,因为这是一个故事语境，而且是一个 if 表达式
Dialogue: 0,0:15:36.77,0:15:38.77,*Default,NTP,0000,0000,0000,,零和
Dialogue: 0,0:15:39.20,0:15:43.30,*Default,NTP,0000,0000,0000,,这里的另一个表达式都在故事上下文中
Dialogue: 0,0:15:44.57,0:15:45.30,*Default,NTP,0000,0000,0000,,所以这很好
Dialogue: 0,0:15:45.30,0:15:47.77,*Default,NTP,0000,0000,0000,,这是在尾部上下文中的调用表达式
Dialogue: 0,0:15:47.90,0:15:49.77,*Default,NTP,0000,0000,0000,,所以这个添加是尾部调用
Dialogue: 0,0:15:50.00,0:15:52.53,*Default,NTP,0000,0000,0000,,但这不是
Dialogue: 0,0:15:52.70,0:15:55.73,*Default,NTP,0000,0000,0000,,所以这是调用表达式中的调用表达式
Dialogue: 0,0:15:56.07,0:15:58.00,*Default,NTP,0000,0000,0000,,而这正是你知道自己不是
Dialogue: 0,0:15:58.00,0:15:59.37,*Default,NTP,0000,0000,0000,,在尾部上下文中
Dialogue: 0,0:16:00.20,0:16:03.47,*Default,NTP,0000,0000,0000,,在计算了 s 的其余部分的长度后
Dialogue: 0,0:16:03.47,0:16:06.37,*Default,NTP,0000,0000,0000,,我们仍有更多的工作要做，以增加一个
Dialogue: 0,0:16:06.93,0:16:10.27,*Default,NTP,0000,0000,0000,,现在我们还不知道还有什么工作要做
Dialogue: 0,0:16:10.67,0:16:11.53,*Default,NTP,0000,0000,0000,,所以
Dialogue: 0,0:16:11.73,0:16:14.57,*Default,NTP,0000,0000,0000,,例如，可能会有一个指向 s
Dialogue: 0,0:16:14.57,0:16:16.27,*Default,NTP,0000,0000,0000,,的引用，因此我们可能需要
Dialogue: 0,0:16:16.53,0:16:18.53,*Default,NTP,0000,0000,0000,,为这个函数调用
Dialogue: 0,0:16:18.53,0:16:20.50,*Default,NTP,0000,0000,0000,,因为还有更多的工作要做
Dialogue: 0,0:16:21.13,0:16:22.20,*Default,NTP,0000,0000,0000,,所以在这种情况下
Dialogue: 0,0:16:22.37,0:16:25.17,*Default,NTP,0000,0000,0000,,在这里实现 length 将需要
Dialogue: 0,0:16:25.47,0:16:28.93,*Default,NTP,0000,0000,0000,,需要线性空间来保存每次递归调用中所有的
Dialogue: 0,0:16:29.00,0:16:30.37,*Default,NTP,0000,0000,0000,,的所有帧都需要线性空间。
Dialogue: 0,0:16:31.17,0:16:33.70,*Default,NTP,0000,0000,0000,,但让我们看看能否重写 length，使其成为
Dialogue: 0,0:16:33.70,0:16:34.67,*Default,NTP,0000,0000,0000,,尾递归
Dialogue: 0,0:16:35.70,0:16:38.00,*Default,NTP,0000,0000,0000,,下面是一种常见的方法
Dialogue: 0,0:16:38.70,0:16:40.70,*Default,NTP,0000,0000,0000,,我们定义另一个存储过程
Dialogue: 0,0:16:41.00,0:16:43.87,*Default,NTP,0000,0000,0000,,length itter，它接收
Dialogue: 0,0:16:44.20,0:16:47.20,*Default,NTP,0000,0000,0000,,我们正在计算的列表
Dialogue: 0,0:16:47.30,0:16:50.60,*Default,NTP,0000,0000,0000,,以及我们目前计算出的长度，并且
Dialogue: 0,0:16:52.87,0:16:54.00,*Default,NTP,0000,0000,0000,,如果 s 为空
Dialogue: 0,0:16:54.07,0:16:57.10,*Default,NTP,0000,0000,0000,,那么我们就计算出了整个长度，并返回 in
Dialogue: 0,0:16:57.67,0:16:58.47,*Default,NTP,0000,0000,0000,,否则
Dialogue: 0,0:16:59.47,0:17:04.73,*Default,NTP,0000,0000,0000,,我们将返回对 s 的其余部分进行递归调用的值
Dialogue: 0,0:17:05.07,0:17:08.00,*Default,NTP,0000,0000,0000,,比我们目前看到的长度多一个
Dialogue: 0,0:17:09.07,0:17:11.80,*Default,NTP,0000,0000,0000,,所以一开始我们没有看到任何长度
Dialogue: 0,0:17:11.80,0:17:13.07,*Default,NTP,0000,0000,0000,,所以我们从 0 开始
Dialogue: 0,0:17:13.47,0:17:16.07,*Default,NTP,0000,0000,0000,,每进行一次递归调用，我们就增加一次
Dialogue: 0,0:17:16.37,0:17:17.50,*Default,NTP,0000,0000,0000,,直到最后
Dialogue: 0,0:17:17.57,0:17:19.30,*Default,NTP,0000,0000,0000,,然后我们计算出长度
Dialogue: 0,0:17:20.00,0:17:22.13,*Default,NTP,0000,0000,0000,,现在这个程序
Dialogue: 0,0:17:22.13,0:17:23.80,*Default,NTP,0000,0000,0000,,在行为上
Dialogue: 0,0:17:24.93,0:17:26.90,*Default,NTP,0000,0000,0000,,这是在尾部上下文中
Dialogue: 0,0:17:27.17,0:17:29.90,*Default,NTP,0000,0000,0000,,因为它是最后一个表达式
Dialogue: 0,0:17:30.27,0:17:33.00,*Default,NTP,0000,0000,0000,,或定义中的最后一个表达式
Dialogue: 0,0:17:34.47,0:17:36.07,*Default,NTP,0000,0000,0000,,为什么我一直称它为 lambda 表达式？
Dialogue: 0,0:17:36.07,0:17:37.37,*Default,NTP,0000,0000,0000,,定义
Dialogue: 0,0:17:37.53,0:17:40.93,*Default,NTP,0000,0000,0000,,隐含着一个 lambda 表达式。
Dialogue: 0,0:17:40.93,0:17:42.50,*Default,NTP,0000,0000,0000,,记住，这等同于说
Dialogue: 0,0:17:42.60,0:17:45.33,*Default,NTP,0000,0000,0000,,定义 length tail lambda s
Dialogue: 0,0:17:45.33,0:17:46.20,*Default,NTP,0000,0000,0000,,等等等等
Dialogue: 0,0:17:46.60,0:17:47.40,*Default,NTP,0000,0000,0000,,好吧
Dialogue: 0,0:17:48.40,0:17:50.73,*Default,NTP,0000,0000,0000,,所以这是在尾部上下文中
Dialogue: 0,0:17:51.70,0:17:54.93,*Default,NTP,0000,0000,0000,,这是在尾部上下文中，因为这是一个单独的
Dialogue: 0,0:17:54.97,0:17:56.00,*Default,NTP,0000,0000,0000,,存储过程定义
Dialogue: 0,0:17:56.00,0:17:58.30,*Default,NTP,0000,0000,0000,,而这是存储过程定义中的最后一项内容
Dialogue: 0,0:17:59.47,0:18:01.73,*Default,NTP,0000,0000,0000,,这意味着这是一个尾部上下文
Dialogue: 0,0:18:01.73,0:18:03.20,*Default,NTP,0000,0000,0000,,因为如果
Dialogue: 0,0:18:03.20,0:18:05.07,*Default,NTP,0000,0000,0000,,表达式
Dialogue: 0,0:18:05.17,0:18:07.90,*Default,NTP,0000,0000,0000,,那么它的替代表达式也是一个故事上下文
Dialogue: 0,0:18:08.27,0:18:10.77,*Default,NTP,0000,0000,0000,,这是在尾部上下文中的调用表达式
Dialogue: 0,0:18:10.77,0:18:12.17,*Default,NTP,0000,0000,0000,,这意味着这是一个尾调用
Dialogue: 0,0:18:12.60,0:18:14.53,*Default,NTP,0000,0000,0000,,这意味着整个程序只能在
Dialogue: 0,0:18:14.53,0:18:15.70,*Default,NTP,0000,0000,0000,,在恒定空间内运行
Dialogue: 0,0:18:16.13,0:18:18.57,*Default,NTP,0000,0000,0000,,现在，实际的列表本身需要一个混合空间
Dialogue: 0,0:18:18.57,0:18:20.07,*Default,NTP,0000,0000,0000,,但额外的
Dialogue: 0,0:18:20.10,0:18:22.13,*Default,NTP,0000,0000,0000,,用于计算长度的空间
Dialogue: 0,0:18:22.30,0:18:23.93,*Default,NTP,0000,0000,0000,,空间中没有一大堆帧
Dialogue: 0,0:18:23.93,0:18:25.20,*Default,NTP,0000,0000,0000,,而只有一个
Dialogue: 0,0:18:27.37,0:18:29.53,*Default,NTP,0000,0000,0000,,所以我把这个递归调用听成了一个故事调用
Dialogue: 0,0:18:29.60,0:18:31.73,*Default,NTP,0000,0000,0000,,或者说这个递归调用不是
Dialogue: 0,0:18:33.10,0:18:35.90,*Default,NTP,0000,0000,0000,,那么我如何让你相信这真的很重要呢？
Dialogue: 0,0:18:35.90,0:18:38.27,*Default,NTP,0000,0000,0000,,好吧，我们得做个演示
Dialogue: 0,0:18:38.60,0:18:41.47,*Default,NTP,0000,0000,0000,,所以，递归调用的返回值应该是
Dialogue: 0,0:18:41.87,0:18:44.53,*Default,NTP,0000,0000,0000,,就是当前过程调用的返回值
Dialogue: 0,0:18:44.97,0:18:46.67,*Default,NTP,0000,0000,0000,,这意味着我们可以跳过
Dialogue: 0,0:18:46.67,0:18:49.00,*Default,NTP,0000,0000,0000,,保留所有我们不需要的帧
Dialogue: 0,0:18:49.17,0:18:51.60,*Default,NTP,0000,0000,0000,,因为最后一帧的返回值
Dialogue: 0,0:18:51.80,0:18:54.30,*Default,NTP,0000,0000,0000,,可以直接返回到原始调用
Dialogue: 0,0:18:55.13,0:18:57.80,*Default,NTP,0000,0000,0000,,苍白调用不应增加环境大小
Dialogue: 0,0:18:58.07,0:18:59.27,*Default,NTP,0000,0000,0000,,我们可以看到
Dialogue: 0,0:18:59.37,0:19:02.40,*Default,NTP,0000,0000,0000,,通过在一个大输入上调用这个阶乘函数
Dialogue: 0,0:19:05.10,0:19:06.30,*Default,NTP,0000,0000,0000,,好了
Dialogue: 0,0:19:07.27,0:19:08.87,*Default,NTP,0000,0000,0000,,下面是派的方案
Dialogue: 0,0:19:09.50,0:19:11.30,*Default,NTP,0000,0000,0000,,是项目的一部分
Dialogue: 0,0:19:12.30,0:19:14.87,*Default,NTP,0000,0000,0000,,在你实现额外奖励的下方
Dialogue: 0,0:19:14.87,0:19:15.80,*Default,NTP,0000,0000,0000,,下面写着不常见
Dialogue: 0,0:19:15.80,0:19:16.77,*Default,NTP,0000,0000,0000,,下面一行
Dialogue: 0,0:19:16.87,0:19:18.87,*Default,NTP,0000,0000,0000,,应用尾部调用优化
Dialogue: 0,0:19:19.40,0:19:22.07,*Default,NTP,0000,0000,0000,,因此，如你所见，现在这一行已被注释掉了
Dialogue: 0,0:19:22.80,0:19:25.30,*Default,NTP,0000,0000,0000,,这意味着我们使用的只是普通的模式值
Dialogue: 0,0:19:25.73,0:19:28.67,*Default,NTP,0000,0000,0000,,并没有针对尾部调用进行优化
Dialogue: 0,0:19:28.73,0:19:30.77,*Default,NTP,0000,0000,0000,,因为我们还没有实现这部分
Dialogue: 0,0:19:30.77,0:19:31.97,*Default,NTP,0000,0000,0000,,这是额外奖励
Dialogue: 0,0:19:32.60,0:19:33.80,*Default,NTP,0000,0000,0000,,好了，让我们
Dialogue: 0,0:19:34.57,0:19:37.37,*Default,NTP,0000,0000,0000,,定义一个返回
Dialogue: 0,0:19:38.80,0:19:40.47,*Default,NTP,0000,0000,0000,,阶乘 k
Dialogue: 0,0:19:41.73,0:19:46.07,*Default,NTP,0000,0000,0000,,定义 n 和 k 的阶乘
Dialogue: 0,0:19:47.10,0:19:47.90,*Default,NTP,0000,0000,0000,,如果
Dialogue: 0,0:19:50.67,0:19:53.37,*Default,NTP,0000,0000,0000,,n 为零，我们只返回 k
Dialogue: 0,0:19:54.57,0:19:57.87,*Default,NTP,0000,0000,0000,,否则我们将返回
Dialogue: 0,0:19:58.77,0:20:00.47,*Default,NTP,0000,0000,0000,,的
Dialogue: 0,0:20:01.53,0:20:02.53,*Default,NTP,0000,0000,0000,,和
Dialogue: 0,0:20:03.37,0:20:04.57,*Default,NTP,0000,0000,0000,,k乘以它
Dialogue: 0,0:20:06.70,0:20:08.30,*Default,NTP,0000,0000,0000,,好了，我们现在是什么状态
Dialogue: 0,0:20:08.30,0:20:10.53,*Default,NTP,0000,0000,0000,,我们有一个尾递归函数
Dialogue: 0,0:20:10.53,0:20:11.87,*Default,NTP,0000,0000,0000,,我们已经分析过了
Dialogue: 0,0:20:11.87,0:20:14.70,*Default,NTP,0000,0000,0000,,这是一个尾部上下文，所以这是一个尾部上下文
Dialogue: 0,0:20:15.30,0:20:16.67,*Default,NTP,0000,0000,0000,,我们有一个解释器
Dialogue: 0,0:20:17.17,0:20:20.47,*Default,NTP,0000,0000,0000,,并没有针对尾部调用进行优化
Dialogue: 0,0:20:21.53,0:20:23.50,*Default,NTP,0000,0000,0000,,所以它会创建一个框架
Dialogue: 0,0:20:23.67,0:20:25.60,*Default,NTP,0000,0000,0000,,每次我们进行递归调用
Dialogue: 0,0:20:25.70,0:20:28.37,*Default,NTP,0000,0000,0000,,这个框架就会一直存在，直到
Dialogue: 0,0:20:29.53,0:20:31.37,*Default,NTP,0000,0000,0000,,我们从调用中返回
Dialogue: 0,0:20:31.57,0:20:34.13,*Default,NTP,0000,0000,0000,,这将占用大量的线性空间
Dialogue: 0,0:20:34.87,0:20:36.97,*Default,NTP,0000,0000,0000,,这意味着如果我们运行 scheme dot pi
Dialogue: 0,0:20:37.33,0:20:39.30,*Default,NTP,0000,0000,0000,,并加载这个阶乘
Dialogue: 0,0:20:39.70,0:20:42.30,*Default,NTP,0000,0000,0000,,我们可以计算 10 的阶乘
Dialogue: 0,0:20:44.67,0:20:47.47,*Default,NTP,0000,0000,0000,,我们可以计算 100 的阶乘
Dialogue: 0,0:20:48.07,0:20:50.97,*Default,NTP,0000,0000,0000,,如果我们计算 1000 的阶乘呢？
Dialogue: 0,0:20:51.10,0:20:52.87,*Default,NTP,0000,0000,0000,,我们会出错
Dialogue: 0,0:20:53.07,0:20:55.57,*Default,NTP,0000,0000,0000,,显示已超出最大递归和深度
Dialogue: 0,0:20:55.57,0:20:57.07,*Default,NTP,0000,0000,0000,,调用 python 对象时
Dialogue: 0,0:20:57.60,0:21:00.07,*Default,NTP,0000,0000,0000,,那么是怎么回事呢？
Dialogue: 0,0:21:00.07,0:21:03.67,*Default,NTP,0000,0000,0000,,到计算 673 的阶乘
Dialogue: 0,0:21:04.10,0:21:05.47,*Default,NTP,0000,0000,0000,,然后就放弃了
Dialogue: 0,0:21:05.47,0:21:08.20,*Default,NTP,0000,0000,0000,,因为它进行了太多的递归调用
Dialogue: 0,0:21:08.47,0:21:10.50,*Default,NTP,0000,0000,0000,,占用了太多内存
Dialogue: 0,0:21:10.50,0:21:13.47,*Default,NTP,0000,0000,0000,,于是 python 说，对不起，你已经达到极限了
Dialogue: 0,0:21:13.50,0:21:14.30,*Default,NTP,0000,0000,0000,,我们完成了
Dialogue: 0,0:21:15.73,0:21:16.93,*Default,NTP,0000,0000,0000,,这很不幸
Dialogue: 0,0:21:16.97,0:21:18.87,*Default,NTP,0000,0000,0000,,因为我们应该可以
Dialogue: 0,0:21:18.90,0:21:20.53,*Default,NTP,0000,0000,0000,,想计算多少就计算多少
Dialogue: 0,0:21:20.53,0:21:22.37,*Default,NTP,0000,0000,0000,,使用恒定的空间
Dialogue: 0,0:21:23.20,0:21:25.70,*Default,NTP,0000,0000,0000,,所以我有一个额外加分的实现
Dialogue: 0,0:21:25.90,0:21:29.00,*Default,NTP,0000,0000,0000,,的实现，它只是说使用一个不同的求值函数
Dialogue: 0,0:21:29.30,0:21:30.33,*Default,NTP,0000,0000,0000,,一个
Dialogue: 0,0:21:30.33,0:21:33.30,*Default,NTP,0000,0000,0000,,在不需要的情况下不创建额外帧的函数
Dialogue: 0,0:21:34.93,0:21:36.80,*Default,NTP,0000,0000,0000,,让我们再次运行
Dialogue: 0,0:21:37.67,0:21:40.53,*Default,NTP,0000,0000,0000,,加载阶乘函数
Dialogue: 0,0:21:41.33,0:21:44.33,*Default,NTP,0000,0000,0000,,如果我计算 10 的阶乘，它运行正常
Dialogue: 0,0:21:44.40,0:21:46.13,*Default,NTP,0000,0000,0000,,100 计算正常
Dialogue: 0,0:21:46.33,0:21:48.70,*Default,NTP,0000,0000,0000,,1000 也运行正常
Dialogue: 0,0:21:49.37,0:21:51.93,*Default,NTP,0000,0000,0000,,如果我计算 10,000 的阶乘
Dialogue: 0,0:21:51.97,0:21:53.40,*Default,NTP,0000,0000,0000,,当然要花点时间
Dialogue: 0,0:21:53.40,0:21:55.40,*Default,NTP,0000,0000,0000,,我并没有真正加快速度
Dialogue: 0,0:21:55.57,0:21:58.40,*Default,NTP,0000,0000,0000,,但我节省了额外的空间
Dialogue: 0,0:21:59.00,0:22:03.77,*Default,NTP,0000,0000,0000,,所以我们计算了这个巨大的 10,000 次阶乘
Dialogue: 0,0:22:04.73,0:22:08.07,*Default,NTP,0000,0000,0000,,现在，这个程序最终会耗尽空间
Dialogue: 0,0:22:08.07,0:22:10.73,*Default,NTP,0000,0000,0000,,不是因为我们创建了额外的帧，而是因为
Dialogue: 0,0:22:11.00,0:22:12.17,*Default,NTP,0000,0000,0000,,表示这个
Dialogue: 0,0:22:12.17,0:22:13.67,*Default,NTP,0000,0000,0000,,会变得太大
Dialogue: 0,0:22:13.67,0:22:15.20,*Default,NTP,0000,0000,0000,,因为它有太多的数字
Dialogue: 0,0:22:15.20,0:22:17.00,*Default,NTP,0000,0000,0000,,但这需要很长时间
Dialogue: 0,0:22:17.40,0:22:21.40,*Default,NTP,0000,0000,0000,,因此，我们用尾部反卷积法非常高效地计算了 10,000 的阶乘
Dialogue: 0,0:22:21.87,0:22:24.13,*Default,NTP,0000,0000,0000,,使用游标尾数
Dialogue: 0,0:22:24.13,0:22:25.07,*Default,NTP,0000,0000,0000,,来确保
Dialogue: 0,0:22:25.10,0:22:27.70,*Default,NTP,0000,0000,0000,,我们不使用任何不需要使用的空间
Dialogue: 0,0:22:31.07,0:22:32.80,*Default,NTP,0000,0000,0000,,让我们来看一些
Dialogue: 0,0:22:33.40,0:22:34.90,*Default,NTP,0000,0000,0000,,尾部递归
Dialogue: 0,0:22:35.77,0:22:37.33,*Default,NTP,0000,0000,0000,,你的任务是
Dialogue: 0,0:22:37.47,0:22:40.87,*Default,NTP,0000,0000,0000,,找出下面定义的四个存储过程中
Dialogue: 0,0:22:41.37,0:22:43.37,*Default,NTP,0000,0000,0000,,是尾递归的
Dialogue: 0,0:22:43.80,0:22:46.67,*Default,NTP,0000,0000,0000,,要使递归函数具有尾递归性
Dialogue: 0,0:22:46.67,0:22:48.20,*Default,NTP,0000,0000,0000,,我的意思是
Dialogue: 0,0:22:48.93,0:22:51.97,*Default,NTP,0000,0000,0000,,所有递归调用都是尾调用
Dialogue: 0,0:22:52.33,0:22:53.50,*Default,NTP,0000,0000,0000,,因此
Dialogue: 0,0:22:53.80,0:22:57.73,*Default,NTP,0000,0000,0000,,存储过程将在恒定空间内执行
Dialogue: 0,0:22:57.73,0:22:59.90,*Default,NTP,0000,0000,0000,,那么下面哪个程序运行
Dialogue: 0,0:22:59.90,0:23:01.30,*Default,NTP,0000,0000,0000,,在恒定空间内运行
Dialogue: 0,0:23:02.20,0:23:03.50,*Default,NTP,0000,0000,0000,,自己看一下
Dialogue: 0,0:23:03.73,0:23:05.47,*Default,NTP,0000,0000,0000,,然后我会给出答案
Dialogue: 0,0:23:07.53,0:23:09.37,*Default,NTP,0000,0000,0000,,首先来看 length
Dialogue: 0,0:23:10.10,0:23:11.67,*Default,NTP,0000,0000,0000,,这里定义的 length
Dialogue: 0,0:23:12.10,0:23:15.10,*Default,NTP,0000,0000,0000,,不是尾递归的
Dialogue: 0,0:23:15.30,0:23:16.87,*Default,NTP,0000,0000,0000,,存储过程定义中的最后表达式
Dialogue: 0,0:23:17.30,0:23:19.10,*Default,NTP,0000,0000,0000,,在存储过程定义中
Dialogue: 0,0:23:19.73,0:23:21.53,*Default,NTP,0000,0000,0000,,是尾部上下文
Dialogue: 0,0:23:21.90,0:23:24.30,*Default,NTP,0000,0000,0000,,但它的子表达式不是
Dialogue: 0,0:23:24.57,0:23:25.70,*Default,NTP,0000,0000,0000,,所以特别是
Dialogue: 0,0:23:26.13,0:23:28.87,*Default,NTP,0000,0000,0000,,这个 if 表达式不在尾部上下文中
Dialogue: 0,0:23:29.77,0:23:31.80,*Default,NTP,0000,0000,0000,,和
Dialogue: 0,0:23:32.17,0:23:35.07,*Default,NTP,0000,0000,0000,,的结果表达式和备选子表达式
Dialogue: 0,0:23:35.53,0:23:36.93,*Default,NTP,0000,0000,0000,,的结果表达式和备选子表达式处于尾部上下文中
Dialogue: 0,0:23:36.93,0:23:39.87,*Default,NTP,0000,0000,0000,,只有当整个 if 都处于尾部上下文时才有效
Dialogue: 0,0:23:39.87,0:23:41.60,*Default,NTP,0000,0000,0000,,所以这也不是
Dialogue: 0,0:23:42.17,0:23:43.90,*Default,NTP,0000,0000,0000,,这意味着
Dialogue: 0,0:23:44.33,0:23:47.33,*Default,NTP,0000,0000,0000,,在这里计算长度将需要
Dialogue: 0,0:23:47.33,0:23:48.93,*Default,NTP,0000,0000,0000,,的线性空间。
Dialogue: 0,0:23:50.13,0:23:52.10,*Default,NTP,0000,0000,0000,,接下来让我们看看 contains
Dialogue: 0,0:23:53.37,0:23:55.40,*Default,NTP,0000,0000,0000,,包含
Dialogue: 0,0:23:55.47,0:23:58.47,*Default,NTP,0000,0000,0000,,是尾部递归的，因为递归调用
Dialogue: 0,0:23:58.50,0:24:00.90,*Default,NTP,0000,0000,0000,,的递归调用是在尾部上下文中进行的
Dialogue: 0,0:24:01.37,0:24:04.97,*Default,NTP,0000,0000,0000,,这是尾部上下文，因为它是存储过程定义中的最后一个表达式
Dialogue: 0,0:24:05.17,0:24:06.77,*Default,NTP,0000,0000,0000,,在存储过程定义中
Dialogue: 0,0:24:07.57,0:24:09.47,*Default,NTP,0000,0000,0000,,这是尾部上下文，因为它是存储过程定义中的最后一个表达式
Dialogue: 0,0:24:09.60,0:24:11.70,*Default,NTP,0000,0000,0000,,因为它是 if 表达式中的第二个或第三个
Dialogue: 0,0:24:12.07,0:24:14.47,*Default,NTP,0000,0000,0000,,子表达式之一
Dialogue: 0,0:24:14.47,0:24:15.90,*Default,NTP,0000,0000,0000,,的第二个或第三个子表达式之一
Dialogue: 0,0:24:16.13,0:24:18.77,*Default,NTP,0000,0000,0000,,因此这也是一个故事上下文
Dialogue: 0,0:24:18.77,0:24:20.40,*Default,NTP,0000,0000,0000,,这就是递归调用
Dialogue: 0,0:24:21.07,0:24:24.10,*Default,NTP,0000,0000,0000,,因此，"包含 "将接收线性大小的内容
Dialogue: 0,0:24:24.10,0:24:25.73,*Default,NTP,0000,0000,0000,,因为 s 是一个 list
Dialogue: 0,0:24:25.97,0:24:26.77,*Default,NTP,0000,0000,0000,,但
Dialogue: 0,0:24:27.27,0:24:30.17,*Default,NTP,0000,0000,0000,,但
Dialogue: 0,0:24:30.20,0:24:34.00,*Default,NTP,0000,0000,0000,,调用 contains 所需的额外空间是恒定的
Dialogue: 0,0:24:35.73,0:24:37.27,*Default,NTP,0000,0000,0000,,那么 has repeat 呢？
Dialogue: 0,0:24:38.10,0:24:38.57,*Default,NTP,0000,0000,0000,,那么
Dialogue: 0,0:24:38.57,0:24:42.50,*Default,NTP,0000,0000,0000,,has repeat 的结构与 contains 完全相同
Dialogue: 0,0:24:43.37,0:24:44.97,*Default,NTP,0000,0000,0000,,所以有重复作为一个函数
Dialogue: 0,0:24:45.13,0:24:48.20,*Default,NTP,0000,0000,0000,,函数，它能找出 s 是否有重复元素
Dialogue: 0,0:24:48.33,0:24:51.47,*Default,NTP,0000,0000,0000,,并通过调用 contains
Dialogue: 0,0:24:51.90,0:24:53.13,*Default,NTP,0000,0000,0000,,所以整个
Dialogue: 0,0:24:53.37,0:24:56.87,*Default,NTP,0000,0000,0000,,表达式，也就是这个存储过程的主体
Dialogue: 0,0:24:57.37,0:24:58.93,*Default,NTP,0000,0000,0000,,是在尾部上下文中
Dialogue: 0,0:25:00.67,0:25:02.77,*Default,NTP,0000,0000,0000,,这意味着这是在尾部上下文中
Dialogue: 0,0:25:03.27,0:25:04.77,*Default,NTP,0000,0000,0000,,这意味着这是两个
Dialogue: 0,0:25:05.40,0:25:07.77,*Default,NTP,0000,0000,0000,,所以整个过程在恒定空间内运行
Dialogue: 0,0:25:08.53,0:25:09.60,*Default,NTP,0000,0000,0000,,顺便说一句
Dialogue: 0,0:25:09.77,0:25:13.73,*Default,NTP,0000,0000,0000,,当它调用 contains 时，并非尾部上下文
Dialogue: 0,0:25:13.90,0:25:18.47,*Default,NTP,0000,0000,0000,,但由于 contains 已经在常量空间中运行
Dialogue: 0,0:25:18.80,0:25:21.60,*Default,NTP,0000,0000,0000,,因为它本身就是尾递归的
Dialogue: 0,0:25:21.97,0:25:23.17,*Default,NTP,0000,0000,0000,,我们不必担心
Dialogue: 0,0:25:23.17,0:25:25.10,*Default,NTP,0000,0000,0000,,占用大量路由
Dialogue: 0,0:25:27.33,0:25:29.33,*Default,NTP,0000,0000,0000,,最后，我们有一个过程
Dialogue: 0,0:25:29.33,0:25:31.30,*Default,NTP,0000,0000,0000,,来计算斐波那契尾数
Dialogue: 0,0:25:31.90,0:25:33.90,*Default,NTP,0000,0000,0000,,让我们看看它是如何工作的
Dialogue: 0,0:25:34.30,0:25:37.77,*Default,NTP,0000,0000,0000,,fit bitter 取当前的斐波纳契数
Dialogue: 0,0:25:37.77,0:25:39.50,*Default,NTP,0000,0000,0000,,即斐波那契数字 k
Dialogue: 0,0:25:40.17,0:25:41.80,*Default,NTP,0000,0000,0000,,如果我们一直计算到第 n 个数
Dialogue: 0,0:25:41.80,0:25:43.27,*Default,NTP,0000,0000,0000,,也就是我们要找的数
Dialogue: 0,0:25:43.40,0:25:44.70,*Default,NTP,0000,0000,0000,,则返回当前
Dialogue: 0,0:25:44.70,0:25:47.07,*Default,NTP,0000,0000,0000,,否则，我们调用 phil bitter
Dialogue: 0,0:25:48.17,0:25:52.50,*Default,NTP,0000,0000,0000,,在当前数加上 k 减一的斐波纳契数上
Dialogue: 0,0:25:53.60,0:25:55.87,*Default,NTP,0000,0000,0000,,当我们这样做时，k 会递增
Dialogue: 0,0:25:56.27,0:25:57.70,*Default,NTP,0000,0000,0000,,所以一开始
Dialogue: 0,0:25:58.67,0:25:59.73,*Default,NTP,0000,0000,0000,,我们检查
Dialogue: 0,0:26:00.00,0:26:01.87,*Default,NTP,0000,0000,0000,,如果我们只是在找第一个数
Dialogue: 0,0:26:01.87,0:26:04.97,*Default,NTP,0000,0000,0000,,那么我们就返回 0，否则我们就调用斐波那契数字
Dialogue: 0,0:26:05.93,0:26:08.90,*Default,NTP,0000,0000,0000,,从第二个斐波那契数字开始，也就是 1
Dialogue: 0,0:26:10.33,0:26:12.07,*Default,NTP,0000,0000,0000,,所以这是一个尾部上下文
Dialogue: 0,0:26:12.10,0:26:13.77,*Default,NTP,0000,0000,0000,,所以这是一个尾部上下文
Dialogue: 0,0:26:13.77,0:26:14.90,*Default,NTP,0000,0000,0000,,到目前为止一切顺利
Dialogue: 0,0:26:15.17,0:26:17.07,*Default,NTP,0000,0000,0000,,这整个就是一个尾部上下文
Dialogue: 0,0:26:17.10,0:26:18.27,*Default,NTP,0000,0000,0000,,这就是
Dialogue: 0,0:26:18.37,0:26:20.27,*Default,NTP,0000,0000,0000,,所以这个递归调用没有问题
Dialogue: 0,0:26:20.53,0:26:23.70,*Default,NTP,0000,0000,0000,,但问题是调用的子表达式
Dialogue: 0,0:26:23.70,0:26:26.50,*Default,NTP,0000,0000,0000,,表达式不是尾语境
Dialogue: 0,0:26:27.00,0:26:28.93,*Default,NTP,0000,0000,0000,,所以这不是尾部调用
Dialogue: 0,0:26:29.00,0:26:31.73,*Default,NTP,0000,0000,0000,,它是对 fip 的递归函数调用
Dialogue: 0,0:26:32.37,0:26:33.70,*Default,NTP,0000,0000,0000,,的递归函数调用
Dialogue: 0,0:26:33.97,0:26:36.50,*Default,NTP,0000,0000,0000,,无法在恒定空间内运行
Dialogue: 0,0:26:36.57,0:26:38.40,*Default,NTP,0000,0000,0000,,因为它进行了递归调用
Dialogue: 0,0:26:38.60,0:26:41.47,*Default,NTP,0000,0000,0000,,尽管我们有两个相互递归的函数
Dialogue: 0,0:26:41.77,0:26:44.73,*Default,NTP,0000,0000,0000,,和 fib iter 要在恒定空间内运行
Dialogue: 0,0:26:44.73,0:26:46.07,*Default,NTP,0000,0000,0000,,都必须
Dialogue: 0,0:26:46.17,0:26:47.97,*Default,NTP,0000,0000,0000,,尾调用对方
Dialogue: 0,0:26:48.40,0:26:49.13,*Default,NTP,0000,0000,0000,,而在这种情况下
Dialogue: 0,0:26:49.13,0:26:50.70,*Default,NTP,0000,0000,0000,,我们有一个不是尾调用的东西
Dialogue: 0,0:26:50.70,0:26:52.10,*Default,NTP,0000,0000,0000,,还有更多工作要做
Dialogue: 0,0:26:52.27,0:26:53.57,*Default,NTP,0000,0000,0000,,只要我们找出
Dialogue: 0,0:26:53.57,0:26:55.30,*Default,NTP,0000,0000,0000,,减一的斐波纳契数
Dialogue: 0,0:26:55.30,0:26:57.20,*Default,NTP,0000,0000,0000,,我们还必须将它与当前的
Dialogue: 0,0:26:57.30,0:26:58.33,*Default,NTP,0000,0000,0000,,以完成
Dialogue: 0,0:26:58.53,0:27:00.77,*Default,NTP,0000,0000,0000,,然后在此基础上调用 fi bitter
Dialogue: 0,0:27:03.73,0:27:06.77,*Default,NTP,0000,0000,0000,,接下来我们来看看两个高阶函数
Dialogue: 0,0:27:07.07,0:27:08.50,*Default,NTP,0000,0000,0000,,map 和 reduce
Dialogue: 0,0:27:09.40,0:27:11.10,*Default,NTP,0000,0000,0000,,让我们先看看 reduce
Dialogue: 0,0:27:11.90,0:27:12.87,*Default,NTP,0000,0000,0000,,还原一个
Dialogue: 0,0:27:13.57,0:27:15.57,*Default,NTP,0000,0000,0000,,过程，该过程需要另一个过程
Dialogue: 0,0:27:16.27,0:27:20.10,*Default,NTP,0000,0000,0000,,我们要添加的列表 s
Dialogue: 0,0:27:20.57,0:27:22.17,*Default,NTP,0000,0000,0000,,和一个起始值
Dialogue: 0,0:27:22.53,0:27:23.33,*Default,NTP,0000,0000,0000,,它的作用是
Dialogue: 0,0:27:23.33,0:27:25.90,*Default,NTP,0000,0000,0000,,将起始值与列表中的第一个元素结合起来
Dialogue: 0,0:27:25.90,0:27:29.80,*Default,NTP,0000,0000,0000,,的第一个元素结合起来，并将结果与第二个元素结合起来，等等。
Dialogue: 0,0:27:29.80,0:27:31.70,*Default,NTP,0000,0000,0000,,使用过程将它们结合起来
Dialogue: 0,0:27:32.47,0:27:33.67,*Default,NTP,0000,0000,0000,,因此，如果我们将
Dialogue: 0,0:27:33.90,0:27:36.67,*Default,NTP,0000,0000,0000,,什么是向上乘法过程
Dialogue: 0,0:27:36.90,0:27:38.33,*Default,NTP,0000,0000,0000,,列表 3 4 5
Dialogue: 0,0:27:38.33,0:27:39.17,*Default,NTP,0000,0000,0000,,从 2 开始
Dialogue: 0,0:27:39.17,0:27:40.40,*Default,NTP,0000,0000,0000,,那么我们将得到 2 乘以 3 乘以 4
Dialogue: 0,0:27:40.40,0:27:41.97,*Default,NTP,0000,0000,0000,,5 乘以 120
Dialogue: 0,0:27:42.30,0:27:43.67,*Default,NTP,0000,0000,0000,,如果我们用
Dialogue: 0,0:27:44.37,0:27:45.70,*Default,NTP,0000,0000,0000,,使用一个程序
Dialogue: 0,0:27:45.90,0:27:49.30,*Default,NTP,0000,0000,0000,,将两件事情合并起来
Dialogue: 0,0:27:49.50,0:27:50.93,*Default,NTP,0000,0000,0000,,为什么先
Dialogue: 0,0:27:51.53,0:27:54.70,*Default,NTP,0000,0000,0000,,的起始值包含两个
Dialogue: 0,0:27:54.70,0:27:56.37,*Default,NTP,0000,0000,0000,,然后对三
Dialogue: 0,0:27:56.53,0:27:58.30,*Default,NTP,0000,0000,0000,,然后将四与之对应
Dialogue: 0,0:27:58.30,0:28:00.07,*Default,NTP,0000,0000,0000,,然后再将五与之对应
Dialogue: 0,0:28:00.37,0:28:02.40,*Default,NTP,0000,0000,0000,,在列表中输入一个数字
Dialogue: 0,0:28:02.40,0:28:04.70,*Default,NTP,0000,0000,0000,,就会得到一个更长的列表，其中数字在前
Dialogue: 0,0:28:04.87,0:28:08.13,*Default,NTP,0000,0000,0000,,所以整个结果将是 5 4 3 2
Dialogue: 0,0:28:11.27,0:28:13.33,*Default,NTP,0000,0000,0000,,好的，让我们看看定义
Dialogue: 0,0:28:13.67,0:28:16.97,*Default,NTP,0000,0000,0000,,如果 s 为空，我们就使用这个起始值
Dialogue: 0,0:28:17.67,0:28:20.93,*Default,NTP,0000,0000,0000,,否则，我们将使用程序
Dialogue: 0,0:28:21.67,0:28:23.00,*Default,NTP,0000,0000,0000,,的其余部分
Dialogue: 0,0:28:24.80,0:28:28.33,*Default,NTP,0000,0000,0000,,我们需要创建一个新的起始值
Dialogue: 0,0:28:28.77,0:28:29.70,*Default,NTP,0000,0000,0000,,也就是
Dialogue: 0,0:28:30.47,0:28:32.30,*Default,NTP,0000,0000,0000,,传入的存储过程
Dialogue: 0,0:28:32.47,0:28:34.80,*Default,NTP,0000,0000,0000,,调用之前的起始值
Dialogue: 0,0:28:35.53,0:28:38.00,*Default,NTP,0000,0000,0000,,和 s 的第一个元素
Dialogue: 0,0:28:39.00,0:28:42.20,*Default,NTP,0000,0000,0000,,的第一个元素时调用的存储过程。
Dialogue: 0,0:28:42.20,0:28:43.97,*Default,NTP,0000,0000,0000,,已经包括
Dialogue: 0,0:28:44.07,0:28:46.07,*Default,NTP,0000,0000,0000,,不仅包括我们之前的起始值
Dialogue: 0,0:28:46.30,0:28:48.33,*Default,NTP,0000,0000,0000,,和 s 的第一个元素
Dialogue: 0,0:28:49.20,0:28:51.97,*Default,NTP,0000,0000,0000,,所以在这种情况下，我们将以两个
Dialogue: 0,0:28:52.37,0:28:54.60,*Default,NTP,0000,0000,0000,,但在下一次递归调用 reduce
Dialogue: 0,0:28:54.60,0:28:56.33,*Default,NTP,0000,0000,0000,,的下一次递归调用
Dialogue: 0,0:28:56.73,0:28:58.07,*Default,NTP,0000,0000,0000,,之后的下一次
Dialogue: 0,0:28:58.07,0:29:00.20,*Default,NTP,0000,0000,0000,,我们将乘以 4 得到 24
Dialogue: 0,0:29:00.20,0:29:02.00,*Default,NTP,0000,0000,0000,,最终得到 120
Dialogue: 0,0:29:03.27,0:29:04.47,*Default,NTP,0000,0000,0000,,让我们来看看
Dialogue: 0,0:29:04.80,0:29:07.07,*Default,NTP,0000,0000,0000,,这是一个尾部上下文
Dialogue: 0,0:29:07.20,0:29:09.37,*Default,NTP,0000,0000,0000,,这意味着这是一个尾部上下文
Dialogue: 0,0:29:10.53,0:29:11.77,*Default,NTP,0000,0000,0000,,但这不是
Dialogue: 0,0:29:12.27,0:29:14.53,*Default,NTP,0000,0000,0000,,那么整个过程是否在恒定时间内运行呢？
Dialogue: 0,0:29:14.90,0:29:17.90,*Default,NTP,0000,0000,0000,,这取决于存储过程做了什么
Dialogue: 0,0:29:20.00,0:29:23.17,*Default,NTP,0000,0000,0000,,所以对 reduce 的递归调用是尾调用
Dialogue: 0,0:29:23.97,0:29:25.27,*Default,NTP,0000,0000,0000,,但其他调用
Dialogue: 0,0:29:25.53,0:29:27.90,*Default,NTP,0000,0000,0000,,特别是过程调用不是
Dialogue: 0,0:29:28.37,0:29:29.97,*Default,NTP,0000,0000,0000,,这是一个高阶函数
Dialogue: 0,0:29:29.97,0:29:32.13,*Default,NTP,0000,0000,0000,,所以我们不知道会传入什么存储过程
Dialogue: 0,0:29:32.47,0:29:35.73,*Default,NTP,0000,0000,0000,,所以 reduce 的总空间取决于
Dialogue: 0,0:29:35.93,0:29:39.13,*Default,NTP,0000,0000,0000,,存储过程是否需要恒定空间
Dialogue: 0,0:29:39.77,0:29:41.70,*Default,NTP,0000,0000,0000,,希望它只需要恒定空间
Dialogue: 0,0:29:41.70,0:29:44.17,*Default,NTP,0000,0000,0000,,在这种情况下，整个还原过程只需要
Dialogue: 0,0:29:44.17,0:29:45.10,*Default,NTP,0000,0000,0000,,恒定空间
Dialogue: 0,0:29:47.27,0:29:48.67,*Default,NTP,0000,0000,0000,,好了，现在我们来谈谈
Dialogue: 0,0:29:48.67,0:29:51.37,*Default,NTP,0000,0000,0000,,如何只使用恒定帧数进行映射
Dialogue: 0,0:29:53.13,0:29:55.57,*Default,NTP,0000,0000,0000,,map 是一个函数，它将一个过程
Dialogue: 0,0:29:56.00,0:29:59.10,*Default,NTP,0000,0000,0000,,并构造一个包含所有结果的列表的函数。
Dialogue: 0,0:29:59.17,0:30:01.10,*Default,NTP,0000,0000,0000,,包含所有结果
Dialogue: 0,0:30:02.40,0:30:02.93,*Default,NTP,0000,0000,0000,,那么
Dialogue: 0,0:30:02.93,0:30:06.07,*Default,NTP,0000,0000,0000,,让我们用最自然的方式来定义
Dialogue: 0,0:30:06.07,0:30:06.60,*Default,NTP,0000,0000,0000,,map
Dialogue: 0,0:30:06.60,0:30:09.53,*Default,NTP,0000,0000,0000,,的最自然的版本，然后我们再提出一个尾部递归的版本
Dialogue: 0,0:30:09.70,0:30:12.13,*Default,NTP,0000,0000,0000,,所以定义
Dialogue: 0,0:30:12.13,0:30:13.80,*Default,NTP,0000,0000,0000,,map 的自然方法是，我们在一个过程
Dialogue: 0,0:30:13.80,0:30:14.87,*Default,NTP,0000,0000,0000,,列表测试
Dialogue: 0,0:30:15.53,0:30:18.00,*Default,NTP,0000,0000,0000,,如果现在是 s，则返回空列表
Dialogue: 0,0:30:18.30,0:30:19.10,*Default,NTP,0000,0000,0000,,否则
Dialogue: 0,0:30:19.37,0:30:22.60,*Default,NTP,0000,0000,0000,,我们将创建一个新的列表，其第一个元素
Dialogue: 0,0:30:23.60,0:30:26.50,*Default,NTP,0000,0000,0000,,是我们将存储过程
Dialogue: 0,0:30:26.77,0:30:29.73,*Default,NTP,0000,0000,0000,,到 s 的第一个元素，然后将这个结果的其余部分应用到
Dialogue: 0,0:30:30.33,0:30:33.50,*Default,NTP,0000,0000,0000,,然后这个结果的其余部分
Dialogue: 0,0:30:33.73,0:30:34.70,*Default,NTP,0000,0000,0000,,将是
Dialogue: 0,0:30:34.70,0:30:37.60,*Default,NTP,0000,0000,0000,,将存储过程映射到列表的其余部分时得到的结果。
Dialogue: 0,0:30:40.33,0:30:43.53,*Default,NTP,0000,0000,0000,,例如，如果我映射一个函数
Dialogue: 0,0:30:44.17,0:30:47.77,*Default,NTP,0000,0000,0000,,将每个元素从 5 中减去
Dialogue: 0,0:30:47.87,0:30:49.30,*Default,NTP,0000,0000,0000,,的函数映射到列表一二
Dialogue: 0,0:30:50.07,0:30:52.77,*Default,NTP,0000,0000,0000,,在这个不是尾递归的定义下
Dialogue: 0,0:30:53.47,0:30:55.10,*Default,NTP,0000,0000,0000,,我们从列表 one two 开始
Dialogue: 0,0:30:55.10,0:30:57.93,*Default,NTP,0000,0000,0000,,在第一次调用 map 时将其绑定到 s
Dialogue: 0,0:30:58.50,0:31:01.37,*Default,NTP,0000,0000,0000,,第二次调用 map 将 s 的其余部分
Dialogue: 0,0:31:01.73,0:31:04.33,*Default,NTP,0000,0000,0000,,的其余部分
Dialogue: 0,0:31:06.07,0:31:07.50,*Default,NTP,0000,0000,0000,,现在
Dialogue: 0,0:31:07.93,0:31:11.33,*Default,NTP,0000,0000,0000,,从第三次调用返回的最终结果是零
Dialogue: 0,0:31:11.57,0:31:12.73,*Default,NTP,0000,0000,0000,,但第二次调用
Dialogue: 0,0:31:12.77,0:31:14.97,*Default,NTP,0000,0000,0000,,返回一个以 3 开头的 list
Dialogue: 0,0:31:15.33,0:31:18.07,*Default,NTP,0000,0000,0000,,而第三次调用则开始一个以 4 开头的列表
Dialogue: 0,0:31:18.07,0:31:21.50,*Default,NTP,0000,0000,0000,,所以 4 是 5 减 1，3 是 2-1
Dialogue: 0,0:31:21.50,0:31:22.97,*Default,NTP,0000,0000,0000,,这就是我们在这里计算的结果
Dialogue: 0,0:31:24.40,0:31:26.97,*Default,NTP,0000,0000,0000,,所以这不是尾递归，因为
Dialogue: 0,0:31:27.40,0:31:29.70,*Default,NTP,0000,0000,0000,,我们为所有 if
Dialogue: 0,0:31:30.53,0:31:32.17,*Default,NTP,0000,0000,0000,,但在 cons
Dialogue: 0,0:31:32.37,0:31:34.37,*Default,NTP,0000,0000,0000,,不是尾部上下文
Dialogue: 0,0:31:34.40,0:31:36.10,*Default,NTP,0000,0000,0000,,我们有一个子表达式
Dialogue: 0,0:31:36.13,0:31:38.57,*Default,NTP,0000,0000,0000,,调用 map
Dialogue: 0,0:31:40.30,0:31:43.60,*Default,NTP,0000,0000,0000,,所以这里有一个 map 的递归定义
Dialogue: 0,0:31:44.17,0:31:45.60,*Default,NTP,0000,0000,0000,,和你想象的不一样
Dialogue: 0,0:31:46.33,0:31:50.27,*Default,NTP,0000,0000,0000,,通过计算 map 的反向定义 map
Dialogue: 0,0:31:50.40,0:31:53.87,*Default,NTP,0000,0000,0000,,意思与我们想要的完全相同，但顺序相反
Dialogue: 0,0:31:54.40,0:31:56.67,*Default,NTP,0000,0000,0000,,首先检查 s 是否为空
Dialogue: 0,0:31:56.73,0:32:00.47,*Default,NTP,0000,0000,0000,,如果是，我们返回结果，即
Dialogue: 0,0:32:00.87,0:32:04.90,*Default,NTP,0000,0000,0000,,我们已经构建的 m 的反向映射列表
Dialogue: 0,0:32:05.77,0:32:07.87,*Default,NTP,0000,0000,0000,,如果不是空值，我们还有更多工作要做
Dialogue: 0,0:32:07.87,0:32:10.90,*Default,NTP,0000,0000,0000,,那么我们就对 s 的其余部分调用 map reverse
Dialogue: 0,0:32:11.13,0:32:13.10,*Default,NTP,0000,0000,0000,,这就是我们要做的其他工作
Dialogue: 0,0:32:14.10,0:32:15.70,*Default,NTP,0000,0000,0000,,我们接下来要做的是
Dialogue: 0,0:32:15.70,0:32:19.10,*Default,NTP,0000,0000,0000,,映射列表的下一个元素
Dialogue: 0,0:32:19.73,0:32:22.10,*Default,NTP,0000,0000,0000,,映射列表的下一个元素。
Dialogue: 0,0:32:22.10,0:32:25.27,*Default,NTP,0000,0000,0000,,调用 s 的车的存储过程的结果。
Dialogue: 0,0:32:26.07,0:32:26.87,*Default,NTP,0000,0000,0000,,和
Dialogue: 0,0:32:27.87,0:32:29.20,*Default,NTP,0000,0000,0000,,剩下的就是
Dialogue: 0,0:32:29.20,0:32:31.60,*Default,NTP,0000,0000,0000,,这就是我们目前构建的 m
Dialogue: 0,0:32:32.53,0:32:34.17,*Default,NTP,0000,0000,0000,,所以一开始我们要先添加一个零
Dialogue: 0,0:32:34.20,0:32:36.07,*Default,NTP,0000,0000,0000,,我们先把 4 加进去
Dialogue: 0,0:32:36.07,0:32:37.80,*Default,NTP,0000,0000,0000,,然后再加上 3
Dialogue: 0,0:32:38.17,0:32:40.67,*Default,NTP,0000,0000,0000,,这样我们的列表就有了相反的顺序
Dialogue: 0,0:32:41.40,0:32:46.57,*Default,NTP,0000,0000,0000,,最后，我们需要在地图上调用 "逆转"，"逆转 "为 "否
Dialogue: 0,0:32:47.30,0:32:49.40,*Default,NTP,0000,0000,0000,,因为这是一个故事语境
Dialogue: 0,0:32:49.60,0:32:51.87,*Default,NTP,0000,0000,0000,,整件事都是在故事语境中进行的
Dialogue: 0,0:32:51.87,0:32:53.47,*Default,NTP,0000,0000,0000,,所以要调用
Dialogue: 0,0:32:53.90,0:32:55.50,*Default,NTP,0000,0000,0000,,这个调用不是
Dialogue: 0,0:32:55.70,0:32:58.10,*Default,NTP,0000,0000,0000,,但注意这不是对 map 的递归调用
Dialogue: 0,0:32:58.17,0:33:00.67,*Default,NTP,0000,0000,0000,,而是调用 map reverse，这是一个在恒定空间内运行的尾递归过程。
Dialogue: 0,0:33:01.60,0:33:05.40,*Default,NTP,0000,0000,0000,,是一个在恒定空间中运行的尾部递归过程
Dialogue: 0,0:33:06.60,0:33:07.77,*Default,NTP,0000,0000,0000,,那么反向呢？
Dialogue: 0,0:33:07.77,0:33:08.00,*Default,NTP,0000,0000,0000,,那么
Dialogue: 0,0:33:08.00,0:33:10.30,*Default,NTP,0000,0000,0000,,我们需要确保它也是尾递归的
Dialogue: 0,0:33:10.37,0:33:13.13,*Default,NTP,0000,0000,0000,,下面是反转列表的定义
Dialogue: 0,0:33:13.93,0:33:15.40,*Default,NTP,0000,0000,0000,,我们定义
Dialogue: 0,0:33:15.53,0:33:19.90,*Default,NTP,0000,0000,0000,,reverse iter，它使用 s 和目前的反向列表
Dialogue: 0,0:33:20.20,0:33:21.87,*Default,NTP,0000,0000,0000,,我们要做的是将
Dialogue: 0,0:33:21.87,0:33:25.00,*Default,NTP,0000,0000,0000,,将 s 的反转版本转换为 r
Dialogue: 0,0:33:26.33,0:33:29.50,*Default,NTP,0000,0000,0000,,所以如果 s 为空，就只有 r，否则
Dialogue: 0,0:33:30.07,0:33:32.73,*Default,NTP,0000,0000,0000,,我们对 s 的其余部分调用 reverse hitter
Dialogue: 0,0:33:32.73,0:33:35.37,*Default,NTP,0000,0000,0000,,将 s 的第一个元素转换到 r 上
Dialogue: 0,0:33:35.77,0:33:37.07,*Default,NTP,0000,0000,0000,,仔细想想
Dialogue: 0,0:33:37.07,0:33:38.97,*Default,NTP,0000,0000,0000,,你会发现这将逆转列表
Dialogue: 0,0:33:39.17,0:33:42.47,*Default,NTP,0000,0000,0000,,如果我一开始用 nil 作为我的反向列表
Dialogue: 0,0:33:42.47,0:33:44.57,*Default,NTP,0000,0000,0000,,和 s 作为我要逆转的元素
Dialogue: 0,0:33:47.67,0:33:50.27,*Default,NTP,0000,0000,0000,,所以这是一个更复杂的例子
Dialogue: 0,0:33:50.53,0:33:53.97,*Default,NTP,0000,0000,0000,,使存储过程尾部递归
Dialogue: 0,0:33:54.73,0:33:56.00,*Default,NTP,0000,0000,0000,,有两个步骤
Dialogue: 0,0:33:56.00,0:33:57.33,*Default,NTP,0000,0000,0000,,我们必须弄清楚
Dialogue: 0,0:33:57.53,0:33:58.57,*Default,NTP,0000,0000,0000,,如何确保
Dialogue: 0,0:33:58.57,0:33:59.97,*Default,NTP,0000,0000,0000,,我们可以建立一个
Dialogue: 0,0:33:59.97,0:34:02.27,*Default,NTP,0000,0000,0000,,的元素进行映射
Dialogue: 0,0:34:04.13,0:34:06.57,*Default,NTP,0000,0000,0000,,从而收集所有结果
Dialogue: 0,0:34:07.80,0:34:08.47,*Default,NTP,0000,0000,0000,,然后
Dialogue: 0,0:34:08.47,0:34:11.10,*Default,NTP,0000,0000,0000,,我们意识到，我将以相反的顺序来构建它
Dialogue: 0,0:34:11.10,0:34:14.60,*Default,NTP,0000,0000,0000,,因为在建立递归列表时
Dialogue: 0,0:34:14.60,0:34:15.90,*Default,NTP,0000,0000,0000,,从后面到前面
Dialogue: 0,0:34:15.97,0:34:18.87,*Default,NTP,0000,0000,0000,,你是在处理从前向后的输入。
Dialogue: 0,0:34:19.37,0:34:20.97,*Default,NTP,0000,0000,0000,,因此我们定义了
Dialogue: 0,0:34:21.27,0:34:23.87,*Default,NTP,0000,0000,0000,,以便得到我们想要的结果
Dialogue: 0,0:34:27.30,0:34:29.00,*Default,NTP,0000,0000,0000,,我们今天的最后一个想法是
Dialogue: 0,0:34:29.00,0:34:30.53,*Default,NTP,0000,0000,0000,,我们在创建解释器时
Dialogue: 0,0:34:30.53,0:34:32.20,*Default,NTP,0000,0000,0000,,当我们创建一个解释器时
Dialogue: 0,0:34:32.60,0:34:35.10,*Default,NTP,0000,0000,0000,,我们在创建一个通用的计算机器
Dialogue: 0,0:34:36.00,0:34:37.37,*Default,NTP,0000,0000,0000,,因此，我们可以打个比方
Dialogue: 0,0:34:37.50,0:34:40.30,*Default,NTP,0000,0000,0000,,把程序看作是定义小机器
Dialogue: 0,0:34:40.50,0:34:42.40,*Default,NTP,0000,0000,0000,,通过制定程序
Dialogue: 0,0:34:42.87,0:34:46.77,*Default,NTP,0000,0000,0000,,我们通过对输入进行运算来输出结果
Dialogue: 0,0:34:47.47,0:34:48.80,*Default,NTP,0000,0000,0000,,所以程序指定了
Dialogue: 0,0:34:48.80,0:34:51.33,*Default,NTP,0000,0000,0000,,某种计算设备的逻辑
Dialogue: 0,0:34:51.70,0:34:55.37,*Default,NTP,0000,0000,0000,,因此，如果我们创建一个计算阶乘的设备
Dialogue: 0,0:34:55.47,0:34:56.97,*Default,NTP,0000,0000,0000,,那么它可能是这样的
Dialogue: 0,0:34:57.60,0:34:58.70,*Default,NTP,0000,0000,0000,,或者说
Dialogue: 0,0:34:59.53,0:35:01.87,*Default,NTP,0000,0000,0000,,如果输入是 1
Dialogue: 0,0:35:02.20,0:35:03.70,*Default,NTP,0000,0000,0000,,那么我们只有一个
Dialogue: 0,0:35:04.40,0:35:08.13,*Default,NTP,0000,0000,0000,,否则，我们必须将输入乘以
Dialogue: 0,0:35:08.53,0:35:12.13,*Default,NTP,0000,0000,0000,,乘以 1，即输入的阶乘
Dialogue: 0,0:35:13.70,0:35:15.20,*Default,NTP,0000,0000,0000,,这里的阶乘
Dialogue: 0,0:35:15.30,0:35:17.33,*Default,NTP,0000,0000,0000,,当然只是
Dialogue: 0,0:35:17.37,0:35:19.67,*Default,NTP,0000,0000,0000,,的另一个副本
Dialogue: 0,0:35:20.93,0:35:24.90,*Default,NTP,0000,0000,0000,,因此，5 乘以 1120，得出 5 的阶乘
Dialogue: 0,0:35:26.13,0:35:29.30,*Default,NTP,0000,0000,0000,,解释器就像普通的计算器
Dialogue: 0,0:35:29.53,0:35:31.90,*Default,NTP,0000,0000,0000,,所以解释器接受输入
Dialogue: 0,0:35:33.00,0:35:35.67,*Default,NTP,0000,0000,0000,,任何一段代码，告诉它模拟
Dialogue: 0,0:35:35.67,0:35:37.67,*Default,NTP,0000,0000,0000,,我们想要的任何特定机器
Dialogue: 0,0:35:38.47,0:35:39.90,*Default,NTP,0000,0000,0000,,所以方案解释器
Dialogue: 0,0:35:39.90,0:35:41.77,*Default,NTP,0000,0000,0000,,可能会将五段代码作为输入
Dialogue: 0,0:35:41.77,0:35:43.17,*Default,NTP,0000,0000,0000,,的源代码
Dialogue: 0,0:35:43.17,0:35:45.60,*Default,NTP,0000,0000,0000,,告诉我们如何计算阶乘的源代码。
Dialogue: 0,0:35:46.07,0:35:48.97,*Default,NTP,0000,0000,0000,,并同时使用这两部分内容
Dialogue: 0,0:35:48.97,0:35:51.20,*Default,NTP,0000,0000,0000,,以创建我们想要的任何计算
Dialogue: 0,0:35:51.20,0:35:52.00,*Default,NTP,0000,0000,0000,,我们所希望的
Dialogue: 0,0:35:52.60,0:35:54.97,*Default,NTP,0000,0000,0000,,例如计算 120
Dialogue: 0,0:35:55.67,0:35:57.77,*Default,NTP,0000,0000,0000,,因此，我们已经构建或正在构建的方案解释器
Dialogue: 0,0:35:57.77,0:35:59.93,*Default,NTP,0000,0000,0000,,或我们正在构建的
Dialogue: 0,0:35:59.97,0:36:01.13,*Default,NTP,0000,0000,0000,,作为你的项目
Dialogue: 0,0:36:01.27,0:36:02.67,*Default,NTP,0000,0000,0000,,是一个通用机器
Dialogue: 0,0:36:02.67,0:36:05.10,*Default,NTP,0000,0000,0000,,它可以执行我们想要的任何计算
Dialogue: 0,0:36:05.20,0:36:07.20,*Default,NTP,0000,0000,0000,,这取决于
Dialogue: 0,0:36:07.20,0:36:09.60,*Default,NTP,0000,0000,0000,,输入源代码的参数化方式而定
Dialogue: 0,0:36:10.97,0:36:12.17,*Default,NTP,0000,0000,0000,,因此，可以把它看作是
Dialogue: 0,0:36:12.17,0:36:12.93,*Default,NTP,0000,0000,0000,,数据
Dialogue: 0,0:36:12.93,0:36:14.33,*Default,NTP,0000,0000,0000,,对象之间的桥梁
Dialogue: 0,0:36:14.33,0:36:15.70,*Default,NTP,0000,0000,0000,,和编程语言本身之间的桥梁
Dialogue: 0,0:36:15.97,0:36:18.27,*Default,NTP,0000,0000,0000,,和编程语言本身之间的桥梁
Dialogue: 0,0:36:18.70,0:36:21.27,*Default,NTP,0000,0000,0000,,它是将两者结合在一起的东西
Dialogue: 0,0:36:22.40,0:36:23.47,*Default,NTP,0000,0000,0000,,但在内部
Dialogue: 0,0:36:23.47,0:36:26.17,*Default,NTP,0000,0000,0000,,请记住，它只是一套评估规则
Dialogue: 0,0:36:26.50,0:36:29.33,*Default,NTP,0000,0000,0000,,解释器只不过是一个程序
